<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ubuntu无法升级Nodejs</title>
    <link href="/2022/08/06/Ubuntu%E6%97%A0%E6%B3%95%E5%8D%87%E7%BA%A7Nodejs/"/>
    <url>/2022/08/06/Ubuntu%E6%97%A0%E6%B3%95%E5%8D%87%E7%BA%A7Nodejs/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>apt-get默认下载的是8.10版本的NodeJS，顺带npm的版本同样是3.xx，常规升级后提示 installed 已安装新版本，但node -v后发现仍然是旧版本。这是是因为新下载的node在其他位置，因此只需注意更改变量位置或添加新位置到profile即可。</p><p>错误提示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">error</span>：The engine node is incompatible with this module. Expected version ^<span class="hljs-number">6</span>.<span class="hljs-number">14</span>.<span class="hljs-number">0</span> || ^<span class="hljs-number">8</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span> || &gt;=<span class="hljs-number">9</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span>. Got <span class="hljs-number">9</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span>y　<br></code></pre></td></tr></table></figure><p>意思很明显，版本不匹配</p><p>更新node版本：</p><p>清除npm缓存：npm cache clean -f</p><p>安装n模块：npm install -g n</p><p>安装官方稳定版本：n stable</p><p>安装最新官方版本：n latest</p><p>安装某个指定版本：n 11.6.0</p><p>查看已安装的node版本: n</p><p>查看当前node版本：node -v</p><p>删除指定版本：n rm 7.5.0</p><p>指定版本执行脚本：n use 7.5.0 index.js</p><p>发现当前版本不是最新的版本，然后已经安装有了最新的版本，造成不生效的原因：</p><p>node默认的安装目录与使用管理工具n安装的目录不一致</p><p>解决方法：</p><p>查看当前node安装路径：which node</p><p>我的当前安装路径是：/usr/local/Cellar/node/9.5.0/bin/node</p><p>而 n 默认安装路径是 /usr/local，需要通过通过N_PREFIX变量来修改 n 的默认node安装路径。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806205242.png"></p><p>编辑环境配置文件：vim ~/.bash_profile</p><p>修改node安装位置：在末尾增加export PATH=/usr/local/bin:$PATH shift+:wq 保存退出</p><p>让新配置生效：socuce ~/.bash_profile</p><p>重新安装稳定版本：n stable</p><p>查看当前node版本：node -v (已经是最新的稳定版本了)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu22.04桌面版配置Clash for Linux</title>
    <link href="/2022/08/06/Ubuntu22-04%E6%A1%8C%E9%9D%A2%E7%89%88%E9%85%8D%E7%BD%AEClash-for-Linux/"/>
    <url>/2022/08/06/Ubuntu22-04%E6%A1%8C%E9%9D%A2%E7%89%88%E9%85%8D%E7%BD%AEClash-for-Linux/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>近来将电脑的windows换成了Ubuntu桌面版，第一件事自然是挂上tizi。查了一下通用做法就是配置Clash，这里也留个记录，供需要的同学参考。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>去github仓库下载最新版本即可:<a href="https://github.com/Dreamacro/clash/releases">https://github.com/Dreamacro/clash/releases</a></p><p>注意系统架构，我这里下的是clash-freebsd-amd64-v3-v1.11.0.gz</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204455.png"></p><p>到gz包的下载目录去解压，将解压出来的文件放在/usr/local/bin/下，改名为clash</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gunzip</span> clash-linux-amd64-v1.<span class="hljs-number">7</span>.<span class="hljs-number">1</span>.gz``mv` `clash-linux-amd64-v1.<span class="hljs-number">7</span>.<span class="hljs-number">1</span> ``/usr/local/bin/clash<br></code></pre></td></tr></table></figure><p>　　</p><p>先赋个权，再直接执行clash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x clash<br><br>clash<br></code></pre></td></tr></table></figure><p>　　</p><p>如此稍等一会儿，重新打开一个终端，查看一下~/.config/clash这个目录是否生成了下面3个文件。这其中config.yaml和Country.db是我们需要配置的。这三个文件如果已经生成，则上面的clash进程可以暂时关掉了。后面配置好了yaml再重新启动</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204526.png"></p><h2 id="配置yaml"><a href="#配置yaml" class="headerlink" title="配置yaml"></a>配置yaml</h2><p>重点来了，来到~/.config/clash目录下， 准备好订阅链接，然后执行下载clash配置文件的操作。这2个操作执行后，会有进度条显示，并且最后是完成的状态。</p><p>这个步骤有任何提示错误都代表不对的。另外，还有一种情况就是有的人开启了代理，网络不通，这里自然也就不通。因此这两步一定要确保网络是正常的</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">wget -<span class="hljs-symbol">O</span> config.yaml [订阅链接]<span class="hljs-string">``</span>wget -<span class="hljs-symbol">O</span> <span class="hljs-symbol">Country</span>.mmdb https:<span class="hljs-string">``</span>//www<span class="hljs-string">``</span>.sub-speeder.com<span class="hljs-string">``</span>/client-download/<span class="hljs-symbol">Country</span><span class="hljs-string">``</span>.mmdb<br><br></code></pre></td></tr></table></figure><p>注意，这里的订阅链接<strong>不是直接用各个平台给的那种通用的</strong>（或者是酸酸乳ssr用的），而是<strong>需要转换</strong>一下。</p><p>普通的订阅链接经过浏览器打开后是显示一串字符串，这种一般是酸酸乳用的，而这里clash需要的配置文件是yaml格式，这种格式有点类似json，是键值对格式的。所以很多人直接在这里直接用ssr用的，后面执行clash -d的时候就会提示下面这样的错误</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">FATA[<span class="hljs-number">0000</span>] Parse config error: yaml: unmarshal errors: line <span class="hljs-number">1</span>: cannot unmarshal !!str `c3M6Ly9...` into config.RawConfig<br></code></pre></td></tr></table></figure><p>目前我所了解的情况是，通过在线订阅转换工具，例如下面的 <a href="http://www.flyjiang.cn/">http://www.flyjiang.cn/</a> 来转换Clash类型的订阅地址。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204540.png"></p><p>将平台给的地址粘贴在订阅链接的框框里，类型选择Clash，点击生成订阅链接，定制订阅里会生成一个长链，这个链我试了一下不能用。因此再点击生成短链接，在订阅短链那一栏就会生成一条短链，把它拿到地址栏用浏览器访问一下，如下图所示，会发现这就是一个yaml格式的文件，因此我们需要的就是这玩意儿。</p><p>把这个短链拿到上面步骤去，生成yaml配置文件。（不用复制网页内容，直接用wget下载即可）</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204559.png"></p><p> 重新回到/usr/local/bin/下面，根据配置文件执行clash</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">clash -d ~<span class="hljs-regexp">/.config/</span>clash/<br></code></pre></td></tr></table></figure><p>此时执行成功的话会产生大量的类似刚才浏览器访问短链的实时日志，在访问互联网的过程中也会一直产生日志，这个是正常的。这个进程所在的终端也不要关闭，关闭了就没法用的。然后，据说访问<a href="http://clash.razord.top/#/proxies">http://clash.razord.top/#/proxies</a> 可以查看节点情况、测试延迟等等，但设置了密码后还是不能登录，就没有再测试了</p><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><p>打开系统设置，选择网络，点击网络代理右边的设置按钮，选择手动，填写 HTTP 和 HTTPS 代理为 0.0.0.0:7890，填写 Socks 主机为 0.0.0.0:7891，即可启用系统代理。启用后尝试一下访问网站，应该就可以用了</p><p>注意：clash进程和网络代理同时开启，才可以正常上网。如果clash开启但网络代理关闭，则无法使用，甚至连正常的网络都没法打开，这一点蛮坑的，所以最好设置clash开机自启，不然会比较麻烦</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204633.png"></p><p>但是开启自启我搞了半天也没搞好，查看clash的状态的时候也是没有启动、失败的，有经验的朋友也可以留言告知一下，不胜感激</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>区块链学习大纲</title>
    <link href="/2022/08/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <url>/2022/08/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>区块链一般表示为一个单链列表，区块链中的块相当于链表中的Node节点，节点之间使用哈希串联形成链。区块链上的数据基本不可能修改，比普通链表要复杂得多</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>区块链中使用Merkle Tree即默克尔树。是二叉树的一种，最底层是叶子节点，内容是对应数据的哈希。每两片相邻的叶子结点加起来做哈希计算，计算结果为上层节点的内容，这样持续计算就会产生一个最顶端的哈希值，该值被放在比特币的区块头中。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204245.png"></p><p>主要用于验证一个交易已经存在对应的区块中，一般来说，验证交易需要搭建节点下载和同步区块链数据后根据哈希值查询，这样既占用空间和验证计算量都较大。如果使用Merkle Tree，可直接下载块头数据即可验证</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204257.png"></p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>Bloom Filter即布隆过滤器。它是一种基于概率的数据结构，主要用来判断某个元素是否在集合内，它具有运行速度快（时间效率），占用内存小的优点（空间效率），但是有一定的误识别率和删除困难的问题。它能够告诉你某个元素一定不在集合内或可能在集合内。</p><p>在比特币网络中，轻节点客户端查找自己账户地址相关的UTXO时需要用到。客户端通过过滤器告诉全节点自己的地址信息，全节点返回结果可能相关的UTXO，过滤器过滤掉了不属于该地址的UTXO。保护隐私、节省带宽</p><hr><h4 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h4><p>即哈希算法、散列算法，一个单项函数，可以将任意长度的输入数据转化为固定长度的输出。将一个输入给哈希，会很快计算出来一个输出，但一个输出无法反推输入，只能暴力穷举，这种概率非常小。如果两个输入数据不同但哈希相同，则发生了哈希碰撞。</p><p>区块链中，哈希算法主要用于防止交易被篡改，交易经过哈希算法计算写入MerkleTree<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204312.png"></p><h4 id="非对称加密与数字签名"><a href="#非对称加密与数字签名" class="headerlink" title="非对称加密与数字签名"></a>非对称加密与数字签名</h4><p>非对称加密中有连个密钥，公钥和私钥，是一对。如果使用公钥加密，那必须用对应的私钥解密；如果对私钥加密，那必须用对应公钥解密。非对称加密信息传输过程如下：</p><ol><li>A要向B发送信息，A和B都要产生一对用于加密、解密的公钥和私钥</li><li>A保管自己的私钥，把公钥告诉B；B保管自己的私钥，把公钥告诉A</li><li>A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥</li><li>A将这个消息发给B（已经用B的公钥加密消息）</li><li>B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204330.png"></li></ol><p>数字签名有两个算法：签名、验证。签名就是使用私钥处理信息或因为信息的哈希而产生的签名，验证就是使用公钥验证签名的真实性。整个验证过程如下：</p><ol><li>张三在比特币转账前需要将交易信息缩短成一段字符串，用自己的私钥进行加密以形成数字签名</li><li>张三会将交易信息、数字签名和公钥都广播出去，矿工会将这些记录下来，并用张三的公钥进行验证</li><li>如果验证成功就证明该笔交易确实是由张三发出的，之后接受转账者李四会收到比特币</li></ol><p>在区块链中，非对称加密和数字签名利用公私钥对加密，可以保证数据安全。</p><p>分布式网络：</p><h4 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h4><ul><li>传统Client-Server模式是中心化网络，资源集中，海量访问时可能受限</li><li>P2P网络是去中心化的，各节点可直接通信，节点既是服务器又是客户端</li><li>P2P架构下是无信任的，用户无需担心隐私泄露，且通信加密，安全</li><li>节点间的直接通信，效率较高</li><li>目前的应用：文件共享（如种子下载）、区块链应用</li></ul><h4 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h4><p>共识算法是允许用户或机器在分布式环境中协调关系的机制，它需要确保系统中的所有代理对单一事实来源能够最终达成一致意见（即使某些代理持反对意见），也就是说，系统必须具有良好的容错性。经典的共识概念可以参考拜占庭将军问题。</p><p>目前我们国家的货币系统是一个记账货币，例如支付宝扫码支付，其中并没有进行实际的货币转移，而是支付宝在它的数据库里记了一笔账，这就是中心化的记账方式。这种方式效率很高，但也存在一系列问题，如中心化节点引发的错误等黑天鹅事件，一般的解决方案就是做备份、对人员进行SOP培训，或者使用更可靠、安全的系统。</p><p>去中心化记账系统中，每个区块都记录着很多交易，这种系统有很多优点，但其中一个很重要的问题就是各节点账本的一致性。因为每加入这个系统的节点都需要保存一份完整的账本，但却不能有两个节点同时记账，因为节点处于不同的环境，接收到的交易信息不一致，如果同时记账就会导致账本的不一致。所以，需要通过共识机制决定让哪个节点来记账，目前常用的就是POW、POS等</p><h5 id="POW工作量证明"><a href="#POW工作量证明" class="headerlink" title="POW工作量证明"></a>POW工作量证明</h5><p>例如，工作面试中，招聘网站写着岗位需要本科学历，如何证明是本科毕业生？只要将本科毕业证给面试官看就行了。但是你要拿到本科毕业证需要上4年大学、在此之前还要上3年高中、初中小学，中途要上课、考试，还不能挂科。这是一个艰辛的过程，但对于面试官而言，只要展示出毕业证就可以证明你上过大学。这种获取困难但验证简单的不对称性也是POW的特点。它<strong>通过对一个区块链头部中的父区块哈希、MerkleTree树根、nonce值三个字段进行哈希运算</strong>，如果结果小于目标值则计算成功，如果大于目标值则改变nonce值，重复运算直到结果小于目标值为止</p><p>区块头部信息：</p><table><thead><tr><th align="center">字段名</th><th align="center">长度/字节</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">version</td><td align="center">4</td><td align="center">版本号</td></tr><tr><td align="center">prev_hash</td><td align="center">32</td><td align="center">前一区块哈希</td></tr><tr><td align="center">merkle_root</td><td align="center">32</td><td align="center">区块体中交易的Merkle树的根节点的哈希</td></tr><tr><td align="center">time</td><td align="center">4</td><td align="center">当前区块生成时间，时间戳</td></tr><tr><td align="center">terget</td><td align="center">4</td><td align="center">当前目标值</td></tr><tr><td align="center">nonce</td><td align="center">4</td><td align="center">随机数</td></tr></tbody></table><h5 id="POS权益证明"><a href="#POS权益证明" class="headerlink" title="POS权益证明"></a>POS权益证明</h5><p>参与比特币挖矿的人越来越多，PoW的许多问题逐渐显现，例如随着算力竞争迅速加剧，获取代币需要消耗的能源大量增加，记账权也逐渐向聚集了大量算力的“矿池”集中。为此研究者尝试采用新的机制取代工作量证明。POS最早的应用是点点币，它出了币龄的概念，币龄是持有的代币与持有时间乘积的累加。利用币龄竞争取代算力竞争，使区块链的证明不再仅仅依靠工作量，有效地解决了PoW的资源浪费问题。关于POS可详见百度</p><p><img src="https://img2022.cnblogs.com/blog/1560490/202205/1560490-20220531160019464-766728807.png" alt="img"></p><p>在区块链中，共识算法可以解决两个问题：双花问题和拜占庭将军问题</p><h4 id="并行计算模型"><a href="#并行计算模型" class="headerlink" title="并行计算模型"></a>并行计算模型</h4><p>在区块链系统中，交易是组成事务的基本单元。交易吞吐量（TPS）很大程度上能限制或拓宽区块链业务的适用场景，愈高的吞吐量，意味着区块链能够支持愈广的适用范围和愈大的用户规模。业界的TPS优化方案层出不穷，但都是为了尽可能提交交易的并行处理能力，降低交易处理时间。如FISCO BCOS基于DAG模型的并行交易引擎等</p><p>事务一致性原理</p><p>一致性是指分布式系统中（如区块链）的多个服务节点，给定一系列的操作，在约定协议的保障下，<strong>使它们对外界呈现的状态是一致的</strong>。换句话说，也就是保证<strong>集群中所有服务节点中的数据完全相同并且能够对某个提案（Proposal）达成一致</strong></p><p><strong>注意</strong>：共识性描述的是节点之间彼此对某个状态达成一致结果的过程，而一致性是指多个节点对外呈现的数据的状态，描述的是对数据状态的维护能力。也就是说，一致性描述的是结棍状态，共识则是一种手段。达成共识并不意味着保证了一致性，只能说共识机制能够实现某种程度上的一致性。在实际应用中，如果要保证系统满足不同程度的一致性，往往需要通过共识算法来达成</p><h5 id="一致性的要求"><a href="#一致性的要求" class="headerlink" title="一致性的要求"></a>一致性的要求</h5><ul><li>达成一致的结果在有限的时间内完成，简称为<strong>有限性</strong></li><li>不同节点最终完成决略的结果是相同的，即<strong>约同性</strong></li><li>决策的结果必须是系统中某个节点提出来的。即<strong>合法性</strong>。</li></ul><p>在分布式系统中，如果一个由节点提出的提案，能够用在有限的时间内达到一致性的结果，我们就说该提案达到了一致性</p><h5 id="一致性的分类"><a href="#一致性的分类" class="headerlink" title="一致性的分类"></a>一致性的分类</h5><ul><li>严格一致性<ul><li>理想状态，对于某数据项的任何读写操作将返回最近一次对它进行的写操作的结果所对应的值，依赖于绝对的全局时间。严格一致性在系统不发生任何故障，且所有节点之间的通信无需任何时间这种理想的条件下才能达到，这时候整个分布式系统相当于一台机器。这在现实中基本不可能达到，且一致性越强往往导致处理性能、可扩展性弱</li></ul></li><li>强一致性<ul><li>标准：当分布式系统中更新操作完成之后，任何多个进程或线程，访问系统都会获得最新的值</li><li>强一致性包括以下两类<ul><li>顺序一致性</li><li>线性一致性</li></ul></li></ul></li><li>弱一致性<ul><li>系统并不保证后续进程或线程的访问都会返回最新的更新的值。系统在数据成功吸入之后，不承诺立即可以读到最新写入的值，也不会具体承诺多久读到。但是<strong>会尽可能保证在某个时间级别（秒级）之后</strong>。可以让数据达到一致性状态。也就是说，如果能容忍后续的部分或者全部访问不到，则是弱一致性</li></ul></li><li>最终一致性<ul><li>弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。 也就是说，如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。在最终一致性的要求下，如果没有故障发生，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS是一个典型的最终一致性系统。</li></ul></li></ul><hr><h4 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h4><p>多个个体之间的收益与奖励、以及如何使用它们来分析一次性和持续性游戏中的激励因素。博弈论应用到区块链的核心就是共识机制——让链上所有成员就同一问题达成一致：<strong>纳什均衡、谢林点</strong>。博弈论是研究战略决策的理论，一个博弈论模型至少有三个组成部分：</p><ol><li>决策者，例如公司董事长</li><li>战略，为了推动发展而做出的决定</li><li>回报，策略的结果</li></ol><p>博弈论中的2种类型：</p><ol><li>零和游戏：以牺牲另一个玩家为代价换取一个玩家的收益的游戏</li><li>非零和游戏：一个玩家的收益不以另一个玩家的损失为代价的游戏</li></ol><p>纳什均衡：博弈论的一个解决方案，假设每个参与者都知道其他参与者的策略的情况下，没有参与者可以通过改变自身策略使自身受益时的一个概念。</p><p>谢林点：同样是博弈论的一个解决方案，指人们在没有沟通的情况下的选择倾向，做出这一选择可能因为它<strong>看起来自然、特别、或者与选择者有关</strong>。</p><ul><li>例如，两人驱车相对而行，如果两车相撞，两人均死于车祸；如一方转弯，而另一方没有，则转弯的一方被耻笑为胆小鬼，另一方胜出。这种情况下使用谢林点的概念来解决问题，即开车时闭上眼睛，切断与对方的沟通，专注自己本能。在现实生活中，车子一般靠右行驶，直接会让各自均靠右边行驶。</li><li>在生活中，有各种聚焦点，如公司、小区门口、奶茶店等，这些地方都属于谢林点</li></ul><p>补充：有限理性概念：</p><p>例如小明每天都去水果店买一个苹果，每次来店主都会离开5分钟，且店里没有监控，他可以很容易地偷到一个苹果，但他从来没有这样做过。有限理性概念意味着当有选择的时候，<strong>人们总是会选择一条简单且习惯的道路</strong>。这条道路可能不是最适合他们的，也可能不会给他们最高的回报，却是<strong>最简单的道路</strong></p><h4 id="区块链、加密货币中的博弈理论"><a href="#区块链、加密货币中的博弈理论" class="headerlink" title="区块链、加密货币中的博弈理论"></a>区块链、加密货币中的博弈理论</h4><p>区块链使用博弈论来保护系统。例如比特币中的双花攻击，系统本身是没有道德可言的，因为道德无法量化，系统中的大部分节点会接着最长合法链的后面去挖矿，双花攻击的成本很大，根本没有必要去做这件事。从这个方面来看，可以说区块链本身就是一个能够自动执行纳什均衡点的系统</p><p>资料来源：<a href="https://blockgeeks.com/guides/cryptocurrency-game-theory/">https://blockgeeks.com/guides/cryptocurrency-game-theory/</a></p><h4 id="激励相容"><a href="#激励相容" class="headerlink" title="激励相容"></a>激励相容</h4><p>经济学家哈维茨在机制设计理论中提出的，意思是在市场经济中，每个理性经纪人都会有自利的一面，其个人行为灰暗自利的规则行为行动。如果能有一种制度安排使得行为人追求的<strong>个人利益正好与企业实现集体价值最大化的目标相吻合</strong>，这一制度安排就是“激励相容”。</p><p>这通过实施一个博弈规则来达到该目标。激励相容通过经济平衡的手段，鼓励节点参与到维护区块系统安全运行中来，防止对总账本进行篡改，是长期维持区块链网络运行的动力。当集体和个人的利益达到了一个平衡点，这个游戏就会一直持续下去，不会崩塌。</p><p>语言：Sodility、WebAssembly</p><p><a href="https://solidity-cn.readthedocs.io/zh/develop/">https://solidity-cn.readthedocs.io/zh/develop/</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn">https://developer.mozilla.org/zh-CN/docs/Learn</a></p><hr><h5 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h5><p>大部分区块链网络底层仍然使用TCP/IP协议，和HTTP、SMTP协议都处在应用层。经常和P2P对比的是当下最为广泛的HTTP，从C/S架构变更成点对点拓扑结构。比特币的P2P网络非常复杂，这里只了解全节点场景下的网络路由</p><p>比特币P2P网络基于TCP协议，主网默认端口8333。P2P网络拓扑结构本身可有很多种，如中心化、半中心化拓、全分布式。</p><ul><li>比特币全节点组成的网络是一种全分布式的拓扑结构，节点间的传输过程接近“泛洪算法”。</li><li>比特币全节点与SPV简化支付验证客户端之间的交互模式接近半中心化的拓扑结构，SPV随机选择一个全节点连接，这个全节点成为SPV的代理，帮助SPV广播交易</li></ul><h5 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h5><p>节点发现是接入区块链P2P网络的第一步</p><ul><li>初始化节点发现：你的全节点刚下载，首次运行，没有任何节点数据<ul><li>DNS-seed，即DNS 种子节点。例如nslookup seed.bitcoin.sipa.be 会发现多个IPv4主机地址，使用nc命令连接域名下的某个主机的8333端口就会发现连接成功<code>nc -nvv 68.183.188.105 8333 found 0 associations</code></li><li>硬编码种子节点</li></ul></li><li>启动后节点发现：正在运行的钱包已经能跟随网络动态维护可用节点<ul><li>初始节点发现后，你的节点需要向已存在的节点要一份对等节点列表（peer list），所以在每次需要发送协议消息的时候，它会花费固定的时间尝试和已存的节点列表中的节点建立链接，如果有任何一个节点在超时之前可以连接上，就不用去 DNS seed 获取地址</li></ul></li></ul><h5 id="局域网穿透"><a href="#局域网穿透" class="headerlink" title="局域网穿透"></a>局域网穿透</h5><p>局域网里运行的区块链节点，在公网是无法发现的，公网上的节点只能被动接受连接，并不能主动发起连接。通过NAT、UPnP技术可自行建立映射。比特币和以太坊均使用了UPnP协议作为局域网穿透工具（局域网内的路由设备支持NAT网关、支持UPnP协议）</p><ul><li>NAT：源 NAT，替换 TCP 报文中的源地址并映射到内网地址</li><li>UPnP：通用即插即用（Universal Plug and Play）主要用于设备的智能互联互通，所有在网络上的设备马上就能知道有新设备加入</li></ul><h5 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h5><p>一旦节点建立连接以后，节点之间的交互是遵循一些特定的命令，这些命令写在消息的头部，消息体写的则是消息内容。</p><ul><li>请求命令</li><li>数据交互命令</li></ul><h5 id="用Java-SDK接入到区块链"><a href="#用Java-SDK接入到区块链" class="headerlink" title="用Java SDK接入到区块链"></a>用Java SDK接入到区块链</h5><p>官方文档：<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/sdk/java_sdk/quick_start.html">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/sdk/java_sdk/quick_start.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习实践（二）：k-NN算法</title>
    <link href="/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ak-NN%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ak-NN%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="两种监督机器学习问题"><a href="#两种监督机器学习问题" class="headerlink" title="两种监督机器学习问题"></a>两种监督机器学习问题</h3><p>许多算法都有分类和回归两种形式</p><ul><li>分类：预测类别标签<ul><li>二分类：两个类别之间区分<ul><li>正类：需要获得的一类</li><li>反类：不需要的一类</li></ul></li><li>多分类：两个以上的类别区分</li></ul></li><li>回归：预测一个连续值（浮点数或实数），这个值在给定范围内任意取值，不必精确到某一个基体数值</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>泛化：如果一个模型可以对新数据做出准确预测，那么可以说该模型能够从训练集<strong>泛化</strong>到测试集，预测精度即为泛化精度</p><p>拟合：模型预测时对训练集的依赖<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203918.png"></p><ul><li>当模型较为复杂、过分关注细节，在训练集中预测表现很好但不能泛化到新数据时，称之为过拟合</li><li>当模型过于简单，无法抓住数据的全部内容和变化，在训练集上表现很差，称之为欠拟合</li></ul><p>总的来说，模型越复杂，在训练数据上的预测结果就越好；但如果模型过于复杂，<br>去过多关注训练集中每个单独的数据点，模型就不能很好地泛化到新数据上。因此，二者之间存在一个最佳位置，可以得到最佳的泛化性能，这就是我们需要的模型<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203937.png"></p><p>模型复杂度和数据集大小的关系：数据集中包含的数据点的变化范围越大，在不发生过拟合的前提下模型就越复杂（相同或相似的数据点除外）</p><p>其他属于补充：</p><ul><li>特征较少的数据集：低维数据集</li><li>特征较多的数据集：高维数据集（不同维度的数据集中得出的结论可能是不同的，互相不适用）</li><li>特征与特征的乘机也可以作为特征——特征工程：包含导出特征的方法</li></ul><h3 id="k-NN算法——人云亦云"><a href="#k-NN算法——人云亦云" class="headerlink" title="k-NN算法——人云亦云"></a>k-NN算法——人云亦云</h3><p>一种非参、惰性的算法模型：模型本身不会对数据做任何假设，模型结构贴合数据，且训练数据的过程很快</p><h4 id="k近邻分类"><a href="#k近邻分类" class="headerlink" title="k近邻分类"></a>k近邻分类</h4><p><strong>预测过程</strong></p><p>给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例，这K个实例的多数属于某个类，就把该输入实例分类到这个类中</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203949.png"></p><p>图解：单一近邻是k-NN最简单的版本，只需考虑最近距离的点。分类结果就是最近的训练集中的点所在的分类</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203959.png"></p><p>图解：任意(k)个邻居时，采用投票法指定标签，即k个邻居中分类比例占多数的为最后的预测结果</p><p><strong>KNeighborsClassifier的决策边界</strong></p><p>如果是二维数据集，可以再xy平面上画出所有可能的预测结果，根据点的所属类别对平面着色，这样就可以查看决策边界</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>X, y = mglearn.datasets.make_forge()<br>X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="hljs-number">0</span>)<br>clf = KNeighborsClassifier(n_neighbors=<span class="hljs-number">3</span>)<br>clf.fit(X_train, y_train)<br><span class="hljs-built_in">print</span>(clf.predict(X_test))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:.2&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(clf.score(X_test, y_test)))<br>fig, axes=plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>))<br><span class="hljs-keyword">for</span> n_neighbors, ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>], axes):<br>    clf = KNeighborsClassifier(n_neighbors=n_neighbors).fit(X, y)<br>    mglearn.plots.plot_2d_separator(clf, X, fill=<span class="hljs-literal">True</span>, eps=<span class="hljs-number">0.5</span>, ax=ax, alpha=<span class="hljs-number">.4</span>)<br>    mglearn.discrete_scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], y, ax=ax)<br>    ax.set_title(<span class="hljs-string">&quot;&#123;&#125; neighbor(s)&quot;</span>.<span class="hljs-built_in">format</span>(n_neighbors))<br>    ax.set_xlabel(<span class="hljs-string">&quot;feature 0&quot;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&quot;feature 1&quot;</span>)<br>    axes[<span class="hljs-number">0</span>].legend(loc=<span class="hljs-number">3</span>)<br>p1=plt.scatter(X[y==<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], X[y==<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], color=<span class="hljs-string">&#x27;blue&#x27;</span>)<br>p2=plt.scatter(X[y==<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], X[y==<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], color=<span class="hljs-string">&#x27;green&#x27;</span>)<br>p3=plt.scatter(X[y==<span class="hljs-number">2</span>,<span class="hljs-number">0</span>], X[y==<span class="hljs-number">2</span>, <span class="hljs-number">1</span>], color=<span class="hljs-string">&#x27;red&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204015.png"></p><p>图解：当单一邻居决策时，边界紧挨着训练数据点，边界很陡峭；当邻居越来越多，边界越平滑。而更平滑的边界对应的模型也就更简单</p><p><strong>模型复杂度和泛化能力的关系</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-title">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_breast_cancer<br><span class="hljs-title">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-title">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-title">cancer</span> = load_breast_cancer()<br><span class="hljs-type">X_train</span>, <span class="hljs-type">X_test</span>, y_train, y_test = train_test_split(<br><span class="hljs-title">cancer</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>, cancer.target, stratify=cancer.target, random_state=66)</span><br><span class="hljs-title">training_accuracy</span> = []<br><span class="hljs-title">test_accuracy</span> = []<br><span class="hljs-title">neighbors_settings</span> = range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)<br><span class="hljs-title">for</span> n_neighbors <span class="hljs-keyword">in</span> neighbors_settings:<br>    clf = <span class="hljs-type">KNeighborsClassifier</span>(n_neighbors=n_neighbors)<br>    clf.fit(<span class="hljs-type">X_train</span>, y_train)<br>    training_accuracy.append(clf.score(<span class="hljs-type">X_train</span>, y_train))<br>    test_accuracy.append(clf.score(<span class="hljs-type">X_test</span>, y_test))<br><br><span class="hljs-title">plt</span>.plot(neighbors_settings, training_accuracy, label=<span class="hljs-string">&quot;training accuracy&quot;</span>)<br><span class="hljs-title">plt</span>.plot(neighbors_settings, test_accuracy, label=<span class="hljs-string">&quot;test accuracy&quot;</span>)<br><span class="hljs-title">plt</span>.ylabel(<span class="hljs-string">&quot;Accuracy&quot;</span>)<br><span class="hljs-title">plt</span>.xlabel(<span class="hljs-string">&quot;n_neighbors&quot;</span>)<br><span class="hljs-title">plt</span>.legend()<br><span class="hljs-title">plt</span>.show()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204028.png"></p><p>图解：</p><ul><li>当单一邻居时，训练集的预测结果十分准确，而测试集精度很低。这边是单一近邻的模型过于复杂</li><li>随着邻居增多，模型变得简单，训练集的精度逐渐下降。当近邻达到10时，模型又过于简单，性能变差</li><li>最佳的性能在中间的某一处，途中大概在6处，测试集与训练集预测结果最为接近</li></ul><p>k近邻回归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>mglearn.plots.plot_knn_regression(n_neighbors=<span class="hljs-number">1</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>单个和多个近邻预测结果如下：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204043.png"></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204056.png"></p><p>sklearn中KNeighborsRegressor类实现回归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br>X, y = mglearn.datasets.make_wave(n_samples=<span class="hljs-number">40</span>)<br><span class="hljs-comment"># 将wave数据集分为训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 模型实例化，并将邻居个数设为3</span><br>reg = KNeighborsRegressor(n_neighbors=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># 利用训练数据和训练目标值来拟合模型</span><br>reg.fit(X_train, y_train)<br><br><span class="hljs-comment"># 预测测试集</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set predictions:\n&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(reg.predict(X_test)))<br><br><span class="hljs-comment"># 评估模型，返回的是R2分数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test set R^2: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(reg.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><p>回归模型同样适用score方法来评估模型，返回的是R2分数，R2分数就是决定系数，是回归模型预测的优度度量，位于1~0之间，当为1时就是完美预测，等于0就是常数模型，即只能预测训练集的平均值</p><p><strong>分析KNeighborsRegressor</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br><span class="hljs-keyword">import</span> mglearn<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br>X, y = mglearn.datasets.make_wave(n_samples=<span class="hljs-number">40</span>)<br><span class="hljs-comment"># 将wave数据集分为训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="hljs-number">0</span>)<br>fig, axes = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">4</span>))<br><span class="hljs-comment"># 创建1000个数据点，在-3和3之间均匀分布</span><br>line = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1000</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> n_neighbors, ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>], axes):<br>    <span class="hljs-comment"># 利用1个、3个或9个邻居分别进行预测</span><br>    reg = KNeighborsRegressor(n_neighbors=n_neighbors)<br>    reg.fit(X_train, y_train)<br>    ax.plot(line, reg.predict(line))<br>    ax.plot(X_train, y_train, <span class="hljs-string">&#x27;^&#x27;</span>, c=mglearn.cm2(<span class="hljs-number">0</span>), markersize=<span class="hljs-number">8</span>)<br>    ax.plot(X_test, y_test, <span class="hljs-string">&#x27;v&#x27;</span>, c=mglearn.cm2(<span class="hljs-number">1</span>), markersize=<span class="hljs-number">8</span>)<br>    ax.set_title(<span class="hljs-string">&quot;&#123;&#125; neighbor(s)\n train score: &#123;:.2f&#125; test score: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(n_neighbors, reg.score(X_train, y_train),<br>    reg.score(X_test, y_test)))<br>    ax.set_xlabel(<span class="hljs-string">&quot;Feature&quot;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Target&quot;</span>)<br>axes[<span class="hljs-number">0</span>].legend([<span class="hljs-string">&quot;Model predictions&quot;</span>, <span class="hljs-string">&quot;Training data/target&quot;</span>,<span class="hljs-string">&quot;Test data/target&quot;</span>], loc=<span class="hljs-string">&quot;best&quot;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806204111.png"></p><p>图解：单一邻居时，训练集的每个点都对预测结果有显著影响，预测结果的图像经过所有数据点，这样并不稳定；邻居多的时候，预测结果更为平滑，但对训练数据的拟合不好</p><p>总结：kNeighbors分类似的重要参数：邻居个数、数据点之间的距离度量方法。度量方法一般使用 欧式距离 ，即直线距离</p><ul><li>优点：构建模型简单，容易理解，调整参数不多，性能也够</li><li>缺点：当数据量（特征多或样本数大）较大时，预测速度较慢。需要对数据进行预处理，对特殊的数据集效果不太好</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DPKI的崛起之路——分布式数字身份(DID)</title>
    <link href="/2022/08/06/DPKI%E7%9A%84%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD-DID/"/>
    <url>/2022/08/06/DPKI%E7%9A%84%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD-DID/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>互联网的出现和普及使得传统身份有了另一种表现形式，即数字身份，除自然人以外，机构组织、智能设备、虚拟网络都可以作为实体并拥有数字身份，这些实体作为数字化社会的重要组成部分，共同构建了数字生态，数字社会身份体系如下图所示。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203631.png"></p><p> 我们一般认为，数字身份的演进可分为三个阶段，第一阶段是由单一权威机构进行管理和控制的中心化身份，不同机构之间身份数据互不相通；第二阶段是由多机构或者联盟进行管理和控制的联盟身份，在该体系下，用户的身份数据具备了一定的可移植性，第三阶段以用户为中心，身份信息由用户自主掌控授权，身份管理走向去中心化。可以预见，在未来的数字化社会中，分布式数字身份体系带来的全新观念必将催生新的商业模式[1]，本篇文章将聚焦分布式数字身份(DID)，探索其广阔应用场景。</p><h1 id="二、PKI-amp-amp-DPKI"><a href="#二、PKI-amp-amp-DPKI" class="headerlink" title="二、PKI&amp;&amp;DPKI"></a><strong>二、PKI&amp;&amp;DPKI</strong></h1><p>“身份”本身是基础并客观存在的，今天的互联网广泛通过“租借”第三方机构（ICANN、DNS注册机构、证书颁发机构）服务来构建信任体系，实现实体间的安全通信，若要实现去中心化生态体系，又该如何求解，这里我们就来聊一聊PKI与DPKI体系之间的关系。</p><h2 id="1-PKI"><a href="#1-PKI" class="headerlink" title="1. PKI"></a><strong>1. PKI</strong></h2><p>PKI是Public Key Infrastructure的缩写，翻译过来也就是公钥基础设施，是生成、存储、分发和撤销用户数字身份证书所必须的软件、硬件、人、策略及处理过程的集合，也是国际公认普遍适用的一整套信息安全系统。PKI的建立依赖于权威的认证，离不开可信第三方（ICANN、DNS注册机构、证书颁发机构）的协同工作，通过运用多种技术，可为应用提供认证、加密和数字签名等安全支撑，为信息系统提供密钥管理和证书管理等安全服务，其主要载体为X.509格式的证书文件，PKI技术架构如下图所示。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203656.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="2-DPKI"><a href="#2-DPKI" class="headerlink" title="2. DPKI"></a>2. <strong>DPKI</strong></h2><p> 分布式公钥基础设施(DPKI)作为PKI的演进，并非是对PKI的全盘抛弃和替代，更多是在原有认证体系基础之上的一种改进和补充，通过构建一种分布式的认证体系来解决中心化认证体系存在的问题，是未来网络信任生态的基础设施。DPKI与PKI在业务流程上并无明显区别，首先用户提供相关信息并发起申请，接下来发证方审核信息，颁发证书，最后用户出示证书完成验证。但不同于PKI体系，DPKI强调用户身份的自主可控、身份可移植和分布式认证，个人身份的验证不再依赖于发证方，DPKI认证体系的具体特性如下图所示。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203708.png"></p><h1 id="三、分布式数字身份-DID"><a href="#三、分布式数字身份-DID" class="headerlink" title="三、分布式数字身份(DID)"></a><strong>三、分布式数字身份(DID)</strong></h1><p>伴随着区块链等可信技术的发展，各大公司、机构纷纷入局，对DPKI的实现展开了更深入的研究探索，分布式数字身份(DID)解决方案应运而生。通过结合区块链技术，分布式数字身份使用户真正拥有并控制自己的个人数据和资产，可实现跨部门、跨行业、跨地域的去中心化共享能力。</p><h2 id="1-W3C-DID"><a href="#1-W3C-DID" class="headerlink" title="1. W3C DID"></a><strong>1. W3C DID</strong></h2><p>万维网联盟(W3C)作为Web技术领域最具权威和影响力的标准化组织，已制定了200多项影响深远的Web技术标准及实施指南，其下属DID工作组已于2019年底发布了首个DID标准规范[2]，该标准主要包括分布式身份标识和可验证声明(身份凭证)两大基础模块，定义了身份标识符格式，描述文档以及身份凭证的生成、出示、验证和销毁等流程，覆盖了身份和凭证管理的完整生命周期，使DID技术向着规范化、标准化的目标迈出了一大步，W3C DID标准结构如下图所示。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203718.png"></p><h2 id="2-基础层：DID规范"><a href="#2-基础层：DID规范" class="headerlink" title="**2. 基础层：DID规范 **"></a>**2. 基础层：DID规范 **</h2><p>DID基础层主要定义规范了身份标识符及相应描述文档，该规范可用来标识人、组织、物品、抽象实体等任意主体。其中，DID标识符是一个特定格式的字符串且全局唯一，用来代表一个实体的数字身份，类似于我们的身份证号码一样，而每个DID标识都会对应一个DID文档(Document)，文档为JSON字符串格式，主要包含了与DID验证相关的密钥信息和验证方法，用以实现对实体身份标识的控制，DID文档内容格式如下图所示。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203730.png"></p><p>并且，一个实体可对应多个DID，实体在通过注册申请后可获得一个或多个由自己进行维护管理的DID标识，不同DID标识所代表的身份之间互不相关，有效降低了身份信息之间的耦合性。总的来说，我们可以将DID基础层看作是一个键值数据库，DID标识符当作键，而DID文档则是对应的值，二者之间的关系结构如下图所示。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203743.png"></p><h2 id="3-应用层：可验证证明"><a href="#3-应用层：可验证证明" class="headerlink" title="**3. 应用层：可验证证明 **"></a>**3. 应用层：可验证证明 **</h2><p>通过上一小节对DID规范的介绍可以看出，DID文档中不包含任何与个人真实信息相关的内容，如姓名、手机号、地址等。因此，仅仅依靠DID标识是无法完成身份验证的，DID应用层可验证声明[3]的助力不可或缺。</p><p>可验证声明(VC)用于在网络上（区块链）流转可验证信息，是建立DID整个体系的价值所在。对于DID应用层，我们可将参与实体划分为发行人(Issuer)、持有人(Holder)、验证人(Verifier)、DID注册系统（区块链）、凭证存储平台。其中，发行人拥有用户数据并且能出具相应VC，如政府部门、公安机关、教育机构等；持有人则是VC的持有者，任何人都可以充当该实体角色；验证人负责接受VC并进行核验，由此为VC持有人提供相应类型的服务；DID注册系统及凭证存储平台分别负责链上链下数据信息的验证维护，可验证声明应用服务如下图所示。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203801.png"></p><h1 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a><strong>四、应用场景</strong></h1><h2 id="1-身份认证"><a href="#1-身份认证" class="headerlink" title="**1.身份认证 **"></a>**1.身份认证 **</h2><p>身份认证可以说是DID最基本的应用了，对于有身份识别(KYC)需求的场景，通过提前将多个机构颁发的VC与用户绑定，且锚定到区块链上，凭借密码算法，可进行分布式验证，用户只需获取一次VC，便可随时出示使用。例如员工入职背景调查，材料在流转过程中极易遭受篡改，且验证手段较为匮乏，若使用DID解决方案，学生可以在链上使用自己的DID标识向学校申请学历（学位）凭证，向前公司申请工作（离职）凭证，而在求职时，现公司只需通过验证接口对上述凭证真实性进行核验，即可快速完成员工的入职背调。</p><h2 id="2-无密码安全登录"><a href="#2-无密码安全登录" class="headerlink" title="2. 无密码安全登录"></a><strong>2. 无密码安全登录</strong></h2><p>无口令安全登录的应用场景类似于微信扫码登陆，当我们需要注册或登录网站时，无需输入用户名、电子邮箱、密码之类的口令，只需使用手机中存储的用户DID信息完成与网站DID的双向验证。虽然登陆形式看起来没有发生任何变化，但与传统扫码认证方式不同的是，DID中的身份信息由用户自己掌控，用户首先通过二维码获得网站DID并进行验证获得公钥，再使用公钥加密请求数据，发送自己的身份信息交由服务器验证，若验证通过，则登陆成功。通过整个流程我们可以看出，服务器并不知道用户的口令，而且也无法获得除用户DID文档以外的任何信息，从而有效防止数据泄露，保护用户身份隐私。</p><h2 id="3-个人隐私保护"><a href="#3-个人隐私保护" class="headerlink" title="**3. 个人隐私保护 **"></a>**3. 个人隐私保护 **</h2><p>隐私保护是任何身份管理解决方案中不可或缺的一部分，DID也不例外，通过对用户属性的选择性披露可以有效降低用户隐私泄露的风险。在实际生活中，用户身份通常具有多个属性，如身份证上的姓名、出生年月、家庭住址、身份证号等，我们并不总是希望直接将整个证件亮给验证者查看，过多关联信息的泄露会带来一系列麻烦，不法份子就曾利用通行大数据（健康宝）窃取明星隐私并进行传播售卖[4]。DID凭证结合零知识证明技术，可以做到信息最小化提供的同时不影响凭证的合法性验证，有效保护用户隐私。例如，一个有社会责任心的商店老板拒绝向未成年人出售香烟，对于买烟的顾客需要查验其年龄信息，此时若使用身份证则会泄露关联敏感信息，但在DID技术中，可以只出示部分信息，证明自己已超过一定年龄（18岁）而无需透露其他信息，包括出生年月，从而实现对个人隐私信息的选择性披露。</p><h2 id="4-数字版权保护"><a href="#4-数字版权保护" class="headerlink" title="**4. 数字版权保护 **"></a>**4. 数字版权保护 **</h2><p>线上数字内容往往会面临一系列的版权纠纷，利用区块链不可篡改及数字身份自主可控的特性，可有效解决数字内容版权保护问题，实现多方信息的实时共享、版权认证、交易维权，促使数字资产合法合规流动。链上参与者通过使用DID技术，使得作品具备唯一标识，著作权经过认证后，成为不可篡改的链上凭证，可以作为举证、流转的声明，应用于资产确权、数据定价、流转监测分析以及侵权取证等场景。</p><h2 id="5-物联网及边缘计算"><a href="#5-物联网及边缘计算" class="headerlink" title="**5. 物联网及边缘计算 **"></a>**5. 物联网及边缘计算 **</h2><p>物联网设备通常分布在不同的地域，采用多种方式接入网络，这也使得其编码标准存在多样性，具有较高管理成本和安全风险。若使用DID技术为物联网设备分配全局唯一标识，并结合厂家生产信息、物联网运营商以及设备的所有权信息，为设备颁发多种凭证，赋予设备可声明、可验证的自主身份，即可在区块链上实现设备身份和数据的高效分布式认证，有效保障数据来源的真实性，同时也有利于对设备产生的数据进行确权、计价。</p><h1 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a><strong>五、小结</strong></h1><p>在本篇文章中，我们详细介绍了分布式数字身份(DID)技术的发展与应用，可以预见，随着时间的推移及行业的共同努力，技术体系愈发完善，相关运作模式趋于规范合理，在未来将会有更多的权威机构、产业机构以及个人、物联网设备通过分布式数字身份体系的助力，参与到广阔的数字经济世界来，开拓更多的创新应用场景。</p><p>未来的数字化社会必定以用户为核心，实体可通过自主管理数据与可信共享交换来创造价值，分布式数字身份将会帮助数字化社会更健康、更透明、更高效地发展。</p><p><strong>参考文献</strong></p><p>1.张开翔, 数字时代的身份基础设施建设, 微众银行, 2020.06.29</p><p>2.<a href="https://www.w3.org/TR/did-core/">https://www.w3.org/TR/did-core/</a></p><p>3.<a href="https://www.w3.org/TR/vc-data-model/">https://www.w3.org/TR/vc-data-model/</a></p><p>4.<a href="https://baijiahao.baidu.com/s?id=1687424669586301192&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1687424669586301192&amp;wfr=spider&amp;for=pc</a></p><p>5.<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/</a></p><p>6.<a href="https://weidentity.readthedocs.io/zh_CN/latest/">https://weidentity.readthedocs.io/zh_CN/latest/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习实践（一）：鸢尾花分类</title>
    <link href="/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%88%86%E7%B1%BB/"/>
    <url>/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><h4 id="机器学习的历史"><a href="#机器学习的历史" class="headerlink" title="机器学习的历史"></a>机器学习的历史</h4><p>人为指定决策规则。人为指定决策规则适合处理人们非常熟悉处理过程的应用，一旦数据量过大、数据处理过程复杂或者任务有所变化，就需要机器学习上场了。<br>早在19世纪的50到80年代，科学家们就有着让计算机算法代替人脑思考的想法，最初，机器学习只用于垃圾邮件清理，数学公式分析等简单领域，然而后来其应用场景越来越多，无论是图片过滤，语音分析，数据清洗等领域都能看到机器学习的身影。到如今无论是智能手机，航空运输，智能驾驶等方方面面都可以看到 AI 的身影</p><p>机器学习主要应用数据科学领域，它与普通程序开发的主要区别在于一般程序，数据往往来源于不同的数据库，通过对数据进行复杂转化，运算得到最后的结果。而机器学习目的并不是为了得到最后的运算结果，而是对计算过程进行分析，总结出一套运算的规则。只要数据量足够多，运算规则就越准确。最后可以根据这套规则对没有通过验证的数据进行预算，得到预算后的值。只要使用的规则正确，预算的结果的正确率往往可以达到95%以上。</p><p>深度学习开始只是机器学习的一分支领域，它更强调从连续的层中进行学习，这种层级结构中的每一层代表不同程序的抽象，层级越高，抽象程度越大。这些层主要通过神经网络的模型学习得到的，最大的模型会有上百层之多。而最简单的神经网络分为输入层，中间层（中间层往往会包含多个隐藏层），输出层。<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203500.png"></p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><h5 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h5><p>用户将输入和预期输出提供给算法，算法根据给定输入给出预期输出。这里的”监督”就是样例的预期输出，这个输出“监督”着算法。监督学习算法需要提供大量数据</p><ul><li>识别信封上手写的邮政编码</li><li>基于医学影像判断肿瘤是否为良性</li><li>检测信用卡交易中的诈骗行为<br>常见的监督学习包含了线性回归、k近邻、朴素贝叶斯分类 、决策树、随机森林与梯度提升决策树、支持向量机等多种算法，</li></ul><h5 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h5><p>只有输入数据已知，没预期的输出数据。理解和评估此类算法比较困难，例如</p><ul><li>分析一些列博客文章的主题</li><li>将客户分类为具有相似偏好的群组</li><li>检测网站的异常访问模式</li></ul><p>常见的无监督学习分为聚类、降维两大类，包含了PCA（主成分分析）、NMF（非负矩阵分解）、t-SNE（流形学习）、k均值聚类、DBSCAN 等多种算法</p><p>机器学习中的每个实体或每一行称为样本or数据点，每一列或者描述实体的属性成为特征。</p><p>构建机器学习解决方案需要注意的点：</p><ul><li>我的问题是什么？已经收集到的数据能够回答这个问题了吗？</li><li>我的问题如何表达成机器学习问题？</li><li>我收集的问题是否足够表达我想解决的问题？</li><li>提取了数据的哪些特征？这些特征是否能实现真正的预测？</li><li>如果预测应用是否成功？</li><li>这个解决方案与商业产品中的其他部分是如何影响的？</li></ul><hr><h3 id="各项工具"><a href="#各项工具" class="headerlink" title="各项工具"></a>各项工具</h3><p>（版本均未指定，默认最新）</p><p>scikit-learn：机器学习库，包含各种算法</p><p>NumPy：科学计算的基础包，包括各种数组，数学函数等，在机器学习中主要用到的是，将NumPy数组格式的数据传给算法</p><p>SciPy：科学计算的函数集合，包含线性代数高级程序、特殊函数函数和统计分布等。在这里主要用到scipy.sparse输出稀疏矩阵（大部分元素为0，非0元素分布无规律）</p><p>Matplotlib：科学绘图库，可生成数据的可视化内容</p><p>Pandas：处理和分析数据的库，基于DataFrame的数据结构，类似一个Excel表格，pandas中包含各种操作这个数据结构的API，还可以提取各种文件格式和数据库中的数据</p><p>mglearn：《Python机器学习基础教程》书本自带库，用于美化绘图</p><hr><h3 id="鸢尾花分类"><a href="#鸢尾花分类" class="headerlink" title="鸢尾花分类"></a>鸢尾花分类</h3><p>数据来源：<strong>内置在sklearn的datasets中</strong>，由load_iris()函数获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br>datas=load_iris()<br></code></pre></td></tr></table></figure><p>数据内容（主要）</p><p>data：样本数据，格式为Numpy数组。例如：[5.1 3.5 1.4 0.2]，每行数据代表一朵花的测量数据</p><p>target：测量过的每朵花的品种，同样是一维Numpy数组。对应data中的每一行数据所测得的结果</p><p>target_names：想要预测的花的品种，target中的结果对应着这里的names。是一个字符串数组</p><p>feature_names：对每个特征进行说明，对应data中的各个属性。字符串数组</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203517.png"></p><p>DESCR：数据集的简要说明，类似备注</p><p><strong>规划数据：测试集</strong></p><p>注意：不能用训练的数据来测试模型，因为模型会记住训练时用的数据集，所以会100%“预测”结果，这无法评估模型的泛化（预测）能力，应该使用测试数据集，确保这些数据集模型之前从未见过。一般的做法是将原有的数据集拿出25%作为测试用</p><p>train_test_split函数会将数据集打乱后，按照比例分割给X_train, X_test, y_train, y_test四个子集，X_train包含75%，X_test为25%，调用子集的shape()函数可看到数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">X_train, X_test, y_train, y_test = train_test_split(datas[<span class="hljs-string">&#x27;data&#x27;</span>], datas[<span class="hljs-string">&#x27;target&#x27;</span>], random_state=0)<br></code></pre></td></tr></table></figure><p><strong>检查数据：可视化</strong></p><p>Ps:反正没怎么能看懂这些生成的图~在预测测试数据时应该是非必要的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">将需要可视化的数据转成DataFrame<br>iris_dataframe=pd.DataFrame(X_train, columns=datas.feature_names)<br><br>grr = pd.scatter_matrix(iris_dataframe, c=y_train, figsize=(15, 15), marker=<span class="hljs-string">&#x27;o&#x27;</span>,hist_kwds=&#123;<span class="hljs-string">&#x27;bins&#x27;</span>: 20&#125;, s=60, alpha=.8, cmap=mglearn.cm3)<br><span class="hljs-comment">#执行绘制</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>训练数据：基于训练构建模型</strong></p><p>k近邻算法：在训练集中寻找与新数据点距离最近的数据点，将找到的数据点的标签赋值给新数据点，达到预测效果，k的含义指训练集与新数据点中最近的任意k个邻居，利用邻居中数量最多的类别做预测</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#创建KNeighborsClassifier的实例，算法就封装在实例中，这里只需设置邻居为1即可</span><br>knn=KNeighborsClassifier(n_neighbors=1)<br><span class="hljs-comment">#构建基于训练的模型，fit函数返回的信息无需关注，它只修改了knn对象</span><br>knn.fit(X_train, y_train)<br></code></pre></td></tr></table></figure><p><strong>预测数据</strong></p><p>将新的数据传入模型，模型会预测出结果</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">#将样本数据封装成numpy数组<br>X_new = np.array(<span class="hljs-string">[[5,2.9,1,0.2]]</span>)<br><br>#封装好的数组传给knn的predict函数进行预测<br>prediction=knn.predict(X_new)<br><br>#查看预测结果和结果在target中对应的品种<br><span class="hljs-built_in">print</span>(prediction)<br><span class="hljs-built_in">print</span>(datas[<span class="hljs-string">&#x27;target_names&#x27;</span>][prediction])<br></code></pre></td></tr></table></figure><p><strong>评估模型</strong></p><p>预测测试数据集，并和已知的品种进行对比，就可以计算出精度，从而衡量模型的优劣</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#需要用到之前的测试集</span><br>y_pred=knn.predict(X_test)<br><br><span class="hljs-comment">#计算精度1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;预测比例：&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.mean(y_pred == y_test)))<br><br><span class="hljs-comment">#计算精度2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;预测比例：&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(knn.score(X_test, y_test)))<br></code></pre></td></tr></table></figure><p>问题：数据分测试集这部分没有看懂</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu18.04使用离线源码包安装Mysql</title>
    <link href="/2022/08/06/Ubuntu18-04%E4%BD%BF%E7%94%A8%E7%A6%BB%E7%BA%BF%E6%BA%90%E7%A0%81%E5%8C%85%E5%AE%89%E8%A3%85Mysql/"/>
    <url>/2022/08/06/Ubuntu18-04%E4%BD%BF%E7%94%A8%E7%A6%BB%E7%BA%BF%E6%BA%90%E7%A0%81%E5%8C%85%E5%AE%89%E8%A3%85Mysql/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>源码包下载：</p><p><a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>选择SourceCode翻到下面的tar.gz包下载即可</p><p>放一张网图，Mysql源码安装的最佳路径：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203300.png"></p><p>先把源码包放在/usr/local下，解压出来再改个名</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf mysql-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">45</span>-linux-glibc2.<span class="hljs-number">12</span>-x86_64.tar.gz<br><span class="hljs-attribute">mv</span> mysql-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">22</span>-linux-glibc2.<span class="hljs-number">12</span>-x86_64 mysql<br></code></pre></td></tr></table></figure><p>新建mysql用户组、mysql用户</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo groupadd mysql</span><br><span class="hljs-attribute">sudo useradd mysql -g mysql</span><br></code></pre></td></tr></table></figure><p>授权。以下文件夹没有就创建一个</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo chown -R mysql:mysql <span class="hljs-regexp">/usr/</span>local/mysql<br>sudo chown -R mysql:mysql <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>data<br>sudo chown -R mysql:mysql <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mysql/</span><br>sudo chown -R mysql:mysql <span class="hljs-regexp">/var/</span>run/mysqld<br></code></pre></td></tr></table></figure><p>配置数据库相关的路径信息，初始化数据库。</p><p>初始化时会打印一堆东西。有的人初始化时会打印出默认密码，但是这次我却没看到……不太清楚是什么原因</p><p>另外初始化必须用sudo去执行，否则会报权限不够或者奇怪的错误</p><p>注：这一步使用mysql_install_db安装，需要用到libaio1， libaio是Linux下的一个异步非阻塞方式读写文件的接口，缺少是无法继续安装的</p><p>libaio下载地址</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://debian.pkgs.org/<span class="hljs-number">11</span>/debian-main-amd64/libaio1_0.<span class="hljs-number">3</span>.<span class="hljs-number">112</span>-<span class="hljs-number">9</span>_amd64.deb.html<br></code></pre></td></tr></table></figure><p>安装libaio</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> dpkg -i libaio1_0.<span class="hljs-number">3</span>.<span class="hljs-number">112</span>-<span class="hljs-number">9</span>_amd64.deb<br></code></pre></td></tr></table></figure><p>查看一下安装是否完成</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">whereis libaio.so.<span class="hljs-number">1</span><br><br>libaio.so: <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libaio.so.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>然后就可以继续初始化数据库了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>scripts<span class="hljs-regexp">/mysql_install_db --user=mysql --basedir=/u</span>sr<span class="hljs-regexp">/local/my</span>sql<span class="hljs-regexp">/ --datadir=/u</span>sr<span class="hljs-regexp">/local/my</span>sql/data<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203319.png"></p><p>然后去配置my.cnf。默认是没有的，需要从源码包里复制一份默认的配置文件到/etc下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span> &amp;&amp; cp support-files<span class="hljs-regexp">/my-default.cnf /</span>etc/my.cnf<br></code></pre></td></tr></table></figure><p>默认的my.cnf下文件一堆注释，最后接了两句 ！开头的语句，不太清楚是做什么用的，我尝试过几个版本的cnf文件，最后用了以下文件即可。</p><p>注意这里的关闭dns解析，内网环境下可以用这个。具体分析请左拐：<a href="https://www.cnblogs.com/liruning/p/7111015.html">原因</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[mysqld]<br><span class="hljs-type">character</span>-<span class="hljs-keyword">set</span>-<span class="hljs-keyword">server</span> = utf8mb4<br>#关闭dns解析（注意：这会造成只能使用ip远程连接MySQL）<br><span class="hljs-meta">#skip-name-resolve</span><br>skip-<span class="hljs-keyword">grant</span>-<span class="hljs-keyword">tables</span><br><br>[client]<br><span class="hljs-keyword">default</span>-<span class="hljs-type">character</span>-<span class="hljs-keyword">set</span> = utf8mb4<br><br>[mysql]<br><span class="hljs-keyword">default</span>-<span class="hljs-type">character</span>-<span class="hljs-keyword">set</span> = utf8mb4<br></code></pre></td></tr></table></figure><p>OK，然后就可以启动了，先把Mysql加入服务中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>support-files<span class="hljs-regexp">/mysql.server /</span>etc<span class="hljs-regexp">/init.d/my</span>sql<br></code></pre></td></tr></table></figure><p>然后启动Mysql：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo service mysql <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>support-files/mysql.server start<br></code></pre></td></tr></table></figure><p>设置密码。这里可能会出现一些警告，这是因为直接明文设置了密码，不用担心实际上已经是设置好了的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>bin/mysqladmin -u root -h localhost.localdomain password <span class="hljs-string">&#x27;new-password&#x27;</span><br></code></pre></td></tr></table></figure><p>直接进入mysql，输入密码即可进入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -uroot -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>问题s：</p><p>初始化数据库时需要使用到libaio1这个包，但是原生的Ubuntu并不会有这个包，如果需要离线安装还需要rpm工具，但rpm也是需要安装的……因此此次安装并不算真实离线</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu修改权限后导致sudo和su无法使用</title>
    <link href="/2022/08/06/Ubuntu%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E5%90%8E%E5%AF%BC%E8%87%B4sudo%E5%92%8Csu%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/06/Ubuntu%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E5%90%8E%E5%AF%BC%E8%87%B4sudo%E5%92%8Csu%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由于ubuntu默认开机后随机密码，所以一般装好系统后第一件事就是sudo passwd root，这次没有修改给忘记了，好死不死又把权限整出来有问题，一用sudo就提示如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">sudo:</span> /etc/sudoers <span class="hljs-built_in">is</span> owned <span class="hljs-keyword">by</span> uid <span class="hljs-number">1000</span>, should be <span class="hljs-number">0</span><br><span class="hljs-symbol">sudo:</span> no valid sudoers sources found, quitting<br><span class="hljs-symbol">sudo:</span> unable <span class="hljs-keyword">to</span> initialize policy plugin<br></code></pre></td></tr></table></figure><p>这种也很好解决，正常情况直接修改sudoer文件的权限即可，但我又不是root用户，切换不过去。我直接麻了。犯了很久终于翻到一个9年前的帖子，情况和我一摸一样，原帖在这儿，有兴趣可以看一下：</p><p><a href="https://blog.csdn.net/weixin_33991418/article/details/93206334">https://blog.csdn.net/weixin_33991418/article/details/93206334</a></p><p>如果不用这种方式，还可以用ubuntu光盘引导系统，mount对应的磁盘修改/etc/sudoers文件。或者直接重装一遍，也不需要太久……</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>重启ubuntu，启动时按esc或shift，进入引导项</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203018.png"></p><p>选择第二个，再选择第二个 recrovery mode，开机程序走完之后，进入Recovery Menu页面 ，选择root，回车</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203031.png"></p><p>回车后下面提示再按回车，再按一下，就能看到熟悉的 root@user ~#了</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203041.png"></p><p>到这儿了就可以开始干正事儿了，把提示之前的问题给解决掉：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pkexec chown root:root <span class="hljs-regexp">/etc/</span>sudoers <span class="hljs-regexp">/etc/</span>sudoers.d -R<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203125.png"></p><p>回车，然后重启Ubuntu即可正常修改root密码了</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806203149.png"></p><p> 如果还有朋友上面这行代码解决不了，可以尝试如下方法，将sudoers.d文件夹的权限设置成root用户和root组，root组只有执行的权限，只有root用户有写入的权限：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">chown -R root:root <span class="hljs-regexp">/etc/</span>sudoers.d<br>chmod u=rwx,g=rx,o=rx <span class="hljs-regexp">/etc/</span>sudoers.d/<br>chmod u=r,g=r,o= <span class="hljs-regexp">/etc/</span>sudoers.d/*<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python import的本质</title>
    <link href="/2022/08/06/Python-import%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <url>/2022/08/06/Python-import%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<p>ModuleNotFoundError: No module named 是经常能碰到的事情.这篇文章详细解释了Python导入模块的细节…………</p><span id="more"></span><p>谈到模块，不得不提起Pytho程序本身的架构。一般来说，一个Python程序包括多个含有Python语句的文本文件，程序就是作为一个主体、顶层的文件来构造，配合0~多个支持的文件，而这些文件就是模块。模块文件在运行时无需做任何事，当一个文件导入一个模块从而获得该模块定义的工具的访问权，那么该工具就是这个模块的属性</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">顶层文件：程序的主要控制流程<br><br>模块文件：工具库，提供给顶层文件使用的组件<br></code></pre></td></tr></table></figure><p><strong>导入的实质</strong></p><p>当程序执行时，且是第一次导入时，会执行以下步骤：</p><p>1.找到该模块文件</p><p>2.将其编译成位码（需要时）</p><p>3.执行模块的代码并创建其所定义的对象</p><p>这三部走完，Python会将载入的模块存储到sys.modules表中，并在导入后检查该表，若模块不存在就会重新执行以上三步</p><p>回到现实，在日常工作中，经常能碰到导包失败的情况，程序是死的，它只能通过人设置好的路径是查找给定的包。这就涉及到Python包的搜索路径sys.path。</p><p><strong>搜索路径</strong></p><ol><li><p>程序的主目录：即顶层文件所在目录</p></li><li><p>PYTHONPATH目录：跨目录使用</p></li><li><p>标准链接库目录：安装在机器上本身的目录，一定会被搜索到</p></li><li><p>任意.pth文件的内容：同跨目录使用，配置环境变量的一种替代方案，可将其放在顶层文件目录或标准链接库目录下</p></li></ol><p><strong>导入的方式</strong></p><ol><li>import 直接导入</li></ol><p>一般用于导入内置模块或第三方库</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> sys <br><span class="hljs-keyword">import</span> Person <span class="hljs-keyword">as</span> ps  #别名<br></code></pre></td></tr></table></figure><p>导入后使用时，需要加上模块名的限定，如：person=Person.Person(‘xiaozhou’)</p><ol start="2"><li>from package import funcname</li></ol><p>from 包名.模块名 import 类名/方法名，从指定模块中导入具体方法，<strong>推荐用法</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> <span class="hljs-keyword">version</span><br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> <span class="hljs-keyword">version</span>,executable<br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure><p>导入后使用时，可直接对import的类/方法名进行操作，如：person=Person(‘ xiaozhou ‘)</p><ol start="3"><li>mymodule=<strong>import</strong>(‘ modulename ‘)，不推荐该写法，可读性很差</li></ol><p>另外，跨目录还有一种导入方法，即：在顶层文件中手动添加sys.path，注意要先添加路径，后执行导入操作</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sys<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.append</span>(<span class="hljs-string">&#x27;E:\\insertdir&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VMware Workstation Pro v16.2.3 官方版+激活密钥</title>
    <link href="/2022/08/06/VMware-Workstation-Pro-v16-2-3-%E5%AE%98%E6%96%B9%E7%89%88-%E6%BF%80%E6%B4%BB%E5%AF%86%E9%92%A5/"/>
    <url>/2022/08/06/VMware-Workstation-Pro-v16-2-3-%E5%AE%98%E6%96%B9%E7%89%88-%E6%BF%80%E6%B4%BB%E5%AF%86%E9%92%A5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>VMware Workstation Pro 是将多个操作系统作为虚拟机 (VM) 在单台 Linux 或 Windows PC 上运行的行业标准。为任何设备、平台或云环境构建、测试或演示软件的 IT 专业人员、开发人员和企业都可以信赖 Workstation Pro。</p><p><strong>系统要求：</strong></p><p>支持使用2011年或以后推出的使用处理器（CPU）的系统， 但 以下情况除外：</p><p>基于2011 Bonnell微体系结构的Intel Atom处理器。例如，Atom Z670 / Z650和Atom N570。<br>使用基于2012 Saltwell微体系结构的Intel Atom处理器的系统。例如，Atom S1200，Atom D2700 / D2500和Atom N2800 / N2600。<br>使用基于Llano和Bobcat微体系结构的AMD处理器的系统。例如，代号为Hondo，Ontario，Zacate和Llano。<br>以下系统 都 还支持：使用基于2010的Westmere微架构系统的英特尔处理器。例如，至强5600，至强3600，Core i7-970，Core i7-980和Core i7-990。</p><p>官网下载：</p><p><a href="https://www.vmware.com/go/getworkstation-win">https://www.vmware.com/go/getworkstation-win</a></p><ul><li>已高速(如有密码：3519)<a href="http://ct.ghpym.com/d/7369060-41496370-0d53b8">http://ct.ghpym.com/d/7369060-41496370-0d53b8</a></li><li><a href="https://pan.quark.cn/s/1679072c6d07">https://pan.quark.cn/s/1679072c6d07</a></li><li>已高速<a href="http://www.123pan.com/s/HQeA-aX1Sh">http://www.123pan.com/s/HQeA-aX1Sh</a></li><li>链接：<a href="https://pan.baidu.com/s/1sa7Fq9AW2Nsx4tsM5CrFXA">https://pan.baidu.com/s/1sa7Fq9AW2Nsx4tsM5CrFXA</a>   提取码：fpii</li></ul><p>原文链接：<a href="https://www.ghxi.com/vmware15.html">https://www.ghxi.com/vmware15.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Shell编程基础教程全集-网页版</title>
    <link href="/2022/08/06/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%85%A8%E9%9B%86-%E7%BD%91%E9%A1%B5%E7%89%88/"/>
    <url>/2022/08/06/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%85%A8%E9%9B%86-%E7%BD%91%E9%A1%B5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>上：<a href="https://www.cnblogs.com/clsn/p/7992981.html">https://www.cnblogs.com/clsn/p/7992981.html</a></p><p>中：<a href="https://www.cnblogs.com/clsn/p/8006210.html">https://www.cnblogs.com/clsn/p/8006210.html</a></p><p>下：<a href="https://www.cnblogs.com/clsn/p/8028337.html">https://www.cnblogs.com/clsn/p/8028337.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>原地TP——SSH连接本机windows子系统的Ubantu</title>
    <link href="/2022/08/06/%E5%8E%9F%E5%9C%B0TP%E2%80%94%E2%80%94SSH%E8%BF%9E%E6%8E%A5%E6%9C%AC%E6%9C%BAwindows%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84Ubantu/"/>
    <url>/2022/08/06/%E5%8E%9F%E5%9C%B0TP%E2%80%94%E2%80%94SSH%E8%BF%9E%E6%8E%A5%E6%9C%AC%E6%9C%BAwindows%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84Ubantu/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>首先需要开启一个子系统，先在控制面板-程序-启用或关闭windows功能，勾选适用于Linux的Windows子系统</p><p> <img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806202319.png"></p><p>然后在Windows自带的微软商店中搜索Ubantu下载，就那个400多MB的，下载好后需要重启电脑，重启后打开dos，输入bash……这就不多说了，详细百度即可。这里重点说连接的事儿。因为在dos上用linux实在太伤眼了，也很麻烦。</p><p>首先把apt更新一下，不然后面会让你绝望（不要不信邪，亲测）</p><p>更新前先换个源，源文件：/etc/apt/sources.list ，可以先备份下原来的源，防止后面要用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list /</span>etc<span class="hljs-regexp">/apt/</span>sources.list.bak<br></code></pre></td></tr></table></figure><p>然后打开/etc/apt/sources.list，可以将其他源注释掉，并添加以下源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#添加阿里源</span><br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal-security main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal-security main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal-updates main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal-updates main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal-proposed main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal-proposed main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal-backports main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal-backports main restricted universe multiverse<br><span class="hljs-comment">#添加清华源</span><br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> focal main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> focal-updates main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> focal-backports main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> focal-security main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse multiverse</span><br></code></pre></td></tr></table></figure><p>先更新下源，如果出现依赖问题，可以<code>sudo apt-get -f install 解决</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>然后就可以更新软件了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> upgrade<br></code></pre></td></tr></table></figure><p>环境清理结束，开始干活。把默认的ssh删掉先，别问我为什么要删，咱也不知道，咱也不敢问（实际上应该是不需要删除的，别人测过）。询问Y/n时，选择Y，按回车</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> --purge openssh-server<br></code></pre></td></tr></table></figure><p>然后重新安装ssh</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install openssh-<span class="hljs-keyword">server</span> ssh <br></code></pre></td></tr></table></figure><p>启动ssh，这时候电脑会提示防火墙啥的，申请联网，点击允许即可</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo service ssh <span class="hljs-comment">--full-restart </span><br></code></pre></td></tr></table></figure><p>这样就OK了，现在可以使用ssh工具连接你的子系统了。但是！由于每次连接子系统时都是手动调用的 System/bash.exe，每次电脑开机重启后进程就会结束，所以需要为电脑设置一个开机自启的定时任务。</p><p>打开win键搜索任务计划程序，右上角点击创建基本任务</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806202348.png"></p><p> 名称就写ssh自启，下一步选择每次计算机启动时触发。操作选择启动程序。在程序或脚本里填写：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">windir</span></span>%\System32\bash.exe<br></code></pre></td></tr></table></figure><p>下方的参数一栏填写：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">-<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;echo 你的linux密码|sudo -S /etc/init.d/ssh restart&quot;</span><br></code></pre></td></tr></table></figure><p>然后点击完成。然后在计划库中找到刚才新增的任务，右键选择属性</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806202402.png"></p><p>这里一定要选择“不管用户是否登录都要运行”，这才是真正的开机自启。它默认是选择“只在用户登录时运行”，看起来没有什么区别，但每个人电脑环境不太一样，看别人只会开机时弹出黑色窗口，但我的电脑却压根不会自启。因此最好是选择到这个位置。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806202412.png"></p><p> 最后重启电脑，开机后直接打开ssh工具连接本机linux，就可以啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux下普通用户无法使用yum，提示需root用户</title>
    <link href="/2022/08/06/linux%E4%B8%8B%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8yum%EF%BC%8C%E6%8F%90%E7%A4%BA%E9%9C%80root%E7%94%A8%E6%88%B7/"/>
    <url>/2022/08/06/linux%E4%B8%8B%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8yum%EF%BC%8C%E6%8F%90%E7%A4%BA%E9%9C%80root%E7%94%A8%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>使用root 用户用 vi 或 vim 编辑/etc/sudoers文件，找到 “root ALL=(ALL) ALL”一栏，在下一行填写：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">user</span> <span class="hljs-title">ALL</span>=(root) NOPASSWORD:yum *<br></code></pre></td></tr></table></figure><p>然后按：wq!完成编辑。注意这里要用到 ! 强制保存，如果不用的话会提示这是一个readonly文件，不支持修改。</p><p>上面语句的作用是：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806202154.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记录一次云服务器被异地登录密码破解、不得已重装系统的经历</title>
    <link href="/2022/08/06/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E5%BC%82%E5%9C%B0%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E3%80%81%E4%B8%8D%E5%BE%97%E5%B7%B2%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <url>/2022/08/06/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E5%BC%82%E5%9C%B0%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E3%80%81%E4%B8%8D%E5%BE%97%E5%B7%B2%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>开局一张图，是我正在安装linux上的杀毒软件clamav 。从昨天开始就登录不删服务器了，而且自检提示什么外网宽带占用率90%+，当时还不知道什么问题，直到今天在图书馆用所有方式都无法登陆，这才发现有点不对，跟客服联系后得出结论是有木马入侵，多次被异地登录。简直大无语，不过也正好，把服务器整理一下，不然一直用root登陆有些不太好。</p><p>安装杀软……<a href="https://blog.csdn.net/weixin_41004350/article/details/80182929">https://blog.csdn.net/weixin_41004350/article/details/80182929</a></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806202035.png"></p><p>客服给的检查结果：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806202051.png"></p><p>上面的链接是这个：<a href="https://cloud.tencent.com/developer/article/1623140?from=10680%E3%80%82%E6%88%91%E5%8F%AA%E8%83%BD%E9%80%89%E6%8B%A9%E6%9C%80%E7%A8%B3%E5%A6%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A%E9%87%8D%E8%A3%85%E4%B8%80%E5%88%87%E3%80%82%E5%B9%B6%E4%B8%94%E9%87%87%E5%8F%96%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD%EF%BC%9A">https://cloud.tencent.com/developer/article/1623140?from=10680。我只能选择最稳妥的方法：重装一切。并且采取一些安全措施：</a></p><ul><li>关闭22端口、选择其他端口作为远程端口。步骤：<a href="https://blog.csdn.net/qq_43652793/article/details/84667933">https://blog.csdn.net/qq_43652793/article/details/84667933</a></li><li>root用户修改密码，使用密码随机生产器来设置密码，并创建子用户，所有工作在子用户下进行：<a href="https://suijimimashengcheng.bmcx.com/">https://suijimimashengcheng.bmcx.com/</a></li><li>其他的就不做了，做了的话可能影响正常使用啦，愿世界没有木马，阿弥陀佛！</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql开启远程访问</title>
    <link href="/2022/08/06/Mysql%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    <url>/2022/08/06/Mysql%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>防火墙、参数这些就不用说了，最基本的，填错了就当眼瞎了。最重要的是这个：<strong>增加允许远程连接 MySQL 用户并授权</strong></p><p>很多朋友（包括我）拿到一条命令，好家伙直接欢欢喜喜拿去运行，运行完了一看运行正常，没报错，ok继续验证，发现没用，心想：垃圾东西。各位，好好看看这里的参数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">database</span>.* <span class="hljs-keyword">to</span> <span class="hljs-keyword">user</span>@<span class="hljs-string">&#x27;123.123.123.123&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>; <br></code></pre></td></tr></table></figure><ul><li>database：这个是数据库名，要换成你当前用的数据库名字！</li><li>user：当前mysql的用户名</li><li>123.123.123.123：允许远程登录的IP，这里也可以填%，看自己需要</li><li>123456：这里是远程登录的密码，远程登录的时候需要用到</li><li>all PRIVILEGES（不用改，我只是解释下）表示赋予所有的权限给指定用户。这里也可以替换为赋予某一具体的权限，例如：select,insert,update,delete,create,drop 等，具体权限间用“,”半角逗号分隔。</li></ul><p>另外，执行完上述语句后记得刷新，刷新后生效</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">flush privileges<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL Workbench 连接数据库提示SSL connection error: SSL is required but the server doesn&#39;t support it</title>
    <link href="/2022/08/06/MySQL-Workbench-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E7%A4%BASSL-connection-error-SSL-is-required-but-the-server-doesn-t-support-it/"/>
    <url>/2022/08/06/MySQL-Workbench-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E7%A4%BASSL-connection-error-SSL-is-required-but-the-server-doesn-t-support-it/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>mysql下载器下载了mysql worbench后无法连接远端数据库，提示SSL之类的错误</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806201747.png"></p><p><strong>解决方案</strong>：不使用SSL，在Advance TAB页的others框中输入参数：useSSL=0，就可以连接上了。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806201800.png"></p><p>有时候本地连接可以，但远程连接不行，并且报错：Host is not allowed to connect to this MySQL server。那一般是没有允许远程登录来的，解决办法也很简单：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>先进入mysql<br>use mysql<br><span class="hljs-regexp">//</span>允许root用户从所有IP远程访问<br>update user set host = <span class="hljs-string">&#x27;%&#x27;</span> where user = <span class="hljs-string">&#x27;root&#x27;</span>;<br><span class="hljs-regexp">//</span>刷新<br>flush privileges;<br></code></pre></td></tr></table></figure><h3 id="附上忘记Mysql密码的修改方法（CentOS7）："><a href="#附上忘记Mysql密码的修改方法（CentOS7）：" class="headerlink" title="附上忘记Mysql密码的修改方法（CentOS7）："></a>附上忘记Mysql密码的修改方法（CentOS7）：</h3><ol><li>先关闭Mysql（前提是mysql存在，且安装正常）</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">service mysqld stop<br></code></pre></td></tr></table></figure><ol start="2"><li>修改mysql配置文件，在[mysqld] 下添加一句 skip-grant-tables 然后保存退出</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/my</span>.cnf<br></code></pre></td></tr></table></figure><ol start="3"><li>重启数据库</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service mysqld <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><ol start="4"><li>此时进入数据库是免密的，进入后 use mysql 选择数据库进入</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">mysql -u<span class="hljs-built_in"> root</span> mysql -u<span class="hljs-built_in"> root</span> <br><br>use mysql;<br></code></pre></td></tr></table></figure><ol start="5"><li>修改密码( newpwd为新密码 )</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> authentication_string=<span class="hljs-keyword">password</span>(<span class="hljs-string">&#x27;newpwd&#x27;</span>) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><p>修改完毕，exit后重新用新密码登录试一下，记得把好了之后记得把刚才的添加的语句注释掉，再重新启动mysql。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-35.搜索插入位置</title>
    <link href="/2022/08/06/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <url>/2022/08/06/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>原题：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>（请必须使用时间复杂度为 O(log n) 的算法）</p><p>示例 1:</p><p>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br>示例 2:</p><p>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br>示例 3:</p><p>输入: nums = [1,3,5,6], target = 7<br>输出: 4<br>示例 4:</p><p>输入: nums = [1,3,5,6], target = 0<br>输出: 0<br>示例 5:</p><p>输入: nums = [1], target = 0<br>输出: 0</p><hr><p>这道题我给想复杂了，这里仅仅需要的是插入的位置，并不需要对整个数组进行排序。逐个去对比每个元素是否相等的操作实在有点傻。</p><ul><li>当目标值小于数组中的最大元素时，可以在遍历中进行比较，当某个元素大于目标值时，直接将当前的索引返回，不需要再去管后面的数组怎么放置。</li><li>当目标值大于数组中的最大元素时，该元素自然就会放在数组的最后一个位置，即数组的长度值。</li></ul><p>这里有一个点就是不需要去新建一个数组、想着把旧数组的值存入新数组，这样很傻，效率也很低，内存使用更多……这也就是评论区说取巧的地方。原数组length为5，最大index为4，插入目标值后新数组length为6，最大index为5，因此对于数组来说，新加入一个元素，新元素的索引值就是原数组的length。取巧就是取的数组规则的巧，元素的索引永远比它所在的长度-1。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;=<span class="hljs-keyword">target</span>) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-724. 寻找数组的中心下标</title>
    <link href="/2022/08/06/LeetCode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/"/>
    <url>/2022/08/06/LeetCode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p><p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p><p>示例 1：</p><p>输入：nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>中心下标是 3 。<br>左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，<br>右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。<br>示例 2：</p><p>输入：nums = [1, 2, 3]<br>输出：-1<br>解释：<br>数组中不存在满足此条件的中心下标。<br>示例 3：</p><p>输入：nums = [2, 1, -1]<br>输出：0<br>解释：<br>中心下标是 0 。<br>左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），<br>右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</p><hr><p>这道题并不是我自己想出来的，是看了题目下的评论分析了很久才想到的（惭愧了），我晚上回家后自己根据白天的思路写出来的。其实原理也挺巧妙的。除了特殊情况（中心索引为0）要额外考虑，其他都是正常的去比大小。做这种题目真的觉得自己人都傻了，连简单的比大小、加减法都不会做了。</p><p>分析：重点在于——中心下标的定义：其<strong>左侧所有元素相加的和</strong>等于<strong>右侧所有元素相加的和</strong>。∑左侧元素=∑右侧元素，千万不能直接去简单的想，遍历元素时把左侧元素之和加上、把右侧元素之和加上，然后再对比。这样我没试过啊，而且想一想就觉得效率太慢了。这样想才是正确的：∑a的左侧元素 = (∑0<del>a) - a ，同理，∑a右侧元素 = ( ∑所有元素 ) - ( ∑0</del>a )。由此对比就可算出数组中是否存在中心索引。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> pivotIndex(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> end=<span class="hljs-number">0</span>,<span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>,flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length; i++)&#123;<br>            <span class="hljs-keyword">sum</span> +=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == <span class="hljs-keyword">sum</span>-nums[<span class="hljs-number">0</span>])&#123;  <span class="hljs-comment">//如果第一个元素右侧所有元素和为0，则中心索引为0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;nums.length; j++)&#123; <span class="hljs-comment">//必须从索引为0的元素开始加起，否则会漏掉一个元素</span><br>            flag += nums[j];  <span class="hljs-comment">//当前循环中已遍历过的元素之和</span><br>            end = <span class="hljs-keyword">sum</span>-flag;  <span class="hljs-comment">//当前循环未遍历的元素之和</span><br>            <span class="hljs-keyword">if</span>(end == flag)&#123;<br>                <span class="hljs-keyword">return</span> j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">//如果没有对比出符合条件的，则返回-1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker进阶-Dockerfile-镜像构建发布</title>
    <link href="/2022/08/06/Docker%E8%BF%9B%E9%98%B6-Dockerfile-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83/"/>
    <url>/2022/08/06/Docker%E8%BF%9B%E9%98%B6-Dockerfile-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="Dockerfile的组成"><a href="#Dockerfile的组成" class="headerlink" title="Dockerfile的组成"></a>Dockerfile的组成</h2><p>构建docker镜像的文件，命令+参数+脚本</p><p>步骤</p><ol><li>编写一个dockerfile文件</li><li>docker build 构建成一个镜像</li><li>docker run运行镜像</li><li>docker push发布镜像至DockerHub或阿里云镜像仓库</li></ol><p>官方做法：在dockerHub中随意点击一个镜像的版本，就会跳转至github的DockerFile目录，如cengtos7显示如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus">FROM scratch <br> <br> <br>ADD centos-<span class="hljs-number">7</span>-x86_64-docker<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.xz</span> /<br> <br>LABEL \<br> <br>org<span class="hljs-selector-class">.label-schema</span>.schema-version=<span class="hljs-string">&quot;1.0&quot;</span> \<br> <br>org<span class="hljs-selector-class">.label-schema</span>.name=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \<br> <br>org<span class="hljs-selector-class">.label-schema</span>.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \<br> <br>org<span class="hljs-selector-class">.label-schema</span>.license=<span class="hljs-string">&quot;GPLv2&quot;</span> \<br> <br>org<span class="hljs-selector-class">.label-schema</span>.build-date=<span class="hljs-string">&quot;20201113&quot;</span> \<br> <br>org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.title=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \<br> <br>org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \<br> <br>org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.licenses=<span class="hljs-string">&quot;GPL-2.0-only&quot;</span> \<br> <br>org<span class="hljs-selector-class">.opencontainers</span><span class="hljs-selector-class">.image</span>.created=<span class="hljs-string">&quot;2020-11-13 00:00:00+00:00&quot;</span><br> <br> <br>CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>官方的镜像一般是基础包，只要能跑起来即可，很多功能是没有的，所以一般都是自己搭建镜像（使用docker指令）</p><p>实际工作中，docker镜像甚至是交付的标准，项目做好之后必须打包成docker镜像来交付：</p><p>原则：</p><ul><li>指令是大写字母</li><li>执行顺序从上至下，每个指令都会创建提交一个新的镜像层</li></ul><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806200522.png"></p><p>Dockerfile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages：通过Dockerfile构建生成的镜像，最终发布和运行的产品</p><p>Docker容器：镜像运行起来提供服务器</p><h2 id="Docker指令"><a href="#Docker指令" class="headerlink" title="Docker指令"></a>Docker指令</h2><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806200538.png"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span>           <span class="hljs-comment">#基础镜像，一切从这里开始构建</span><br><span class="hljs-keyword">MAINTAINER</span>     <span class="hljs-comment">#镜像的署名和联系方式</span><br><span class="hljs-keyword">RUN</span><span class="language-bash">            <span class="hljs-comment">#镜像构建时需要运行的命令</span></span><br><span class="hljs-keyword">ADD</span><span class="language-bash">            <span class="hljs-comment">#添加内容，源文件可以是相对路径，可以是url，特可以是tar.gz文件（会自动解压）</span></span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash">        <span class="hljs-comment">#镜像的工作目录</span></span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash">         <span class="hljs-comment">#挂载的目录</span></span><br><span class="hljs-keyword">EXPOSE</span>         <span class="hljs-comment">#保留端口配置，开启后外部无需使用-p</span><br><span class="hljs-keyword">CMD</span><span class="language-bash">            <span class="hljs-comment">#指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span></span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash">     <span class="hljs-comment">#指定这个容器启动的时候要运行的命令，可以追加命令</span></span><br><span class="hljs-keyword">ONBUILD</span>        <span class="hljs-comment">#当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令 ，触发指令</span><br><span class="hljs-keyword">COPY</span><span class="language-bash">           <span class="hljs-comment">#类似ADD，将文件拷贝至镜像中，格式：COPY 源目标 目的目标。多个命令使用&amp;&amp;拼接</span></span><br><span class="hljs-keyword">ENV</span>            <span class="hljs-comment">#构建的时候设置环境变量</span><br></code></pre></td></tr></table></figure><p><strong>备注：CMD与ENTRYPOINT的区别</strong></p><p>当一个镜像使用CMD指定容器启动后运行的命令时，只有最后一个会真实生效，并且当从外部启动时新增了额外的命令时，CMD的命令会被替代。如：构建镜像时使用了CMD [‘ls’, ‘-a’]，启动容器后会自动打印当前目录列表，但如果启动时额外加了参数 -l，这时的-l并不会和ls -a合并成新命令，而是替代ls -a作为新命令。但-l并非完整命令，所以当容器启动时就会报错</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806200655.png"></p><p> 当一个镜像使用ENTRYPOINT指定容器启动后运行的命令时，在外部启动容器时可以追加命令，拿上面的例子说，如果构建时使用ENTRYPOINT [‘ls’, ‘-a’]，外部启动时额外加了-l，则这里的-l会和镜像自带的ls -a 合并成完整命令ls -al </p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806200708.png"></p><h2 id="配置带vim-和ifconfig的CentOS"><a href="#配置带vim-和ifconfig的CentOS" class="headerlink" title="配置带vim 和ifconfig的CentOS"></a>配置带vim 和ifconfig的CentOS</h2><p>手动配置镜像，一般从scratch 开始（dockerhub中99%的镜像从这个基础镜像过来的）。手动配置之前，可以用<strong>docker history</strong>命令查看其他镜像的构建步骤：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806200810.png"></p><p> 编辑Dockerfie文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos dockerfile]<span class="hljs-comment"># vim centos-yz #这里的centos-yz如果写成Dockerfile，则编译时无需-f寻找编译文件，会自动寻找</span><br><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">MAINTAINER</span> zhouyinlin&lt;<span class="hljs-number">1909423593</span>@qq.com&gt;<br><span class="hljs-keyword">ENV</span> MYPATH /root/<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MYPATH</span></span><br><span class="hljs-comment">#构建时运行的命令</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span><br><span class="hljs-comment">#打开端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-variable">$PATH</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;------------------end-------------------&quot;</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span><br>[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos dockerfile]<span class="hljs-comment"># docker build -f centos-yz -t centos-yz:1.0 . #开始构建</span><br></code></pre></td></tr></table></figure><p>构建后进入新的CentOS，发现vim和ifconfig都有了</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@VM-0-7-centos dockerfile]<span class="hljs-comment"># docker images</span><br>REPOSITORY            TAG       IMAGE ID       CREATED          SIZE<br>centos-yz             1.0       a2f9e606e2c5  <span class="hljs-number"> 15 </span>seconds ago   322MB<br> <br>[root@VM-0-7-centos dockerfile]<span class="hljs-comment"># docker run -it centos-yz:1.0</span><br>[root@4103126b11ae ~]<span class="hljs-comment"># vim</span><br>[root@4103126b11ae ~]<span class="hljs-comment"># ifconfig</span><br>eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 172.18.0.2  netmask 255.255.0.0  broadcast 172.18.255.255<br>        ether 02:42:ac:12:00:02  txqueuelen<span class="hljs-number"> 0 </span> (Ethernet)<br>        RX packets<span class="hljs-number"> 8 </span> bytes<span class="hljs-number"> 656 </span>(656.0 B)<br>        RX errors<span class="hljs-number"> 0 </span> dropped<span class="hljs-number"> 0 </span> overruns<span class="hljs-number"> 0 </span> frame 0<br>        TX packets<span class="hljs-number"> 0 </span> bytes<span class="hljs-number"> 0 </span>(0.0 B)<br>        TX errors<span class="hljs-number"> 0 </span> dropped<span class="hljs-number"> 0 </span>overruns<span class="hljs-number"> 0 </span> carrier<span class="hljs-number"> 0 </span> collisions 0<br> <br> <br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        loop  txqueuelen<span class="hljs-number"> 1000 </span> (Local Loopback)<br>        RX packets<span class="hljs-number"> 0 </span> bytes<span class="hljs-number"> 0 </span>(0.0 B)<br>        RX errors<span class="hljs-number"> 0 </span> dropped<span class="hljs-number"> 0 </span> overruns<span class="hljs-number"> 0 </span> frame 0<br>        TX packets<span class="hljs-number"> 0 </span> bytes<span class="hljs-number"> 0 </span>(0.0 B)<br>        TX errors<span class="hljs-number"> 0 </span> dropped<span class="hljs-number"> 0 </span>overruns<span class="hljs-number"> 0 </span> carrier<span class="hljs-number"> 0 </span> collisions 0<br> <br>[root@4103126b11ae ~]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h2 id="配置自带Tomcat的镜像，且允许从外部部署项目"><a href="#配置自带Tomcat的镜像，且允许从外部部署项目" class="headerlink" title="配置自带Tomcat的镜像，且允许从外部部署项目"></a>配置自带Tomcat的镜像，且允许从外部部署项目</h2><p>编辑Dockerfile文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM centos<br>MAINTAINER ZHOUYINGLIN&lt;<span class="hljs-number">1909423593</span>@QQ.COM&gt;<br><br><br>COPY readme.txt <span class="hljs-regexp">/usr/</span>local/readme.txt <span class="hljs-comment">#阅读文档</span><br><br><span class="hljs-comment">#将压缩包和jdk添加到镜像</span><br>ADD apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">22</span>.tar.gz <span class="hljs-regexp">/usr/</span>local  <br>ADD jdk-<span class="hljs-number">8</span>u151-linux-x64.tar.gz <span class="hljs-regexp">/usr/</span>local<br><br><br>RUN yum -y install vim<br><br><span class="hljs-comment">#配置工作目录和路径</span><br>ENV MYPATH <span class="hljs-regexp">/usr/</span>local<br>WORKDIR <span class="hljs-variable">$MYPATH</span><br><br><span class="hljs-comment">#配置相关的环境变量</span><br>ENV JAVA_HOME <span class="hljs-regexp">/usr/</span>local/jdk1.<span class="hljs-number">8.0</span>_151<br>ENV CLASSPATH <span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib/</span>dt.jar:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib/</span>tools.jar<br>ENV CATALINA_HOME <span class="hljs-regexp">/usr/</span>local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">22</span><br>ENV CATALINA_BASH <span class="hljs-regexp">/usr/</span>local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">22</span><br>ENV PATH <span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/bin:$CATALINA_HOME/</span>lib:<span class="hljs-variable">$CATALINA_HOME</span>/bin<br><br><span class="hljs-comment">#开放端口</span><br>EXPOSE <span class="hljs-number">8080</span><br><br><span class="hljs-comment">#镜像运行时，就启动tomcat，并写入日志</span><br>CMD <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache-tomcat-9.0.22/</span>bin<span class="hljs-regexp">/startup.sh &amp;&amp; tail -F /u</span>sr<span class="hljs-regexp">/local/</span>apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">22</span><span class="hljs-regexp">/logs/</span>catalina.out<br></code></pre></td></tr></table></figure><p>构建镜像并启动容器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker build -tdiytomcat . <span class="hljs-comment">#这里由于dockerfile名叫：Dockerfile，因此无需再加-f 但注意后面的点，表示是当前目录的</span><br><br><span class="hljs-comment">#开放宿主机的9090端口映射至容器的8080端口，挂载两个目录：1.项目目录 2.日志存放目录</span><br><span class="hljs-comment">#宿主机的tomcat/project映射到webapps下的test目录，test项目下所有文件都可以从外部部署进去</span><br>docker run -d -p <span class="hljs-number">9090</span>:<span class="hljs-number">8080</span> --name newtomcat -v <span class="hljs-regexp">/root/</span>dockerfile<span class="hljs-regexp">/tomcat/</span>project:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache-tomcat-9.0.22/</span>webapps<span class="hljs-regexp">/test -v /</span>root<span class="hljs-regexp">/dockerfile/</span>tomcat<span class="hljs-regexp">/logs:/u</span>sr<span class="hljs-regexp">/local/</span>apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">22</span>/logs diytomcat<br></code></pre></td></tr></table></figure><p>目前为止，就可以正常的在宿主机或者外部网络访问到tomcat的主页啦。项目就弄一个简单的网页就好了，再以IP:port/项目名就可以访问项目主页了</p><p>新建项目</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">在宿主机的project下新建WEB<span class="hljs-literal">-INF</span>等目录、文件，层级如下：<br>project<br>    WEB<span class="hljs-literal">-INF</span>O<br>        web.<span class="hljs-keyword">xml</span><br>    <span class="hljs-title">index</span>.jsp<br></code></pre></td></tr></table></figure><p>文件描述</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">web.xml<br><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>index.jsp</strong></p><p>&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”</p><p>  pageEncoding=”UTF-8”%&gt;</p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>new tomcat</title></head><body><p>​    恭喜，web项目已经搭建完成。</p></body></html> <h2 id="发布镜像至DockerHub"><a href="#发布镜像至DockerHub" class="headerlink" title="发布镜像至DockerHub"></a>发布镜像至DockerHub</h2><p>发布镜像到dockerHub上，首先要做的事应该是登录。如果没有登录过，那么需要先注册账号：<a href="https://hub.docker.com/">https://hub.docker.com/</a> 。登录好之后才可以提交镜像，docker中的登录的帮助文档长这样：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos project]# docker login --help<br><br><br><span class="hljs-symbol">Usage:</span>  docker login [OPTIONS] [SERVER]<br><br><br>Log <span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> a Docker registry.<br><span class="hljs-keyword">If</span> no server <span class="hljs-built_in">is</span> specified, the <span class="hljs-keyword">default</span> <span class="hljs-built_in">is</span> defined <span class="hljs-keyword">by</span> the daemon.<br><br><br><span class="hljs-symbol">Options:</span><br>  -p, --password <span class="hljs-type">string</span>   Password<br>      --password-stdin    <span class="hljs-keyword">Take</span> the password <span class="hljs-keyword">from</span> stdin<br>  -u, --username <span class="hljs-type">string</span>   Username<br></code></pre></td></tr></table></figure><p>登录好之后，就可以使用docker push提交镜像</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">root@VM-0-7-centos</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># docker push diytomcat</span><br><span class="hljs-attr">Using default tag:</span> <span class="hljs-string">latest</span><br><span class="hljs-string">The</span> <span class="hljs-string">push</span> <span class="hljs-string">refers</span> <span class="hljs-string">to</span> <span class="hljs-string">repository</span> [<span class="hljs-string">docker.io/library/diytomcat</span>]<br><span class="hljs-attr">ffb151e67a73:</span> <span class="hljs-string">Preparing</span><br><span class="hljs-attr">23127db07fa3:</span> <span class="hljs-string">Preparing</span><br><span class="hljs-attr">1e438b048a4f:</span> <span class="hljs-string">Preparing</span><br><span class="hljs-attr">328e77a13569:</span> <span class="hljs-string">Preparing</span><br><span class="hljs-attr">74ddd0ec08fa:</span> <span class="hljs-string">Preparing</span><br><span class="hljs-attr">denied:</span> <span class="hljs-string">requested</span> <span class="hljs-string">access</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">resource</span> <span class="hljs-string">is</span> <span class="hljs-string">denied</span>  <span class="hljs-comment">#提示拒绝</span><br></code></pre></td></tr></table></figure><p>这里有一个提示错误，因为是我们的push格式有错误。所以不会上去的。正确的命令格式应该是先将做好的镜像使用tag命令规范命名</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#格式：用户名/镜像名:版本号。创建完后会出现一个一样的镜像</span><br>[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># docker tag diytomcat zhouyinglin/diytomcat:v1</span><br>[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># docker images</span><br>REPOSITORY              <span class="hljs-keyword">TAG</span>       <span class="hljs-title">IMAGE</span> ID       CREATED         SIZE<br>diytomcat               latest    <span class="hljs-number">50316</span>eed1aeb   <span class="hljs-number">5</span> hours ago     <span class="hljs-number">695M</span>B<br>zhouyinglin/diytomcat   v1        <span class="hljs-number">50316</span>eed1aeb   <span class="hljs-number">5</span> hours ago     <span class="hljs-number">695M</span>B<br></code></pre></td></tr></table></figure><p>接着我们就可以正常使用push命令了。云服务器的小水管虽然慢，但毕竟是阿里的网，也是能够上传完的，本地网络的话就有可能传不上去，毕竟DockerHub是国外的</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">[root@VM-0-7-centos ~]<span class="hljs-comment"># docker push zhouyinglin/diytomcat:v1</span><br>The push refers <span class="hljs-keyword">to</span> repository [docker.io/zhouyinglin/diytomcat]<br>ffb151e67a73: Pushing [=====================&gt;                             ]  <span class="hljs-number">26.99</span>MB/<span class="hljs-number">64</span>MB<br><span class="hljs-number">23127db</span>07fa3: Pushing [=&gt;                                                 ]  <span class="hljs-number">10.98</span>MB/<span class="hljs-number">384.4</span>MB<br><span class="hljs-number">1e</span>438b048a4f: Pushing [==================================================&gt;]  <span class="hljs-number">15.41</span>MB/<span class="hljs-number">15.41</span>MB<br><span class="hljs-number">328e</span>77a13569: Pushing [==================================================&gt;]  <span class="hljs-number">3.072k</span>B<br><span class="hljs-number">74ddd</span>0ec08fa: Pushing [=====&gt;                                             ]  <span class="hljs-number">23.48</span>MB/<span class="hljs-number">231.3</span>MB<br></code></pre></td></tr></table></figure><h2 id="发布镜像至阿里云镜像仓库"><a href="#发布镜像至阿里云镜像仓库" class="headerlink" title="发布镜像至阿里云镜像仓库"></a>发布镜像至阿里云镜像仓库</h2><p>登录阿里云仓库：<a href="https://cr.console.aliyun.com/cn-hangzhou/instance/repositories">https://cr.console.aliyun.com/cn-hangzhou/instance/repositories</a></p><p>创建命名空间</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806201034.png"></p><p>创建容器镜像</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806201046.png"></p><p>查看仓库面板</p><p>仓库地址：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806201101.png"></p><p>官方push流程</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806201113.png"></p><p>这里其实只要注意一个点就行了，就是需要将自己的镜像按照阿里云的操作流程，修改tag</p><p>在DockerHub中，tag一般修改成DockerHub用户名/镜像名:版本号</p><p>在阿里云中，tag要求修改成docker tag [ImageId] <a href="http://registry.cn-hangzhou.aliyuncs.com/yz-zhouyinglin/resp">registry.cn-hangzhou.aliyuncs.com/yz-zhouyinglin/resp</a> : 版本号</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># docker tag 50316eed1aeb registry.cn-hangzhou.aliyuncs.com/yz-zhouyinglin/resp:v1</span><br>[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># docker images</span><br>REPOSITORY                                              <span class="hljs-keyword">TAG</span>       <span class="hljs-title">IMAGE</span> ID       CREATED         SIZE<br>diytomcat                                               latest    <span class="hljs-number">50316</span>eed1aeb   <span class="hljs-number">6</span> hours ago     <span class="hljs-number">695M</span>B<br>registry.cn-hangzhou.aliyuncs.com/yz-zhouyinglin/resp   v1        <span class="hljs-number">50316</span>eed1aeb   <span class="hljs-number">6</span> hours ago     <span class="hljs-number">695M</span>B<br></code></pre></td></tr></table></figure><p>修改之后才可以进行push，当然也是速度很慢，毕竟是学生机小水管</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">[root@VM-0-7-centos ~]<span class="hljs-comment"># docker push registry.cn-hangzhou.aliyuncs.com/yz-zhouyinglin/resp:v1</span><br>The push refers <span class="hljs-keyword">to</span> repository [registry.cn-hangzhou.aliyuncs.com/yz-zhouyinglin/resp]<br>ffb151e67a73: Pushing [===========================================&gt;       ]  <span class="hljs-number">55.78</span>MB/<span class="hljs-number">64</span>MB<br><span class="hljs-number">23127db</span>07fa3: Pushing [========&gt;                                          ]  <span class="hljs-number">64.83</span>MB/<span class="hljs-number">384.4</span>MB<br>ffb151e67a73: Pushed<br><span class="hljs-number">23127db</span>07fa3: Pushing [==========&gt;                                        ]  <span class="hljs-number">77.64</span>MB/<span class="hljs-number">384.4</span>MB<br><span class="hljs-number">74ddd</span>0ec08fa: Pushing [=================&gt;                                 ]  <span class="hljs-number">78.85</span>MB/<span class="hljs-number">231.3</span>MB<br><span class="hljs-number">74ddd</span>0ec08fa: Pushing [===================&gt;                               ]  <span class="hljs-number">90.89</span>MB/<span class="hljs-number">231.3</span>MB<br></code></pre></td></tr></table></figure><p>push结束</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">root@VM-0-7-centos</span> <span class="hljs-string">~</span>]<span class="hljs-comment"># docker push registry.cn-hangzhou.aliyuncs.com/yz-zhouyinglin/resp:v1</span><br><span class="hljs-string">The</span> <span class="hljs-string">push</span> <span class="hljs-string">refers</span> <span class="hljs-string">to</span> <span class="hljs-string">repository</span> [<span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/yz-zhouyinglin/resp</span>]<br><span class="hljs-attr">ffb151e67a73:</span> <span class="hljs-string">Pushing</span> [<span class="hljs-string">===========================================&gt;</span>       ]  <span class="hljs-number">55.</span><span class="hljs-string">78MB/64MB</span><br><span class="hljs-attr">23127db07fa3:</span> <span class="hljs-string">Pushing</span> [<span class="hljs-string">========&gt;</span>                                          ]  <span class="hljs-number">64.</span><span class="hljs-string">83MB/384.4MB</span><br><span class="hljs-attr">ffb151e67a73:</span> <span class="hljs-string">Pushed</span> <br><span class="hljs-attr">23127db07fa3:</span> <span class="hljs-string">Pushing</span> [<span class="hljs-string">==================================================&gt;</span>]  <span class="hljs-number">385.</span><span class="hljs-string">7MB</span><br><span class="hljs-attr">1e438b048a4f:</span> <span class="hljs-string">Pushed</span> <br><span class="hljs-attr">23127db07fa3:</span> <span class="hljs-string">Pushed</span> <br><span class="hljs-attr">v1: digest: sha256:a08b7a9ba95cb7cc624975f07d2fb4b686f316d1ae319cc557f2ce71291c7c26 size:</span> <span class="hljs-number">1373</span><br></code></pre></td></tr></table></figure><p>在阿里云的版本页面可以看到push 上来的镜像</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806201143.png"></p><p>——————————————-Docker入门结束——————————————–</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806201204.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>unix、dos、mac文本格式区分</title>
    <link href="/2022/08/06/unix%E3%80%81dos%E3%80%81mac%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%BA%E5%88%86/"/>
    <url>/2022/08/06/unix%E3%80%81dos%E3%80%81mac%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%BA%E5%88%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>如果开发的环境是unix、dos并存，那么一定会碰到文本格式的问题。比如dos环境中（win下的notepad++）编辑的脚本文件传输到linux上，行尾会多出来一个^M，导致脚本在linux上无法运行，这就是fileformat的问题。由于历史原因，unix、dos、mac三家系统采用的是不同的行结束符，unix是\n，windows是复古的\r\n（也不是所有windows上编辑的都是dos），mac则是\r，避免方法如下：</p><ul><li>在vim命令模式下，输入:set ff=unix</li><li>在vimrc中添加一行，set fileformat=unix,dos</li></ul><p>举例：</p><ul><li>从服务器上下载来的日志文件，用UltraEdit打开会显示是否转换成dos格式</li><li>有时候在notepad++上打开的文本，后面行尾会有黑色方块</li></ul><p> 这里也不需要扯太深，往深了说的得扯到字节的传输模式了，我们只需要知主流三种系统对行尾符有不同的解释，在不同的平台上打开会出现哪些问题、以及怎么解决就可以了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux探秘————/dev/null与/dev/zero</title>
    <link href="/2022/08/06/Linux%E6%8E%A2%E7%A7%98%E2%80%94%E2%80%94%E2%80%94%E2%80%94-dev-null%E4%B8%8E-dev-zero/"/>
    <url>/2022/08/06/Linux%E6%8E%A2%E7%A7%98%E2%80%94%E2%80%94%E2%80%94%E2%80%94-dev-null%E4%B8%8E-dev-zero/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="dev目录"><a href="#dev目录" class="headerlink" title="/dev目录"></a>/dev目录</h2><p>/dev目录挂载了linux的所有外部设备，dev意为device，是linux访问外部设备的端口，但没有入口，只能通过挂载的方式访问，在任意一台正常使用的服务器上，/dev下面的文件是很多的，因为linux遵循unix万物皆文件的风格。常见的设备有：</p><ul><li>/dev/hd[a-t]：IDE设备，硬盘</li><li>/dev/sd[a-z]：SCSI设备</li><li>/dev/ram[0-15]内存</li><li>………</li></ul><p>还有很多，剩下不常见的就不一一举例了，也没啥意义，主要介绍俩新奇东西：/dev/null 和 /dev/zero</p><h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><p>在类unix系统中，/dev/null称为空设备，是一个特殊的外部设备端口，它丢弃一切写入其中的数据（但写入会提示成功），如果尝试读取它，会立即得到一个EOF。行话称为位桶（bit bucket）或者黑洞（black hole），空设备一般用于丢弃不需要的输出流，或作为输入流的空文件，这些操作一般由重定向完成。如：</p><p>cat file意思是输出file内容至标准输出（即终端）</p><p>cat file &gt; /dev/null 则输出直接丢失</p><p>cat file 2&gt;/dev/null 当file不存在时，也不会报错，因为标准错误输出重定向至位桶了。</p><p>网上有个例子：cat file 2&gt;/dev/null &gt;/dev/null 可以当做检测文本文件file而存在，但我觉得好像不太管用，因为这相当于不管file是否存在，它都不会报错，那还怎么检测file是否存在呢？还不如直接用find ./-name file</p><h2 id="dev-zero"><a href="#dev-zero" class="headerlink" title="/dev/zero"></a>/dev/zero</h2><p>在类unix系统中，/dev/zero是一个特殊的文件，当你读它的时候，它会提供无线的空字符（null、ascii null、0x00）。其中一个典型的用法就是用它提供的字符流来覆盖信息，另一个用法就是产生一个特定大小的空白文件。</p><p>OK，上面这段是来自wiki的官方描述，实际上这玩意儿对普通用户真的没有什么作用，说是可以初始化文件，但我尝试用cat /dev/zero &gt; zero.log时发现没几秒种这个文件就被塞进去6个G的乱码，我看了下速度是6.7G/s……吓得我赶紧停掉，后来查了下，正确的用法应该是使用dd命令从/dev/zero里任意大小的块出来：</p><p>dd if=/dev/zero of=/dev/raw bs=xxx count=xxx 。</p><p>bs：输出的块的大小，单位byte，count：块的数量</p><p>如此，我们再尝试：dd if=/dev/zero of=/home/zero.log bs=1024 count=1 得到的结果就是一个1kb的空文件，cat zero.log不会打印任何内容，vim编辑进去却有很多^@符号，应该是文本格式的原因</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Crontab食用指南</title>
    <link href="/2022/08/06/Linux-Crontab%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2022/08/06/Linux-Crontab%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="Crontab是啥？"><a href="#Crontab是啥？" class="headerlink" title="Crontab是啥？"></a>Crontab是啥？</h2><p>我们先来看看wiki的说法：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195943.png"></p><p>再来看看官方（<a href="http://crontab.org/%EF%BC%89%E5%AF%B9crontab%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A">http://crontab.org/）对crontab的定义：</a></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195954.png"></p><p> 大概说明了crontab命令的使用方法、参数的使用等注意事项，其实这些中文网已经有很多了。推荐一个小网站：<a href="https://tool.lu/crontab">https://tool.lu/crontab</a> 这个网站可以用来执行我们的cron表达式，以检测是否有错误。我发现这种小工具网站是真的多，而且一个比一个好，一个比一个全，真的牛皮</p><p>好了，现在我们知道了，原来crontab中文名：任务时间表。它是linux家出厂自带的，像我的云服务器（腾讯云centos7）自己就带了一个我也不知道干嘛用的cron job，百度看好像是加什么文件锁的。等以后功力足够了再去深究</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># crontab -l</span><br>*<span class="hljs-regexp">/5 * * * * flock -xn /</span>tmp<span class="hljs-regexp">/stargate.lock -c &#x27;/u</span>sr<span class="hljs-regexp">/local/</span>qcloud<span class="hljs-regexp">/stargate/</span>admin<span class="hljs-regexp">/start.sh &gt; /</span>dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>还是先来看看linux自带的crontab文件是怎么定义的吧</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[root<span class="hljs-variable">@DockerHost</span> install] cat /etc/crontab<br><span class="hljs-variable constant_">SHELL</span>=<span class="hljs-regexp">/bin/bash</span><br><span class="hljs-variable constant_">PATH</span>=<span class="hljs-regexp">/sbin:/bin</span><span class="hljs-symbol">:/usr/sbin</span><span class="hljs-symbol">:/usr/bin</span><br><span class="hljs-variable constant_">MAILTO</span>=root<br><br><span class="hljs-comment"># For details see man 4 crontabs</span><br><span class="hljs-comment"># Example of job definition:</span><br><span class="hljs-comment"># .----------------- minute (0 - 59)</span><br><span class="hljs-comment"># | .---------------hour (0 - 23)</span><br><span class="hljs-comment"># | | .------------ day of month (1 - 31)</span><br><span class="hljs-comment"># | | | ----------month (1 - 12) OR jan,feb,mar,apr...</span><br><span class="hljs-comment"># | | | | .——day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="hljs-comment"># | I I I I</span><br>* * * * * * user-name command to be executed<br></code></pre></td></tr></table></figure><p>案例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 井号注释，不执行</span><br><span class="hljs-bullet">*</span> 表示不限制，每个时间单位都会执行1<br><span class="hljs-bullet">-</span> 表示整数列，如1-4代表1, 2, 3, 4<br>，代表指定的数，如1,4,6代表1、4、6<br>/ 代表步进值，如0-59/2代表每2分钟执行一次(?),也可用<span class="hljs-emphasis">*表示，如*</span>/3是每3个月运行指定任务<br>run-parts后面跟文件夹，目的是执行该目录下所有脚本文件<br></code></pre></td></tr></table></figure><p>非root用户创建cron: 先在家目录/home/linkdo下创建linkdocron文件，系统会生成一个副本文件linkdo在/var/spool/cron/下，但普通用户并不能直接对她读写，只能通过crontab-e来修改。官方推荐应该是使用crontab -e来修改cron job，但这种修改好像只会改动/var/spool/cron/linkdo，/home/linkdocron并不会改动，导致我crontab -e完了就crontab linkdocron一下，结果半天没改动。实际上通过crontab-e 修改后，无需重新crontab <user>cron，直接就可以运行，如果还是不能运行，就重启cron线程</p><p>crontab例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> /5 <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">* *</span>每5分钟执行一次，不限时、天、周、月<br>0,30 18-06 <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">*每天18点到6点之内，每隔半小时执行一次</span><br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果一个cron务需要定期而不是按每小时，天，周，月来执行，则需要添加/etc/cron.d目录，语法与/etc/crontab一致</li><li> crontab是由系统自动调度的，所以并不会加载任何环境变量，需要在crontab中指定任务运行所需的环境变量。一般来说，手动执行没问题，crontab执行有问题的，都是环境变量的问题</li><li>如果执行的是脚本 ， 脚本中的路径需要使用全局路径</li><li>需要用到其他变量时，需source引入所需环境变量</li><li>crontab突然失效时 可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron</li><li>crontab job分为系统级调题和用户级调度（root用户也属于用户级调度）。用户级任务调度可以通过”crontab -uroot -e”升级为系统及调度，或者直接将调度任务写入/etc/crontab,例如定时重后系统，需要写如/etc/crontab下，写root下是没用的</li><li>crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%,如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker进阶-挂载-容器数据卷</title>
    <link href="/2022/08/06/Docker%E8%BF%9B%E9%98%B6-%E6%8C%82%E8%BD%BD-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <url>/2022/08/06/Docker%E8%BF%9B%E9%98%B6-%E6%8C%82%E8%BD%BD-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>卷技术，作用是数据共享。由于容器删除后内部修改的数据也会丢失，因此需要有个地方存储数据。 卷技术可以让容器本地产生的数据映射到本地，卷技术的本质是目录的挂载，将容器内部的目录挂载到宿主机上，实现容器持久化。包括容器间也可以共享</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> -v 主机目录:容器目录<br><span class="hljs-comment"># 就算重启容器，映射关系也还是会存在</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195614.png"></p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>navicat连接到云服务器的3305端口，映射到docker容器的3306端口，即可连接成功</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d -p <span class="hljs-number">3305</span>:<span class="hljs-number">3306</span> -v <span class="hljs-regexp">/home/my</span>sql<span class="hljs-regexp">/conf:/</span>etc<span class="hljs-regexp">/mysql/</span>conf.d -v <span class="hljs-regexp">/home/my</span>sql<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql  -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:<span class="hljs-number">5.7</span><br><br>-v:挂载卷<br><br>-e：配置环境，这里是设置root密码<br><br>本地创建数据库，数据直接是同步的。就算将容器删除，挂载到本地的数据卷中的数据也不会丢失<br></code></pre></td></tr></table></figure><h2 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h2><h3 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h3><p>没有给挂载点取名。在-v时没有写容器外的路径，只写了容器内的路径</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[root@VM-0-7-centos ~]</span># docker run -d -<span class="hljs-selector-tag">P</span> <span class="hljs-attr">--name</span> jmnginx -v /etc/nginx nginx<br></code></pre></td></tr></table></figure><p>可以发现，匿名挂载的外部路径，默认是在 /var/lib/docker/volumes/xxx/_data</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livescript">[root@VM-0-7-centos ~]<span class="hljs-comment"># docker volume ls</span><br>DRIVER    VOLUME NAME<br>local     <span class="hljs-number">39e</span>68d440c53a251de69252c9e767a0386c88ddcf699d7ba42ec556e8c94d74b<br> <br>[root@VM-0-7-centos ~]<span class="hljs-comment"># docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                       NAMES<br><span class="hljs-number">25b</span>3bd3c330b   nginx     <span class="hljs-string">&quot;/docker-entrypoint.…&quot;</span>   <span class="hljs-number">4</span> minutes ago   Up <span class="hljs-number">4</span> minutes   <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">49153</span>-&gt;<span class="hljs-number">80</span>/tcp, :::<span class="hljs-number">49153</span>-&gt;<span class="hljs-number">80</span>/tcp     jmnginx<br> <br>[root@VM-0-7-centos ~]<span class="hljs-comment"># docker inspect jmnginx</span><br>…………<br><span class="hljs-string">&quot;Mounts&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;volume&quot;</span>,<br>                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;5940b7fbf8563daefa34a40270ac793bf2b2084d8e6702dc0c2999681542c66d&quot;</span>,<br>                <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/5940b7fbf8563daefa34a40270ac793bf2b2084d8e6702dc0c2999681542c66d/_data&quot;</span>,<br>                <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;/etc/nginx&quot;</span>,<br>                <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>                <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                <span class="hljs-string">&quot;RW&quot;</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>            &#125;<br>        ],<br>…………<br></code></pre></td></tr></table></figure><h3 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h3><p>为挂载卷指定名字，方便查找卷，一般都是使用具名挂载</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs golo">[root<span class="hljs-meta">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos _data]<span class="hljs-comment"># docker run -d -P --name nginx -v jmnginx:/etc/nginx nginx</span><br><span class="hljs-number">8052e5458</span>d216512b650455d97713e30fdb0dd31b49e22335cef8bb2a7625532<br>[root<span class="hljs-meta">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos _data]<span class="hljs-comment"># docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                       NAMES<br><span class="hljs-number">8052e5458</span>d21   nginx     <span class="hljs-string">&quot;/docker-entrypoint.…&quot;</span>   <span class="hljs-number">8</span> seconds ago   Up <span class="hljs-number">6</span> seconds   <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">49154</span>-&gt;<span class="hljs-number">80</span>/tcp, :::<span class="hljs-number">49154</span>-&gt;<span class="hljs-number">80</span>/tcp     nginx<br> <br>[root<span class="hljs-meta">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos _data]<span class="hljs-comment"># docker volume ls</span><br>DRIVER    VOLUME NAME<br><span class="hljs-keyword">local</span>     <span class="hljs-number">39e68</span>d440c53a251de69252c9e767a0386c88ddcf699d7ba42ec556e8c94d74b<br><span class="hljs-keyword">local</span>     <span class="hljs-number">5940</span>b7fbf8563daefa34a40270ac793bf2b2084d8e6702dc0c2999681542c66d<br><span class="hljs-keyword">local</span>     jmnginx<br> <br>[root<span class="hljs-meta">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos _data]<span class="hljs-comment"># docker volume inspect jmnginx</span><br>[<br>    &#123;<br>        <span class="hljs-string">&quot;CreatedAt&quot;</span>: <span class="hljs-string">&quot;2021-12-05T16:57:41+08:00&quot;</span>,<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Labels&quot;</span>: <span class="hljs-literal">null</span>,<br>        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/jmnginx/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;jmnginx&quot;</span>,<br>        <span class="hljs-string">&quot;Options&quot;</span>: <span class="hljs-literal">null</span>,<br>        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span><br>    &#125;<br>]<br>[root<span class="hljs-meta">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos _data]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>为容器挂载出来的内容设置读写权限</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos _data]# docker run -d -P --name nginx -v jmnginx:<span class="hljs-regexp">/etc/</span>nginx:ro/rw nginx<br> <br>:ro  <span class="hljs-keyword">read</span>-only  只读，只可通诺宿主机来操作，容器内不无法操作<br>:rw  <span class="hljs-keyword">read</span> <span class="hljs-keyword">write</span> 可读写（默认）<br></code></pre></td></tr></table></figure><h1 id="在DockerFile中挂载"><a href="#在DockerFile中挂载" class="headerlink" title="在DockerFile中挂载"></a><strong>在DockerFile中挂载</strong></h1><p>dockerfile用于构建docker镜像的构建文件，命令脚本。docker镜像是一层层的，dockerfile也是一个个命令的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos docker-test-<span class="hljs-keyword">volume</span><span class="language-bash">]<span class="hljs-comment"># cat dockerfile01   #新建脚本,注意，脚本中的指令都是大写的</span></span><br><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;volume01&quot;</span>,<span class="hljs-string">&quot;volume02&quot;</span>]</span><br> <br> <br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-------------end--------&quot;</span></span><br> <br> <br><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span><br></code></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>-f file名  -t 镜像名</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ada">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos docker-test-volume]# docker build -f dockerfile01 -t yuanzhou/centos:<span class="hljs-number">1.0</span> .<br>Sending build context to Docker daemon  <span class="hljs-number">2.048</span>kB<br>Step <span class="hljs-number">1</span>/<span class="hljs-number">4</span> : <span class="hljs-type">FROM</span> centos<br><span class="hljs-comment">---&gt; 5d0da3dc9764</span><br>Step <span class="hljs-number">2</span>/<span class="hljs-number">4</span> : <span class="hljs-type">VOLUME</span> [<span class="hljs-string">&quot;Vvolume01&quot;</span>,<span class="hljs-string">&quot;volume02&quot;</span>]<br><span class="hljs-comment">---&gt; Running in 794cbe294f47</span><br>Removing intermediate container <span class="hljs-number">794</span>cbe294f47<br><span class="hljs-comment">---&gt; 64be4f7b9f83</span><br>Step <span class="hljs-number">3</span>/<span class="hljs-number">4</span> : <span class="hljs-type">CMD</span> echo <span class="hljs-string">&quot;-------------end--------&quot;</span><br><span class="hljs-comment">---&gt; Running in f16a4be3b1c0</span><br>Removing intermediate container f16a4be3b1c0<br><span class="hljs-comment">---&gt; e9f0e352192d</span><br>Step <span class="hljs-number">4</span>/<span class="hljs-number">4</span> : <span class="hljs-type">CMD</span> /bin/bash<br><span class="hljs-comment">---&gt; Running in 7c1a9d4a1363</span><br>Removing intermediate container <span class="hljs-number">7</span>c1a9d4a1363<br><span class="hljs-comment">---&gt; 989969f6fbad</span><br>Successfully built <span class="hljs-number">989969</span>f6fbad<br>Successfully <span class="hljs-keyword">tagged</span> yuanzhou/centos:<span class="hljs-number">1.0</span><br> <br>[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos docker-test-volume]# docker images<br>REPOSITORY            TAG       IMAGE ID       CREATED         SIZE<br>yuanzhou/centos       <span class="hljs-number">1.0</span>       <span class="hljs-number">989969</span>f6fbad   <span class="hljs-number">3</span> minutes ago   <span class="hljs-number">231</span>MB<br></code></pre></td></tr></table></figure><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p>这种挂载也较为常用，如果构建镜像时没有挂载，就需要手动-v挂载</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tcl">[root@VM<span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos docker-test-volume]# docker run -it yuanzhou/centos:<span class="hljs-number">1.0</span> /bin/bash<br>[root@d6afa730c9b7 /]# ls<br>volume01  bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  <span class="hljs-keyword">proc</span><span class="hljs-title">  root</span> <span class="hljs-title"> run</span> <span class="hljs-title"> sbin</span> <span class="hljs-title"> srv</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span> <span class="hljs-title"> volume02</span><br> <br>#这里的volume01和volume02就是创建镜像时自动挂载的，这种目录属于匿名目录。使用inspect可以查看宿主机的目录<br>&quot;Mounts&quot;: [<br>            &#123;<br>                <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;volume&quot;</span>,<br>                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;c432ac4c1479b54b8b2248a5bd982b0d95f2909e605b0d1744bd9734c9f093f6&quot;</span>,<br>                <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/c432ac4c1479b54b8b2248a5bd982b0d95f2909e605b0d1744bd9734c9f093f6/_data&quot;</span>,<br>                <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;Vvolume01&quot;</span>,<br>                <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>                <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                <span class="hljs-string">&quot;RW&quot;</span>: true,<br>                <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;volume&quot;</span>,<br>                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;358875250c31b98b1b5ff64e17f7873f5b3ed65f75207e5f127d430ef89b5221&quot;</span>,<br>                <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/358875250c31b98b1b5ff64e17f7873f5b3ed65f75207e5f127d430ef89b5221/_data&quot;</span>,<br>                <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;volume02&quot;</span>,<br>                <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>                <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                <span class="hljs-string">&quot;RW&quot;</span>: true,<br>                <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>            &#125;<br>        ],<br></code></pre></td></tr></table></figure><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p> 多个容器挂载同一个目录。是容器之间的数据共享</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195757.png"></p><p>数据卷：挂载的目录</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--name centos02 --volumes-from d6afa730c9b7 yuanzhou/centos:1.0</span><br> <br><span class="hljs-comment">--volumes-from 从第一台机器volume出来的容器，数据卷目录的是共享的，即使源容器删掉目录也不会丢失，因为文件本身是存储在宿主机上的</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker基本</title>
    <link href="/2022/08/06/Docker%E5%9F%BA%E6%9C%AC/"/>
    <url>/2022/08/06/Docker%E5%9F%BA%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="单体Docker"><a href="#单体Docker" class="headerlink" title="单体Docker"></a>单体Docker</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195111.png"></p><p>Docker出现的契机：解决项目中的环境问题。docker的图标：鲸鱼上放了许多集装箱，也映射了docker的核心思想——隔离。每个箱子是互相隔离的。隔离机制也可以将linux服务器利用到极致</p><p>深究历史</p><p>2010年出现dotcloud，2013年开源后使用人数增多。2014年Docker1.0发布，基于Go语言开发。Docker优势是非常轻巧，在Docker之前一般都是使用虚拟机，非常笨重。Docker是容器技术，也属于一种虚拟化技术。一般linux最核心的环境不过4MB。</p><p>Docker与VM虚拟技术</p><p>虚拟机技术缺点：资源占用多、冗余步骤多、启动慢</p><p>容器化技术：不是模拟一个完整的操作系统</p><p>差异点：</p><ol><li>传统虚拟机先虚拟出一套硬件，运行完整的操作系统，再在系统上运行软件</li><li>容器内的应用直接运行在宿主机的内容，容器本身无内核，也没有硬件，且容器间互相隔离，文件系统都是不一样的</li></ol><p>优势：</p><ol><li><p>应用更快速的交付和部署</p></li><li><ul><li>传统交付需要借助文档、安装程序</li><li>docker打包镜像后发布测试，一键运行</li></ul></li><li><p>更便捷的升级和扩缩容</p></li><li><ul><li>部署应用快捷、项目打包为镜像后扩展方便</li></ul></li><li><p>更简单的系统运维</p></li><li><ul><li>开发、测试等环境高度一致</li></ul></li><li><p>更高效的计算资源利用</p></li><li><ul><li>内核级别的虚拟化，在一台物理机上可运行多个容器实例，服务器性能充分利用</li></ul></li></ol><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a><strong>Docker安装</strong></h2><p>架构图：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195138.png"></p><p>名词解释：</p><ol><li>镜像：相当于一个模板，通过镜像来创建容器。一个镜像可以创建多个容器</li><li>容器：通过容器可以独立运行一个或一个组应用，有启动、停止、删除等基本操作</li><li>仓库：存放镜像的地方，有共有仓库和私有仓库</li></ol><p>更换阿里云镜像地址：yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p><p>安装教程（linux）：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><p>配置阿里云镜像加速（教程地址：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors%EF%BC%89%EF%BC%9A">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors）：</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#修改daemon配置文件<span class="hljs-regexp">/etc/</span>docker/daemon.json来使用加速器<br>sudo mkdir -p <span class="hljs-regexp">/etc/</span>docker<br>sudo tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://1fd77tzz.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><p>工作原理</p><p>docker是一个Client-Server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问。DockerServer接收到DockerClient的指令，就会执行这个命令。docker中容器之间相互隔离，外部不能直接访问容器。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195206.png"></p><p>docker比vm快的原因</p><p>vm对比dc架构：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195217.png"></p><p>docker比vm少了一层Guest OS。直接利用宿主机的内核。因此在新建容器时，无需想vm一样加载一个操作系统内核，省略了这个复杂的过程，加载时间是秒级的</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195228.png"></p><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><p>docker version 版本信息</p><p>docker info 系统和容器相关信息</p><p>docker –help 帮助 ，官网文档地址：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/</a></p><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h3 id="docker-images-查看所有本地的主机上的镜像"><a href="#docker-images-查看所有本地的主机上的镜像" class="headerlink" title="docker images 查看所有本地的主机上的镜像"></a>docker images 查看所有本地的主机上的镜像</h3><p> -a, –all       Show all images (default hides</p><p>​            intermediate images)# 列出所有镜像</p><p>   –digests     Show digests</p><p> -q, –quiet      Only show image IDs #只显示镜像ID</p><h3 id="docker-search-搜索镜像"><a href="#docker-search-搜索镜像" class="headerlink" title="docker search 搜索镜像"></a>docker search 搜索镜像</h3><p>-f, –filter filter  Filter output based on conditions provided#过滤搜索</p><p>例如：docker search –filter=stars=5000 #寻找stars大于等于5000的镜像</p><h3 id="docker-pull-下载镜像"><a href="#docker-pull-下载镜像" class="headerlink" title="docker pull 下载镜像"></a>docker pull 下载镜像</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">格式：docker</span> <span class="hljs-string">pull</span> <span class="hljs-string">镜像名[:tag]（版本）</span><br><span class="hljs-attr">Using default tag:</span> <span class="hljs-string">latest</span> <span class="hljs-comment">#如果不写tag则是默认mlatest</span><br><span class="hljs-attr">latest:</span> <span class="hljs-string">Pulling</span> <span class="hljs-string">from</span> <span class="hljs-string">library/mysql</span><br><span class="hljs-attr">a10c77af2613:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span>  <span class="hljs-comment">#分层下载，docker images的核心：联合文件系统</span><br><span class="hljs-attr">b76a7eb51ffd:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span>  <span class="hljs-comment">#当下载其他镜像时，若有相同层的镜像，则不会重新下载，直接共用</span><br><span class="hljs-attr">258223f927e4:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">2d2c75386df9:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">63e92e4046c9:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">f5845c731544:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">bd0401123a9b:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">3ef07ec35f1a:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">c93a31315089:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">3349ed800d44:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">6d01857ca4c1:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">4cc13890eda8:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">complete</span><br><span class="hljs-attr">Digest:</span> <span class="hljs-string">sha256:aeecae58035f3868bf4f00e5fc623630d8b438db9d05f4d8c6538deb14d4c31b</span> <span class="hljs-comment">#签名</span><br><span class="hljs-attr">Status:</span> <span class="hljs-string">Downloaded</span> <span class="hljs-string">newer</span> <span class="hljs-string">image</span> <span class="hljs-string">for</span> <span class="hljs-string">mysql:latest</span> <br><span class="hljs-string">docker.io/library/mysql:latest</span>  <span class="hljs-comment">#真实地址，docker pull mysql 等价于docker pull docker.io/library/mysql:latest</span><br></code></pre></td></tr></table></figure><h3 id="docker-rmi-删除镜像-rm代表删除，i代表image"><a href="#docker-rmi-删除镜像-rm代表删除，i代表image" class="headerlink" title="docker rmi 删除镜像 rm代表删除，i代表image"></a>docker rmi 删除镜像 rm代表删除，i代表image</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">-f, --<span class="hljs-literal">force</span>      <span class="hljs-literal">Force</span> removal of the image <span class="hljs-comment">#强制删除镜像</span><br></code></pre></td></tr></table></figure><p>例如：</p><p>删除指定镜像：docker rmi -f ID/image名，</p><p>删除全部镜像：docker rmi -f $(docker images -aq)</p><h2 id="容器命令（有镜像才可以创建容器）"><a href="#容器命令（有镜像才可以创建容器）" class="headerlink" title="容器命令（有镜像才可以创建容器）"></a>容器命令（有镜像才可以创建容器）</h2><h3 id="docker-run-启动容器"><a href="#docker-run-启动容器" class="headerlink" title="docker run 启动容器"></a>docker run 启动容器</h3><p>先在本机寻找镜像，找不到则去dockerHub上下载，还找不到就报错，找到了就下载到本地，并使用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">docker run <span class="hljs-selector-attr">[可选参数]</span> image<br><span class="hljs-attr">--name</span>=<span class="hljs-string">&quot;Name&quot;</span> 容器名字，用于区分容器<br>-d                        后台方式运行<br>-it                        使用交互方式运行，进入容器查看内容<br>-<span class="hljs-selector-tag">p</span>                        使用容器的端口，-<span class="hljs-selector-tag">p</span> <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span><br>        -<span class="hljs-selector-tag">p</span> ip:主机端口:容器端口<br>        -<span class="hljs-selector-tag">p</span> 主机端口:容器端口（常用）<br>        -<span class="hljs-selector-tag">p</span> 容器端口<br>            容器端口<br>-P（大写）    随机指定端口<br></code></pre></td></tr></table></figure><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl">启动并进入镜像，交互工具使用bash<br>[root@VM<span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos ~]# docker run -it centos /bin/bash  <br>[root@<span class="hljs-number">2</span>b902d8d2492 /]# ls  #镜像内部是一个并不太完整的centos系统，很多命令是没有的<br>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  <span class="hljs-keyword">proc</span><span class="hljs-title">  root</span> <span class="hljs-title"> run</span> <span class="hljs-title"> sbin</span> <span class="hljs-title"> srv</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span><br></code></pre></td></tr></table></figure><h3 id="exit-退出至主机"><a href="#exit-退出至主机" class="headerlink" title="exit 退出至主机"></a>exit 退出至主机</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span>    直接停止容器并退出<br>Ctrl + P + Q 容器不停止<br>[root@<span class="hljs-number">2</span>b902d8d2492 /]<span class="hljs-comment"># exit</span><br><span class="hljs-keyword">exit</span><br>[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># ls /</span><br>bin  boot  data  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br>[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h3 id="docker-ps-列出容器"><a href="#docker-ps-列出容器" class="headerlink" title="docker ps 列出容器"></a>docker ps 列出容器</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a    列出当前正在运行的容器和历史运行过的容器</span><br><span class="hljs-deletion">-n=?  列出最近创建的容器 ?为个数</span><br><span class="hljs-deletion">-q    只显示容器编号</span><br></code></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos ~]<span class="hljs-meta"># docker ps</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[root<span class="hljs-symbol">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos ~]<span class="hljs-meta"># docker ps -a</span><br>CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                     PORTS     NAMES<br><span class="hljs-number">2</span>b902d8d2492   centos         <span class="hljs-string">&quot;/bin/bash&quot;</span>   <span class="hljs-number">3</span> minutes ago   Exited (<span class="hljs-number">0</span>) <span class="hljs-number">2</span> minutes ago             vibrant_torvalds<br><span class="hljs-number">184</span>d14eb101f   feb5d9fea6a5   <span class="hljs-string">&quot;/hello&quot;</span>      <span class="hljs-number">8</span> days ago      Exited (<span class="hljs-number">0</span>) <span class="hljs-number">8</span> days ago                stoic_fermi<br>[root<span class="hljs-symbol">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos ~]<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><h3 id="docker-rm-删除容器"><a href="#docker-rm-删除容器" class="headerlink" title="docker rm 删除容器"></a>docker rm 删除容器</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> 容器名 删除指定容器，不能删除正在运行的<br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 强制删除容器<br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>( docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-aq</span> ) 强制删除所有容器，等同于docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span> | xargs <span class="hljs-built_in">rm</span> 使用管道删除<br></code></pre></td></tr></table></figure><h1 id="容器基本操作命令"><a href="#容器基本操作命令" class="headerlink" title="容器基本操作命令"></a>容器基本操作命令</h1><p>容器的启动、重启、停止和强制停止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start[ -i] <span class="hljs-built_in">id</span> <br>docker restart <span class="hljs-built_in">id</span><br>docker stop <span class="hljs-built_in">id</span><br>docker <span class="hljs-built_in">kill</span> <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autoit">当使用后台启动容器、且容器创建后没有对外的服务时（如nginx），创建后就会立刻停止容器。所以容器使用后台启动时，一定要有一个前台进程<br>[root<span class="hljs-symbol">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos ~]<span class="hljs-meta"># docker run -d centos</span><br><span class="hljs-number">41730</span>bcd96cf85f682b13b2346ef6701868981f68d4c4c2e0b4930c02e17a874<br>[root<span class="hljs-symbol">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos ~]<span class="hljs-meta"># docker ps</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[root<span class="hljs-symbol">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-7</span>-centos ~]<span class="hljs-meta"># docker ps -a</span><br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES<br><span class="hljs-number">41730</span>bcd96cf   centos    <span class="hljs-string">&quot;/bin/bash&quot;</span>   <span class="hljs-number">8</span> seconds ago   Exited (<span class="hljs-number">0</span>) <span class="hljs-number">7</span> seconds ago             eager_gauss<br><br>注意，这样是正常的。具体原因不详：docker <span class="hljs-built_in">run</span> -d --name nginx74 -p <span class="hljs-number">7474</span>:<span class="hljs-number">80</span> nginx<br></code></pre></td></tr></table></figure><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> logs -tf --tail <span class="hljs-number">10</span> 容器ID  查看最后<span class="hljs-number">10</span>条实时日志<br><span class="hljs-attribute">docker</span> logs -tf 容器ID  查看所有日志、实时<br></code></pre></td></tr></table></figure><h3 id="查看容器中的进程"><a href="#查看容器中的进程" class="headerlink" title="查看容器中的进程"></a>查看容器中的进程</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># docker top d3b2db3e0491</span><br>UID             PID             PPID           C         STIME               TTY             TIME        CMD<br>root            <span class="hljs-number">15252</span>           <span class="hljs-number">15234</span>          <span class="hljs-number">0</span>         <span class="hljs-number">21</span>:<span class="hljs-number">13</span>               ?               <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>    <span class="hljs-regexp">/bin/</span>sh -c <span class="hljs-keyword">while</span> true;<span class="hljs-keyword">do</span> echo yuanzhou;sleep <span class="hljs-number">2</span>;done<br>root            <span class="hljs-number">28124</span>           <span class="hljs-number">15252</span>          <span class="hljs-number">0</span>         <span class="hljs-number">21</span>:<span class="hljs-number">24</span>               ?               <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>    <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/coreutils --coreutils-prog-shebang=sleep /u</span>sr<span class="hljs-regexp">/bin/</span>sleep <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="查看镜像元数据"><a href="#查看镜像元数据" class="headerlink" title="查看镜像元数据"></a>查看镜像元数据</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker <span class="hljs-keyword">inspect</span> 容器ID<br>[<br>    &#123;<br>        <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-string">&quot;d3b2db3e0491e4caa4434343c2c8860db8442c6ac03295b46f7d679e1180066f&quot;</span>,<br>        <span class="hljs-string">&quot;Created&quot;</span>: <span class="hljs-string">&quot;2021-11-30T13:13:56.884601581Z&quot;</span>,<br>        <span class="hljs-string">&quot;Path&quot;</span>: <span class="hljs-string">&quot;/bin/sh&quot;</span>,<br>        <span class="hljs-string">&quot;Args&quot;</span>: [<br>            <span class="hljs-string">&quot;-c&quot;</span>,<br>            <span class="hljs-string">&quot;while true;do echo yuanzhou;sleep 2;done&quot;</span><br>        ],<br>        <span class="hljs-string">&quot;State&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Status&quot;</span>: <span class="hljs-string">&quot;running&quot;</span>,<br>………………<br></code></pre></td></tr></table></figure><h3 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> ID bashShell 开启一个新的终端，可以在里面操作（常用）<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]# docker exec -it d3b2db3e0491 <span class="hljs-regexp">/bin/</span>bash<br>[root@d3b2db3e0491 /]# ps -ef<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         <span class="hljs-number">1</span>     <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">13</span>:<span class="hljs-number">13</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-regexp">/bin/</span>sh -c <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span>;<span class="hljs-keyword">do</span> echo yuanzhou;sleep <span class="hljs-number">2</span>;done<br>root      <span class="hljs-number">1264</span>     <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span> pts<span class="hljs-regexp">/0    00:00:00 /</span>bin/bash<br>root      <span class="hljs-number">1279</span>     <span class="hljs-number">1</span>  <span class="hljs-number">0</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/coreutils --coreutils-prog-shebang=sleep /u</span>sr<span class="hljs-regexp">/bin/</span>sleep <span class="hljs-number">2</span><br>root      <span class="hljs-number">1280</span>  <span class="hljs-number">1264</span>  <span class="hljs-number">0</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ps -ef<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker attach ID 进入容器正在执行的终端，不启动新进程，不常用<br></code></pre></td></tr></table></figure><h3 id="从容器内拷贝文件到主机"><a href="#从容器内拷贝文件到主机" class="headerlink" title="从容器内拷贝文件到主机"></a>从容器内拷贝文件到主机</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># docker exec -it 17a7dca3d597 /bin/bash</span><br>[root@<span class="hljs-number">17</span>a7dca3d597 /]<span class="hljs-comment"># cd</span><br>[root@<span class="hljs-number">17</span>a7dca3d597 ~]<span class="hljs-comment"># ls</span><br>anaconda-ks.cfg  anaconda-post.log  original-ks.cfg  yuanhou.sh<br>[root@<span class="hljs-number">17</span>a7dca3d597 ~]<span class="hljs-comment"># exit</span><br><span class="hljs-keyword">exit</span><br>[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># docker cp 17a7dca3d597:/root/yuanhou.sh /root/   #与scp写法类似</span><br>[root@VM-<span class="hljs-number">0</span>-<span class="hljs-number">7</span>-centos ~]<span class="hljs-comment"># ll</span><br>总用量 <span class="hljs-number">1340</span><br>-rw-r--r-- <span class="hljs-number">1</span> root root <span class="hljs-number">1362341</span> <span class="hljs-number">11</span>月 <span class="hljs-number">29</span> <span class="hljs-number">22</span>:<span class="hljs-number">25</span> single_table.sql<br>drwxr-xr-x <span class="hljs-number">3</span> root root    <span class="hljs-number">4096</span> <span class="hljs-number">9</span>月  <span class="hljs-number">17</span> <span class="hljs-number">22</span>:<span class="hljs-number">43</span> test<br>-rw-r--r-- <span class="hljs-number">1</span> root root      <span class="hljs-number">16</span> <span class="hljs-number">11</span>月 <span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span> yuanhou.sh<br></code></pre></td></tr></table></figure><h3 id="查看docker的CPU状态"><a href="#查看docker的CPU状态" class="headerlink" title="查看docker的CPU状态"></a>查看docker的CPU状态</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker stats</span><br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195355.png"></p><p>使用docker安装nginx、tomcat</p><p>注：容器中的命令较少，且tomcat中的镜像是保证最小可运行的镜像，连webapps都需要从其他目录copy过来</p><p>安装elasticsearch:</p><p>docker run -d –name elasticsearch -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=”-Xms64m -xmx512m” -e “discovery.type=single-node” elasticsearch:7.6.2 /bin/bash</p><p>[root@VM-0-7-centos ~]# curl localhost:9200</p><p>{</p><p> “name” : “dda2ff33a70e”,</p><p> “cluster_name” : “docker-cluster”,</p><p> “cluster_uuid” : “ECsYrnfeTl-hxGllhDXSvg”,</p><p> “version” : {</p><p>  “number” : “7.6.2”,</p><p>  “build_flavor” : “default”,</p><p>  “build_type” : “docker”,</p><p>  “build_hash” : “ef48eb35cf30adf4db14086e8aabd07ef6fb113f”,</p><p>  “build_date” : “2020-03-26T06:34:37.794943Z”,</p><p>  “build_snapshot” : false,</p><p>  “lucene_version” : “8.4.0”,</p><p>  “minimum_wire_compatibility_version” : “6.8.0”,</p><p>  “minimum_index_compatibility_version” : “6.0.0-beta1”</p><p> },</p><p> “tagline” : “You Know, for Search”</p><p>}</p><p>[root@VM-0-7-centos ~]#</p><p>ES+kibna：数据可视化，涉及到两个容器的网络连接。</p><p>安装docker可视化面板portainer(一般不会用)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker run -d -p <span class="hljs-number">8088</span>:<span class="hljs-number">9000</span> --restart=always -v <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/docker.sock:/</span>var<span class="hljs-regexp">/run/</span>docker.sock --privileged=<span class="hljs-keyword">true</span> portainer/portainer<br></code></pre></td></tr></table></figure><p>注：针对容器启动后就停止有两种可能，一种是容器内部没有前台进程，如nginx这种，启动之后就会立刻退出。还有一种是ela这种需要超大内存的容器，启动之后直接把一核1G内存的云主机CPU挤爆了，这种就需要对其资源占用做限制，如添加 -e ES_JAVA_OPTS=”-Xms64m -xmx512m” 以限制jvm的资源</p><h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><p>联合文件系统：UFS是一种分层、轻量级、高性能文件系统，Union文件系统是镜像的基础，联合加载会把各层文件系统叠加起来，最终文件系统会包含所有底层文件和目录</p><h2 id="镜像加载原理"><a href="#镜像加载原理" class="headerlink" title="镜像加载原理"></a>镜像加载原理</h2><p>bootfs包含加载系统，镜像的最底层。与典型的linux是一样的，包含boot加载器和内核，当boot加载完成后，整个内核都在内存中，此时内存的使用权就由boofs转交给内核，系统也会卸载bootfs</p><p> rootfs：在bootfs之上，包含/dev、/proc、/etc等标准目录，就是不同操作系统发行版，如乌班图、centos等</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195421.png"></p><p>Docker进项都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层就是通常说的容器层，容器之下的都叫镜像层</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806195434.png"></p><h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">docker commit 提交容器称为一个新副本<br>-m 描述信息<br>-<span class="hljs-selector-tag">a</span> 作者 容器id 目标镜像名：<span class="hljs-selector-attr">[tag]</span> <br></code></pre></td></tr></table></figure><p>修改原有镜像后，通过docker commit -m xxx -a xxx打包成一个新的镜像。因此如果想要保存一个容器当前的状态，必须通过commit来提交，获得新的镜像。类似虚拟机中的快照</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL单表查询的成本</title>
    <link href="/2022/08/06/MySQL%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC/"/>
    <url>/2022/08/06/MySQL%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>存储引擎将数据存储在磁盘中，查询数据时会选择合适的执行计划将数据查询，执行计划的选择取决于SQL语句执行的成本。而当我们在讨论查询的成本时，一般有两部分：</p><ul><li>I/O成本：查询时需要将磁盘上的数据加载到内存中。这个过程损耗的时间即<strong>I/O成本</strong></li><li>CPU成本：读取记录、检测记录是否满足搜索条件、排序等操作的时间为<strong>CPU成本</strong></li></ul><p>在操作系统中，I/O和CPU因为效率的不同，计算成本的单位也不一样。MySQL规定读取一个页面花费的成本为1.0，读取记录等操作的成本是0.2。（加：优化器将读取一个扫描区间和执行一次回表的的I/O成本定为一样的，都是1.0）</p><p><strong>基于成本的优化步骤</strong></p><p>mysql查询前的步骤：</p><p>根据搜索条件<strong>找出所有可能使用的索引</strong>。对于B+树索引来说，只要索引列和常数使用连接符号（=、IN、&gt;、IS NULL、LIKE等）连接起来，就会产生扫描区间。一个查询中可能使用到的索引称之为possible keys。如下图查询SQL语句的执行计划中，possible_keys为NULL</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806194837.png"></p><p><strong>计算全表扫描的代价</strong>。执行SHOW TABLE STATUS LIKE ‘表名’;即可查询到当前表的统计信息，其中可以看到<strong>rows</strong>记录条数（估计值，偏高）和<strong>Data_length</strong>所占空间字节数。Data_length值可以大概计算出该表在表空间中<strong>所占用的页的数量</strong>，从而推导出I/O成本，而rows值可以算出CPU成本，相加即可得出全表扫描的总成本。（忽略了内节点成本，因为层级本就不高）</p><p><strong>计算使用不同索引执行查询的代价</strong>。MySQL优化器会先分析使用唯一二级索引的成本，再分析使用普通索引的成本。既然是二级索引，必然是要回表的。所以计算成本时，主要计算两种：</p><ul><li><ul><li><p>计算<strong>扫描区间的数量</strong></p><ul><li>不管某个扫描区间的二级索引占用了多少页面。优化器粗略的定义：读取一个扫描区间的I/O成本与一个页的I/O成本相同。</li></ul></li><li><p>计算<strong>需要回表的记录数量</strong></p></li><li><ul><li><p>即某个扫描区间的记录数量，也就是某个搜索条件在二级索引所包含的记录数。过程如下：</p><ul><li><p>找到条件符合的第一条记录，，为区间最左记录，此过程非常快，性能忽略不记</p></li><li><p>找到最后一条满足条件的记录，为区间最右记录，此过程非常快，性能忽略不记</p></li><li><p>最后算出具体的记录数量，也分两种情况：</p></li><li><ul><li>如果最左记录与最右记录距离相隔不远（5.7版本为&lt;=10个页面），就可以精确算出记录条数。距离通过数据页中的PAGE_N_RECS属性（记录当前页面用户记录数量）来算出，直接遍历即可。</li><li>如果最左与最右距离相隔较远，则需要顺着最左记录向右读10个页面，计算平均每页的记录，然后<strong>用平均值与最左最右记录之间的页面数量相乘</strong>。最左最右记录之间的页面数量，可以在他们的共同父节点（目录项记录页）中统计两条记录之间相隔几条记录。</li></ul></li></ul></li></ul></li><li><p>拿到扫描区间的二级记录数量时，需要根据这些记录的对应的主键去聚簇索引<strong>执行回表</strong>。那执行一次回表多大成本呢？这里规定是相当于一次访问页面。即1.0，因此二级索引扫描区间中有几条记录，就需要进行多少次I/O。</p></li><li><p>回表后得到完整的用户记录，再去<strong>匹配其他搜索条件是否成立</strong>。扫描每条记录所用的成本是CPU成本，上面已经说过了是2.0。</p></li><li><p>最后，将<strong>所有成本相加</strong>。即：I/O成本+CPU成本=（扫描区间的数量+预估的二级索引记录数量）+（读取二级索引记录的成本+读取并检测回表后聚簇索引记录的成本）=总成本。</p></li></ul></li></ul><p>对比执行方案，取成本最低者执行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL查询的本质——单表与多表的查询方法</title>
    <link href="/2022/08/06/MySQL%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E5%8D%95%E8%A1%A8%E4%B8%8E%E5%A4%9A%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95/"/>
    <url>/2022/08/06/MySQL%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E5%8D%95%E8%A1%A8%E4%B8%8E%E5%A4%9A%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>单表查询</strong></p><p>单表查询的语句实际上是一种声明式的语法，只是告诉MySQL要获取的数据符合哪些规则，至于具体的执行方式是MySQL自己来定。针对不同的场景，也有不同的执行计划， MySQL基于开销(cost)的优化器策略，哪种执行计划开销更低，就意味着性能更好，速度更快，就选择哪一种。以下是执行计划的类型：</p><p><strong>const</strong></p><p>通过<strong>主键</strong>或者<strong>唯一二级索引</strong>与常数的<strong>等值比较</strong>来定位一条记录，是最快的执行方式。主键定位直接返回，而唯一二级索引只需查询一次+回表一次即可返回</p><p><strong>ref</strong></p><p>较为常见的，在建立二级索引后直接使用其为等值查询条件。因为是等值的，索引会形成单点扫描区间。这种方法称为ref，规则是：搜索条件为<strong>二级索引列</strong>与<strong>常数</strong>进行<strong>等值比较</strong>，形成的扫描区间为<strong>单点扫描区间</strong>，采用二级索引来执行查询。这种方式的缺点就是每查到一次就回表一次，消耗大。</p><ul><li>且当二级索引列允许存储null时，都是用此ref方式访问。</li><li>ref允许最左匹配机制，即最左连续列匹配联合索引，就可以使用ref</li><li>当查询条件<strong>不为等值时不能用ref</strong></li></ul><p>（另外：在多表查询中，对被驱动表的主键或者不允许存储NULL值的唯一二级索引进行等值查找，使用的方法称为eq_ref）</p><p><strong>ref_or_null</strong></p><p>比ref多扫描了一些值为null的二级索引记录</p><p><strong>range</strong></p><p>使用索引执行查询时，对应的扫描区间为<strong>若干个单点扫描区间</strong>或者<strong>范围扫描区间</strong>。即包含多个单点扫描区间的查询条件，包含一个或全表扫描都不能称为range </p><p><strong>index</strong></p><p>直接<strong>扫描全部二级索引记录</strong>，且查询结果包含在索引列中，无需回表操作。即索引覆盖，因为二级索引比聚簇索引是要小很多的，就算全部扫描也不会消耗很多资源</p><p><strong>all</strong></p><p>全表扫描，适用于所有查询，但缺点就是慢</p><p>注意：</p><p>一般来说，具体使用哪种方法来执行，是MySQL中优化器的工作，它会访问表中少量数据获等方式，<strong>分析出多种执行计划中成本最小</strong>的来查询。</p><p>一般来说，使用二级索引查询时，当拿到匹配的二级记录后，就算还有其他匹配条件，也会先根据结果（主键）执行回表操作，再检测该记录是否满足其他条件，满足则发送给客户端，不满足则忽略。</p><p><strong>index_merge</strong> </p><p>索引合并。使用多个索引来完成一次查询，有以下三种方式：</p><ul><li><strong>Intersection索引合并</strong></li></ul><p>举个栗子：SELECT * FROM sing_table WHERE key1 = ‘a’ AND key3 = ‘b’;</p><p>一共有四种方式可以执行该查询：</p><ol><li><ol><li>首先，是全表就不谈了，慢。</li><li>其次，是使用key1的索引查询，则扫描区间为[‘a’,’a’]，查询到之后立刻回表，再匹配key3。</li><li>然后，是按照key3的索引查询，同样的则扫描区间为[‘b’,’b’]，查询到之后立刻回表，再匹配key1</li><li>最后，同时使用key1和key3的索引查询。在key1索引中扫描出匹配key1=a的记录，在key3索引中扫描出匹配key1=b的记录。由于在普通二级索引中，重复的索引值会按照主键来排序。所以在这个执行计划中，使用各自的索引扫描出来的记录也是主键排序的。又因为这里使用了 AND，需要查询两者条件都匹配的结果，所以<strong>找出两者查询的结果中主键相同的记录</strong>，再使用这些相同的主键<strong>一并执行回表</strong>，这样可能会省下很多回表带来的开销。这就是Intersection索引合并，它<strong>要求二级索引是排序的</strong>，也就是说我们的查询条件必须是等值的，只有等值才会排序。如果不使用等值条件，则不会使用Intersection索引合并（相当于各自使用ref，最后取重复集）</li></ol></li></ol><p>注意：如果条件中含有主键索引，则并不会扫描主键索引，而是和非主键索引一起形成等效的扫描区间。</p><ul><li><strong>Union索引合并</strong></li></ul><p>再举个栗子：SELECT * FROM sing_table WHERE key1 = ‘a’ OR key3 = ‘b’;</p><p>和之前的例子差不多，只是AND换成了OR，但完全不同了，你肯定不能单独使用其中一个索引来查，否则会先查询二级索引所有记录，再全部回表，灾难性的回表代表巨大消耗！所以要么你全表查询，要么你就是用Union索引合并：</p><p>在key1索引中扫描出匹配key1=a的记录，在key3索引中扫描出匹配key1=b的记录。因为这里用的是 OR ，只要匹配一个条件即可返回，所以只要<strong>根据两个结果集进行去重</strong>，把重复的ID去掉，接着就可以<strong>拿着剩下的ID区一并回表</strong>了，其实和Intersection索引是类似的，只不过它要的是重复的记录，这里要的是去掉重复的记录。同样，只有等值比较才可以使用这种Union索引合并。（相当于各自ref，然后去重）</p><ul><li><strong>Sort-Union索引合并</strong></li></ul><p>看这个名字其实就是比Union新增了一个Sort，那么它在什么地方加了排序呢？我们知道使用Union的条件是二级索引记录必须是按主键排序的，也就是说在SQL语句中，必须是等值的，类似上面的：key1 = ‘a’ OR key3 = ‘b’; 但如果是这种：key1 &lt; ‘a’ OR key3 &gt; ‘z’; 呢？使用Sort-Union排序可以先从key1索引中获得条件为“key1 &lt; ‘a’ ”的二级索引记录，并<strong>对其根据主键进行排序**；再从key3索引中获得条件为“key3 &gt; ‘z’ ”的二级索引记录，也对其根据主键进行排序。如此，又变成Union索引合并了。又可以减少很多回表操作。这种方法比普通的Union</strong>多了一层各自索引的主键值的排序**，也称Sort-Union索引合并。</p><p>注意：只有Sort-Union而没有Sort-Intersecion的原因作者也有解释，但具体没怎么看明白：如果加入Sort-Intersecion，就需要<strong>为大量的二级索引记录按照主键值进行排序</strong>，这个成本可能比使用单个二级索引执行查询的成本都要高，所以mysql没有引入。</p><p>在MySQL中执行计划使用EXPLAIN关键字查看，可以查看 SELECT,DELETE,INSERT,REPLACE,UPDATE语句的查询计划，查询出来的执行计划有两种查看方式（MySQL5.7+），：</p><ul><li>表格格式：EXPLAIN SQL</li><li>json格式：EXPLAIN FORMAT =JSON SQL</li></ul><p>例：表格：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806194506.png"></p><p> json:</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806194518.png"></p><p><strong>多表查询</strong></p><p>MySQL是关系型数据库，一个非常重要的概念就是Join 。表关联的实质其实就是把各个表的记录都取出来依此匹配，并把匹配后的组合发给客户端。如果不加条件限制，给到客户端的记录将是几个表的乘积，也称<strong>笛卡尔积</strong>，因为需要每个表的每一条记录都与另一个表的每条记录相互匹配。这个过程有点像大规模的回表操作，或者代码中的嵌套for循环。</p><p>因此，我们一般在连接查询时并不会全部匹配，而是会加上限制条件。这里的限制条件一般只有两种情况：</p><ul><li>单表限制条件。如：key=3或key&gt;1或key&lt;4。只针对key所在的表的限制条件</li><li>多表限制条件。如：t1.m1=t2.m1、t1.n1&lt; t2.n2。就针对了t1和t2两个表的限制条件。</li></ul><p>在这里有必要提一下基本连接查询过程：假设有表t1和t2，t1作为驱动表，t2作为被驱动表。首先在t1表中，按照对应的限制条件，使用成本最小的单表查询方法去查询。每次在t1查询到一条记录，都需要根据这条记录去t2表查询匹配的记录。即<strong>驱动表只需要查询一次，而被驱动表可能需要访问多次</strong>。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806194532.png"></p><p>这种方式有个缺点，如果驱动表的某条记录，没有在被驱动表中找到相应记录，那么就连驱动表的那条记录也不会查询出来，这样就导致查询出来的数据有缺失。为了解决该问题，引出了连接另一个概念：外连接。<strong>在外连接中，即时驱动表中的记录在被驱动表中没有匹配的记录，也仍然需要加入到结果集</strong>。</p><p>连接查询也需要有过滤条件，单表查询中使用WHERE，连接查询中的WHERE可能是不够用的。因此在连接查询中，存在着两种过滤条件：</p><ul><li><p>WHERE：<strong>不分内外连接</strong>，只要不匹配WHERE子句的条件，就不加入结果集。</p></li><li><p>ON：</p></li><li><ul><li>对于外连接的驱动表来说，如果在被驱动表中找不到匹配ON子句的过滤条件，<strong>驱动表的记录还是会加入结果集</strong>，被驱动表找不到记录没有关系，填NULL即可。</li><li>对于内连接的驱动表来说，ON等效于WHERE。</li></ul></li></ul><p>内连接的语法：</p><p>select * from t1,t2; 等效于 select * from t1 join t2; 等效于 select * from t1 inner join t2; 等效于 select * from t1 cross join t2; 。</p><p>推荐INNER JOIN的写法，语义明确</p><p>外连接的语法：</p><p>select * from t1 left join t2 on 连接条件 [where 普通过滤条件];</p><p>left join 中左侧的表称为外表或者驱动表，右侧的表称为内表或被驱动表。外连接必须使用on来指出连接条件。</p><p>right join也是一样的，只是左右驱动表位置换了，不再赘述</p><p><strong>连接查询的原理</strong></p><p><strong>嵌套循环连接</strong></p><p>最基本的简单的连接查询算算法。驱动表只访问一次，但被驱动表却可能访问多次，且访问的次数取决于对驱动表执行单表查询后的结果集中有多少条记录（驱动表匹配到记录后立即去被驱动表查）</p><p>多次如果每条驱动表的记录在被驱动表中都有很多，那么单表查询被驱动表的次数就会非常多，效率自然会不高。如果被驱动表的限制条件带有索引，那么有可能会使用ref、ref_or_null或者range等方式来查找，效率相对会快一些。所以在查询时，尽量避免select *，而是把真正使用到的列作为查询条件，这是在人为可控的情况下，优化查询。一般常用的列都会有索引，索引覆盖下查询效率会更高。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806194548.png"></p><p><strong>基于块的嵌套循环连接</strong></p><p>在表数据过于庞大的情况下，记录有可能是千万、亿级的规模，这种情况下的连接查询有可能会非常慢。基于块的嵌套循环连接是从减少被驱动表的访问次数入手，达到减少IO、提高效率的效果的。具体的做法就是在执行连接查询前申请一块固定大小的内存（也称Join Buffer），先将若干驱动表结果集里的记录装在这个内存中，然后开始扫描被驱动表，<strong>每条被驱动表的记录一次性地与Join Buffer中的多条驱动表记录进行匹配</strong>，由于匹配在内存中完成，无需IO，所以可以大大减少IO量。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806194603.png"></p><p>Join Buffer的大小通过启动项或系统变量进行配置，默认为256KB。一般在<strong>不能使用索引且自己机器的内存较大</strong>的情况下，可以尝试调大Join Buffer来进行连接查询的优化。需要注意的是Join Buffer并不会放所有驱动表的列，只存放查询列表中的列和过滤条件的列。因此我们查询时少用select * ，这样Join Buffer可以存放更多的记录。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大数据课程————Hadoop</title>
    <link href="/2022/08/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94Hadoop/"/>
    <url>/2022/08/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94Hadoop/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>hadoop搭建</strong>：</p><ol><li>环境搭建：利用分发脚本在所有服务器上部署java和hadoop</li><li>组件部署：三个重要组件分别部署在三台服务器上，并修改配置文件</li><li>启动集群并测试功能：格式化后分别启动组件并上传文件，配置历史服务器和日志功能</li></ol><p><strong>服务器相关概念</strong></p><p>类型：文件服务器、数据库服务器、WEB服务器</p><p>特点：高处理能力、高扩展性、高可靠性</p><p>服务器磁盘</p><p>机械硬盘：</p><p>SCSI接口硬盘，早期使用，已停售，1w转/min</p><p>SAS接口硬盘：提升，1.5w转/min</p><p>STAT硬盘：串口硬盘，主流硬盘带纠错、降噪功能，7200转/min</p><p>固态硬盘：</p><p>SSD硬盘：贵，性能高</p><p>交换机：</p><p>存储转发设备，交换式集线器，扩展端口功能、物理编址……</p><p>网卡：</p><p>以太网网卡，PCI总线接口服务器一般使用千兆网卡</p><p>机架：</p><p>存储服务器主机的机柜。通信使用交换机</p><p>IDC数据中心：</p><p>电信部门为企业做托管</p><p>Radi磁盘阵列：</p><p>独立磁盘冗余阵列，最新的Raid5，将校验的数据分布在所有磁盘上，基本满足大部分需求，主流用品</p><p><strong>Hadoop</strong></p><p>概念：分布式系统基础架构，主要解决海量数据的存储和分析计算，广义上指的是Hadoop生态圈</p><p><strong>三大发行版本</strong></p><p>Apache：基础版本（2006）</p><p>Cloudera：继承大数据框架，产品CDH（2008）</p><p>Hortonworks：文档较好，HDP（2011）</p><p><strong>优势</strong>：</p><p>高可靠性，底层多个数据副本，某计算单元故障不会丢失</p><p>高扩展性，集群间分配任务数据，动态扩展节点</p><p>高效性，Hadoop是并行工作，加快任务处理速度</p><p>搞容错性，自动将失败的任务重新分配</p><p><strong>Hadoop 1.x、2.x和3.x</strong></p><p>1.x：MapReduce（计算+资源调度）；HDFS（数据存储）；Common（辅助工具）</p><p>2.x：MapReduce（计算）；Yarn（资源调度）；HDFS（数据存储）；Common（辅助工具）</p><p>3.x：在组成上和2代没有区别，有其他区别</p><p><strong>HDFS架构</strong></p><p>NameNode（nn）：存储文件的元数据，如文件名、目录结构、文件属性，以及每个文件的块列表和块所在的DataNode</p><p>DataNode（dn）:在本地文件系统存储文件块数据，以及块数据的校验和</p><p>Secondary NameNode（2nn）：每隔一段时间对nn元数据备份</p><p><strong>YARN架构概述</strong></p><p>另一种资源协调者，是Hadoop的资源管理器</p><p>Resourceanager（RM）：整个集群资源（内存CPU等）的总管，存在多个客户端提交job让其运行</p><p>NodeManager（NM）：单个节点服务器的资源老大，一个节点可有多个Container</p><p>ApplicationMaster（AM）：单个任务运行的老大</p><p>Container：容器，相当于一台独立的服务器，封装了任务运行所需的内存CPU磁盘网络等</p><p><strong>MapReduce架构</strong></p><p>MapReduce将计算分为两个阶段：Map和Reduce，Map阶段是并行处理输入数据，Redce是对Map结果进行汇总</p><p><strong>HDFS、YARN、MapReduce三者关系</strong></p><p>HDFS是基础的架构，NameNode记录元数据，DataNode是存储单元，2nn负责备份数据。客户端向集群提交一个任务，YARN中的ResourceManager会寻找其中一个节点服务器的NodeManager，开启一个Container，将任务放在ApplicationMaster中运行，AM向RM申请运行资源，在节点中寻找到合适资源后开启资源，由AM开启MapTask，这就是Map阶段，每一个MapTask独立工作，检索后返回结果写入磁盘上，形成一个ReduceTask，NameNode再次进行记录操作</p><p><strong>大数据生态体系</strong></p><p>数据来源层：数据库（结构化）、文件日志（半结构化）、视频、PPT等（非结构化）</p><p>数据传输层：Sqoop数据传递、Flime日志收集、Kafka消息队列（也可整理结构化与非结构化）</p><p>数据存储层：HDFS文件存储（结构、非结构）、HBase（非结构）</p><p>资源管理层：YRAN资源管理</p><p>数据计算层：MapReduce（离线计算、Hive数据查询）、SparkCore（内存计算、SparkMlib数据挖掘、SparkSql数据查询、SparkStreaming、Flink实时计算）</p><p>任务调度：Oozie任务调度、Azkaban任务调度器</p><p>整个数据平台的调度者：Zookeeper</p><p>业务层：叶树模型、数据可视化、业务应用</p><p>案例：在电商购买推荐的商品：用户操作——Nginx埋点获取访问日志——产生数据存储至文件日志——Flume日志收集——Kafka进行缓冲——Flink云计算并返回结果至数据库——后台读取分析数据，并返回推荐页给用户</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193819.png"></p><p>前置工作：</p><p>VM虚拟机、linux初始化、XShell远程等</p><p>磁盘分区：/boot分1G，/swap分4G，/分45G，装好之后给虚拟机创建初始快照</p><p>设置固定IP网关DNS：</p><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p><p>将DHCP改成static</p><p>末尾添加</p><p>IPADDR=192.168.200.10x</p><p>GATWAT=192.169.200.2</p><p>NDS1=192.168.200.2</p><p>vi /etc/hosts 末尾添加：</p><p>192.168.200.100 hadoop100</p><p>192.168.200.101 hadoop101</p><p>192.168.200.102 hadoop102</p><p>192.168.200.103 hadoop103</p><p>192.168.200.104 hadoop104</p><p>192.168.200.105 hadoop105</p><p>————————————虚拟机快照由此结束————————————-</p><p>虚拟机基础工具：</p><p>yum install -y epel-release安装应用商店</p><p>yum install -y net-tools安装工具包</p><p>yum install -y vim 安装vim</p><p>添加部署java和hadoop</p><p>tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module解压java</p><p>tar -zxvf hadoop-3.1.3.tar.gz -C /opt/module/解压hadoop</p><p>前往/etc/profile.d新建my_env.sh脚本，脚本中加入java、hadoop环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/opt/module/jdk1.8.0_212<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br><span class="hljs-comment">#HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_HOME=/opt/module/hadoop-3.1.3<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_HOME</span>/bin<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_HOME</span>/sbin<br></code></pre></td></tr></table></figure><p>添加后source /etc/profile即可</p><p>hadoop文件分析</p><p>hadoop/bin目录中存储和HDFS、Yran、Mapred相关执行文件</p><p>hadoop/etc/hadoop目录中存储的xx-site.xml、workers相关</p><p>hadoop/sbin目录中一些集群功能开关相关脚本</p><p>hadoop/lib/native目录中存储的本地动态链接库，压缩功能会需要</p><p><strong>hadoop运行模式</strong></p><ul><li>Local (Standalone) Mode linux本地存储模式，一般测试用，企业不会用</li><li>Pseudo-Distributed Mode 伪分布式模式，数据存储在HDFS上</li><li>Fully-Distributed Mode 完全分布式模式，公司一般使用的</li></ul><p>scp拷贝文件至其他服务器，首次迁移使用</p><p>基本语法：</p><p>scp：命令，实现服务器与服务器之间的拷贝</p><p> -r ：递归</p><p>pdir/pdir/fname：源文件地址路径/名称</p><p>user@user@host:pdir/pdir/fname：目的地用户@主机：目的地路径/名称</p><p>例如：</p><p>scp -r ./jdk1.7/ root@hadoop103:/opt/module（将102本地推送至103），或</p><p>scp -r root@hadoop103:/opt/module/jdk1.7/ ./module（将远端102拉取至103）</p><p>rsync同步文件至其他服务器，速度较快，修改文件后使用</p><p>基本语法：</p><p>rsync：命令，实现服务器与服务器之间的文件同步</p><p> -av：归档拷贝并显示复制过程</p><p>例如：</p><p>rsync -av hadoop-3.1.3/ root@hadoop103:/opt/module/hadoop-3.1.3/ 将本地hadoop文件同步至103上</p><p>注意：需要双方同时安装了rsync才可以执行操作</p><p><strong>利用rsync实现同步分发</strong> 格式：xsync xxx，即可分发至所有指定服务器</p><p>注意：想要全局使用xsync必须满足以下条件：</p><ol><li><p>文件为可执行文件，即授权777</p></li><li><p>将xsync上层路径添加至全局环境变量中，即/etc/profile，但这个文件千万不能乱改，否则出了cd其他命令都会失效，补救方法如下：</p></li><li><ol><li>初始化path：export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin</li><li>使用vi重新修改PATH，将错误的地方改掉：/bin/vi /etc/profile ，并重新source /etc/profile</li></ol></li></ol><p>脚本代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#1. 判断参数个数</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -lt 1 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> Not Enough Arguement!<br>    <span class="hljs-built_in">exit</span>;<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">#2. 遍历集群所有机器</span><br><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> hadoop102 hadoop103 hadoop104<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> ====================  <span class="hljs-variable">$host</span>  ====================<br>    <span class="hljs-comment">#3. 遍历所有目录，挨个发送</span><br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$@</span><br>    <span class="hljs-keyword">do</span><br>        <span class="hljs-comment">#4. 判断文件是否存在</span><br>        <span class="hljs-keyword">if</span> [ -e <span class="hljs-variable">$file</span> ]<br>            <span class="hljs-keyword">then</span><br>                <span class="hljs-comment">#5. 获取父目录</span><br>                pdir=$(<span class="hljs-built_in">cd</span> -P $(<span class="hljs-built_in">dirname</span> <span class="hljs-variable">$file</span>); <span class="hljs-built_in">pwd</span>)<br>                <span class="hljs-comment">#6. 获取当前文件的名称</span><br>                fname=$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$file</span>)<br>                ssh <span class="hljs-variable">$host</span> <span class="hljs-string">&quot;mkdir -p <span class="hljs-variable">$pdir</span>&quot;</span><br>                rsync -av <span class="hljs-variable">$pdir</span>/<span class="hljs-variable">$fname</span> <span class="hljs-variable">$host</span>:<span class="hljs-variable">$pdir</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">echo</span> <span class="hljs-variable">$file</span> does not exists!<br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>该脚本缺陷：ssh时需要重复验证密码，不能一次到位，相当麻烦。因此需要使用ssh免登录</p><p><strong>ssh免密登录</strong></p><p>   普通情况下通过ssh其他服务器需要输入目标服务器密码，但也可以通过密钥来实现免密登录（注：未主动使用ssh命令的机器没有.ssh文件）</p><ol><li>在当前用户下的.ssh/下输入ssh-keygen -t rsa注册密钥，则在.ssh/下生成id_rsa私钥和id_rsa.pub公钥，还有一个存放目标节点的公钥集合文件known_hosts</li><li>输入ssh-copy-id xxxx将公钥拷贝至目标服务器，首次需要输入密码，以后即可无密访问。若想访问服务器本身，也许这样操作</li></ol><ul><li>被无密访问过的服务器会在.ssh/生成一个authorized_keys文件，存放允许访问它的服务器；而known_hosts存放着它能够无密访问的其他服务器</li><li>主动无密访问其他节点的服务器才会有密钥</li></ul><p>注意：防火墙关闭（centOS7）：</p><p>查看防火墙状态： systemctl status firewalld</p><p>永久关闭防火墙： systemctl disable firewalld</p><p>重启防火墙： systemctl enable firewalld</p><p>关闭防火墙开机自启： systemctl disable firewalld.service</p><p>集群部署规划</p><p>原则：NameNode、SecondaryNameNode和ResourceManager很耗内存，不要安装在同一个台机器上</p><table><thead><tr><th></th><th>hadoop102</th><th>hadoop103</th><th>hadoop104</th></tr></thead><tbody><tr><td>HDFS</td><td>NameNodeDataNode</td><td>DataNode</td><td>SecondaryNameNodeDataNode</td></tr><tr><td>YARN</td><td>NodeManager</td><td>ResourceManagerNodeManager</td><td>NodeManager</td></tr></tbody></table><p>默认配置文件：官网下载，存放在Hadoop的jar包中</p><p>自定义配置文件：$HADOOP_HOME/etc/hadoop位置下的core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml文件</p><p>根据自己需要，参照默认配置文件，将自定义配置文件修改</p><p>配置集群</p><ul><li>核心配置文件core-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定NameNode的地址 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://hadoop102:8020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定hadoop数据的存储目录 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/opt/module/hadoop-3.1.3/data<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置HDFS网页登录使用的静态用户为root --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>HDFS配置文件 hdfs-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- nn web端访问地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop102:9870<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2nn web端访问地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop104:9868<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>YARN配置文件yarn-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定MR走shuffle --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定ResourceManager的地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop103<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 环境变量的继承 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>MapReduce配置文件 mapred-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定MapReduce程序运行在Yarn上 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>$HADOOP_HOME/etc/hadoop/woekers中的localhost改成</li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">hadoop102<br>hadoop103<br>hadoop104<br></code></pre></td></tr></table></figure><ul><li>使用分发脚本xsync将当前改动分发至所有服务器</li></ul><p><strong>启动集群</strong></p><p>首次启动集群需要使用hdfs namenode -format进行格式化，注意格式化必须停止所有进程（stop-all.sh）并删除所有机器的data和logs目录，再进行格式化</p><ul><li>启动HDFS：sbin/start-dfs.sh</li></ul><p>此处教程是用子用户操作的，而我这边直接用在root下操作，所以有些地方需要修改</p><p>针对root用户的问题，在start-dfs.sh，stop-dfs.sh中分别添加</p><p>HDFS_DATANODE_USER=root</p><p>HDFS_DATANODE_SECURE_USER=hdfs</p><p>HDFS_NAMENODE_USER=root</p><p>HDFS_SECONDARYNAMENODE_USER=root</p><p>使用jps查看当前java相关的进程：</p><p>7281 Jps</p><p>6948 DataNode</p><p>6812 NameNode</p><p>浏览器输入<a href="http://hadoop102:9870/">hadoop102:9870</a> 查看HDFS上存储的数据信息</p><ul><li>在配置了ResourceManager的服务器中启动YARN：sbin/start-yarn.sh</li></ul><p>同样针对root用户，在start-yarn.sh和stop-yarn.sh中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">YARN_RESOURCEMANAGER_USER=root<br>HADOOP_SECURE_DN_USER=yarn<br>YARN_NODEMANAGER_USER=root<br></code></pre></td></tr></table></figure><p>用jps查看yarn节点中的进程</p><p>2609 DataNode</p><p>3089 NodeManager</p><p>3420 Jps</p><p>2958 ResourceManager</p><p>浏览器中输入<a href="http://hadoop102:9870/">hadoop103:</a>8088 查看YARN运行的job信息 </p><p><strong>集群基本测试</strong></p><ul><li>上传文件到集群</li></ul><p>​     hadoop fs -mkdir /input 在/目录下创建一个input文件夹</p><p>​     hadoop fs -put $HADOOP_HOME/wcinput/word.txt /input 将word.txt上传到/input下</p><ul><li>查看HDFS文件存储路径</li></ul><p>​     不太清楚是什么原因，教程中的文件在102、103和104中都各自存了一份，而我的文件却只有在104是完整的，103是不完整的，102就压根没有这个文件夹。在103和104中，在104确实是能够cat出来看到源文件的上传的文件分成多个文件块存储在一起，文本文件可直接cat查看，gz压缩包则需要使用cat输出重定向至当前文件夹，然后才可正常解压：cat xxx&gt;&gt; xxx.tar.gz</p><p>问题：web端尝试删除上传的文件时，出现“Permission denied: user=dr.who, access=READ_EXECUTE, inode=”/user”:root:supergroup:drwx-wx-wx”。这样的话直接在core-site.xml中添加以下配置即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 当前用户全设置成root --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 不开启权限检查 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.permissions.enabled<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>问题警告：</p><ol><li>存储位置会跳来跳去，不是固定是3等份！！！！但是删除后又好了，原因不明，新问题是元数据重新压缩后解压出现错误，原因不明</li><li>有出现过上传的文件只在102中有，103和104找不到的情况，还有web页面打不开（已解决，防火墙的问题，关闭后需要重启）。</li></ol><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806194109.png"></p><ul><li>运行hadoop自带的hadoop-mapreduce-examples.jar来测试，将文件上传后预览</li></ul><p>hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar wordcount /wcinput /wcoutput</p><p>注意：</p><p>此处的wordcount是类似结果的变量（但在HDFS内没看到这个名字）</p><p>这里填写的是输入输出地址，即/wcinput 和 /wcoutput。其中<strong>wcinput需要已存在于HDFS上，而wxoutput不能提前创建，否则会报错</strong>。这个逻辑很奇怪，后面再看看什么原因，并且由于我分配的内存过小，在计算时有杀掉一些其他进程，导致无法预览，这个现在也不看，评论区有加内存的博客地址，需要的话随时去看</p><p><strong>集群崩溃处理办法</strong></p><p>先停止yarn和hdfs，再将所有集群节点的$HADOOP_HOME下的/data和/logs文件夹删除，最后重新格式化HDFS即可</p><p>sbin/stop-yarn.sh</p><p>sbin/stop-dfs.sh</p><p>rm -rf data/ logs/</p><p>hdfs namenode -format</p><p>注意：DataNode版本号相关，没听懂，与数据版本相关</p><p><strong>配置历史服务器与日志聚集功能</strong></p><p>历史服务器配置成功后，在程序运行完成后的yarn前端页面可查看其历史运行情况</p><p>日志功能配置成功后，可在历史运行情况页面打开logs，方便分析运行情况</p><p>在mapred-site.xml中添加以下参数后，分发至各个节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 历史服务器端地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop102:10020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 历史服务器web端地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hadoop102:19888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在yarn-site.xml中添加以下参数后，分发至各个节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启日志聚集功能 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置日志聚集服务器地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log.server.url<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>http://hadoop102:19888/jobhistory/logs<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置日志保留时间为7天 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>604800<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>开启历史服务器和日志聚集功能之前，先将HDFS和YARN重启一遍，再在102中启动。启动后即可在jps中查看历史服务器进程，日志聚集不会产生进程，会从下次任务开始生成日志：</p><p>$HADOOP_HOME/bin/mapred –daemon start historyserver</p><p>HDFS/YARN的两种开关方式</p><ul><li>整体开关：start/stop-dfs.sd；start/stop-yarn.sh</li><li>单节点开关：hdfs –daemon start/stop namenode/datanode/secondarynamenode；yarn ==daemon start/stop resourcemanager/nodemanager</li></ul><p><strong>hadoop集群常用脚本</strong></p><ul><li>集群组件开关脚本：统一开关HDFS、YARN、historyserver、logs</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -lt 1 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No Args Input...&quot;</span><br>    <span class="hljs-built_in">exit</span> ;<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br><span class="hljs-string">&quot;start&quot;</span>)<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; =================== 启动 hadoop集群 ===================&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 启动 hdfs ---------------&quot;</span><br>        ssh hadoop102 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/sbin/start-dfs.sh&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 启动 yarn ---------------&quot;</span><br>        ssh hadoop103 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/sbin/start-yarn.sh&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 启动 historyserver ---------------&quot;</span><br>        ssh hadoop102 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon start historyserver&quot;</span><br>;;<br><span class="hljs-string">&quot;stop&quot;</span>)<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; =================== 关闭 hadoop集群 ===================&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 关闭 historyserver ---------------&quot;</span><br>        ssh hadoop102 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon stop historyserver&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 关闭 yarn ---------------&quot;</span><br>        ssh hadoop103 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/sbin/stop-yarn.sh&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; --------------- 关闭 hdfs ---------------&quot;</span><br>        ssh hadoop102 <span class="hljs-string">&quot;/opt/module/hadoop-3.1.3/sbin/stop-dfs.sh&quot;</span><br>;;<br>*)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Input Args Error...&quot;</span><br>;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><ul><li>统一查看集群服务器状态</li></ul><p>分发到各节点上之后，就可在任意一台节点查看各节点进程情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> hadoop102 hadoop103 hadoop104<br><span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">echo</span> =============== <span class="hljs-variable">$host</span> ===============<br>        ssh <span class="hljs-variable">$host</span> jps<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>hadoop常见端口号</strong></p><table><thead><tr><th>端口名称</th><th>Hadoop2.x</th><th>Hadoop3.x</th></tr></thead><tbody><tr><td>NameNode内部通信端口</td><td>8020 / 9000</td><td>8020 / 9000/9820</td></tr><tr><td>NameNode HTTP UI</td><td>50070</td><td>9870</td></tr><tr><td>MapReduce查看执行任务端口</td><td>8088</td><td>8088</td></tr><tr><td>历史服务器通信端口</td><td>19888</td><td>19888</td></tr></tbody></table><p><strong>常用配置文件</strong></p><p>hadoop3.x：core-site.xml hdfs-site.xml yarn-site.xml mapred-site.xml workers</p><p>hadoop2.x：core-site.xml hdfs-site.xml yarn-site.xml mapred-site.xml slaves</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大数据课程————HDFS</title>
    <link href="/2022/08/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94HDFS/"/>
    <url>/2022/08/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94HDFS/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>HDFS基本概念</strong></p><p>是一个文件系统，用于存储文件，通过目录树来定位文件；是分布式的，由多个服务器联合起来实现其功。</p><p>适合场景：一次写入，多次读出，不可更改。文件写入后就不需要再改变</p><p><strong>HDFS特征</strong></p><p>优点</p><ul><li>高容错，文件报错多个副本</li><li>适合处理大数据，数据规模到GB、TB甚至TP；文件数量多到百万级以上均可处理</li><li>可建构廉价机器上</li></ul><p>缺点</p><ul><li>不适合低延迟数据访问，实时场景不合适</li><li>无法高效对大量小文件进行存储（占用大量NN内存来存储目录和块信息，且小文件的寻址时间超过读取时间，违反了HDFS的设计目标）</li><li>不支持并发写入、文件随机修改，不允许多线程写入</li><li>仅支持数据追加，不允许文件修改 </li></ul><p><strong>组成架构</strong></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193437.png"></p><ul><li><p>NameNode：即NN，Master，是整个HDFS的管理者，</p></li><li><ul><li>管理HDFS的NmaeSpeace</li><li>配置副本策略</li><li>管理Block的映射信息</li><li>处理客户端读写请求</li></ul></li><li><p>DataNode：即DN，Slave，NN下达的命令由DN执行实际的操作</p></li><li><ul><li>存储实际的数据块</li><li>执行数据块的读写操作</li></ul></li><li><p>Secondary NameNode：NN的冷备份，当NN挂掉后并不会立刻替换NN</p></li><li><ul><li>辅助NN，定期合并Fsimage和Edits，并推送给NN</li><li>紧急情况下可辅助恢复NN</li></ul></li><li><p>Client：客户端</p></li><li><ul><li>文件切分。</li><li>与NameNode交互，读取文件位置信息</li><li>与DataNode交互，读取或写入数据</li><li>提供命令管理HDFS，如HDFS格式化</li><li>通过命令访问HDFS，如HDFS增删改查</li></ul></li></ul><p><strong>HDFS的块大小</strong></p><p>HDFS是分块存储，块大小通过配置参数dfs.blocksize来规定，默认大小在Hadoop2/3版本是128M，1.x版本是64M。</p><p>HDFS是块大小主要取决于磁盘传输的速率，普通机械硬盘一般80<del>90MB/s，固态200</del>300MB/s</p><ul><li>HDFS块设置太小，会增加寻址时间</li><li>HDFS块设置太大，传输时间会明显大于寻址时间，导致程序处理这块数据会非常慢</li></ul><p>准则：寻址时间为传输时间的1%为最佳状态。</p><p><strong>HDFS的Shell操作</strong></p><ul><li><p>上传</p></li><li><ul><li>-moveFromLocal：从本地剪切粘贴到HDFS</li><li>-copyFromLocal 或 -put：从本地文件系统中拷贝文件到HDFS路径去</li><li>-appendToFile：追加一个文件到已经存在的文件末尾</li></ul></li><li><p>下载、直接操作</p></li><li><ul><li>-copyToLocal 或 -get ：从HDFS 拷贝到本地</li><li>-ls: 显示目录信息</li><li>-cat：显示文件内容</li><li>-chgrp、-chmod、-chown：Linux文件系统中的用法一样，修改文件所属权限</li><li>-mkdir：创建路径</li><li>-cp：从HDFS的一个路径拷贝到HDFS的另一个路径</li><li>-mv：在HDFS目录中移动文件</li><li>-tail：显示一个文件的末尾1kb的数据</li><li>-rm：删除文件或文件夹</li><li>-rm -r：递归删除目录及目录里面内容</li><li>-du -h -s ：统计文件夹的大小信息</li><li>-setrep：设置HDFS中文件的副本数量，最大副本数取决于节点数</li></ul></li></ul><p><strong>HDFS的API操作</strong></p><p>   环境搭建：</p><ul><li>资料包中打开windows依赖，将文件夹拷贝到本地文件，并对其添加环境变量（windows上不需要安装hadoop服务器，只需安装此文件中的winutils即可）</li><li>创建maven项目，添加hadoop等相关依赖</li><li>添加日志打印等级，创建包、类，干代码</li><li>注意：IDEA的jar包依赖问题困扰了很久才解决。猜测是可能本地仓库的问题，下次如果还会出现的话，把仓库删了重新换回原始的.m2试试。还有环境变量一定要注意，如果有参数不对可以优先打桩出来看看是否正确</li></ul><p>都是代码实现，在IDEA中</p><p>HDFS的读写数据流程：面试重点</p><p> <img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193523.png"></p><p><strong>HDFS读数据流程</strong></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193552.png"></p><p>节点距离计算</p><p>在HDFS写数据的过程中，NN会选择距离上离带上传数据最近的DN接收数据。</p><p>节点距离：两个节点到达最近共同祖先的距离总和。</p><p>解释：将网络分层，数出节点到达共同祖先的另一节点即可</p><p>副本存储节点选择——机架感知</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193610.png"></p><p><strong>NameNode和DataNode的工作机制</strong></p><p>注意的点：</p><p>secondary NameNode向NameNode checkpoint时的条件：</p><ol><li><p>定时时间到</p></li><li><ul><li>hdfs-default.xml中有所描述，即 dfs.namenode.checkpoint.period字段，默认设置为3600s。即每个小时2NN会向NN请求checkpoint</li></ul></li><li><p>Edits中的数据满了</p></li><li><ul><li>hdfs-default.xml中有所描述，即 dfs.namenode.checkpoint.txns字段，当操作次数到达100w次时，2NN执行checkpoint，检查次数的时间由 dfs.namenode.checkpoint.check.period设置，默认为60s即每分钟检查一次操作次数</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193625.png"></p><p><strong>Fsimage和Edits解析</strong></p><p>NameNode被格式化之后，将会在$HADOOP_HOME/data/tmp/dfs/name/cirrent目录下产生如下文件</p><p><img src="https://img2020.cnblogs.com/blog/1560490/202110/1560490-20211008075447431-470533680.png" alt="img"></p><p>Fsimage：HDFS文件系统元数据的一个永久性的检查点，包含HDFS文件系统的所有目录和文件inode的序列化信息</p><p>Edits：存放HDFS文件系统的所有更新操作，客户端执行的写操作会首先被记录到Edits文件中（追加操作）</p><p>seen_txid：保存的是一个数字，最后一个edits_的数字</p><ul><li>oiv查看Fsimage文件</li></ul><p>语法：hdfs oiv -p 文件类型 -i镜像文件 -o 转换后文件输出路径</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">例子：<br>hadoop103:<span class="hljs-number">8088</span>hdfs oiv -p XML -i fsimage_0000000000000000025 -o <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>fsimage.xml<br>cat <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>fsimage.xml<br></code></pre></td></tr></table></figure><p>fsimage.xml文件中，记录了HDFS中的文件树，并使用inode来作为元数据中的目录管理节点，与文件一一对应。</p><ul><li>oev查看Edits</li></ul><p>语法：hdfs oev -p 文件类型 -i编辑日志 -o 转换后文件输出路径</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">例子：<br>hdfs oev -p XML -i edits_inprogress_0000000000000000289 -o <span class="hljs-regexp">/opt/</span>software/edits.xml<br>cat <span class="hljs-regexp">/opt/m</span>odule<span class="hljs-regexp">/hadoop-3.1.3/</span>edits.xml<br></code></pre></td></tr></table></figure><p>edits.xml中记录了写入追加的操作。</p><p>NN和2NN最大的区别就是2NN没有edits_inprogress这个记录最新操作的文件，因此如果发生数据丢失，最有可能丢失的是最近一次操作，而往期操作被存放在2NN中</p><p><strong>DataNode 的工作机制</strong></p><p>服务及开机之后，DN会主动向NN发送当前节点的所有块信息（活动的块，非死亡块）（注册）</p><p>块信息——数据、数据长度、校验和、时间戳</p><p>在开机之后：</p><ul><li>DN会自己自我检查块信息（每6小时，字段：dfs.datanode.directoryscan.interval）查询之后立即向NN汇报（每6小时，字段dfs.blockreport.intervalMsec）所有块信息</li><li>DN会每3秒发起心跳信号，告诉NN它还存活。若超过10分钟+30秒（timeOut=2<em>dfs.namenode.heartbeat.recheck-interval + 10</em>dfs.heartbeat.interval）NN仍未收到DN的的心跳信号，NN则认为该DN不可用，即不再使用该节点读写数据</li></ul><p><strong>HDFS数据完整性校验</strong></p><p>原始数据封装后在末尾添加CRC校验位，HDFS接收数据后重新CRC计算与传输过来的校验位比较看是否一致</p><p>待续</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大数据课程————MapReduce</title>
    <link href="/2022/08/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94MapReduce/"/>
    <url>/2022/08/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94MapReduce/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>MapReduce</p><p>一个分布式运算程序的编程框架，用户开发“基于Hadoop的数据分析应用”的核心框架。</p><p>优点：</p><ul><li>易于编程，用户只关心业务逻辑，实现框架的接口</li><li>良好的扩展性。可动态增加服务器，解决计算资源不够的问题</li><li>高容错性。任意节点挂掉可以将任务转移至其他节点</li><li>适合海量数据计算。（TB/PB级别）几千台服务器共同计算</li></ul><p>缺点：</p><ul><li>不擅长实时计算。（mysql毫秒级别的）</li><li>不擅长流式计算</li><li>不擅长DAG有向无环图计算</li></ul><p>MapReduce工作流程</p><ol><li>运算程序一般分为2个阶段：Map阶段和Reduce阶段</li><li>Map阶段并发MapTask并行运行，互不干扰；Reduce阶段的并发Reduce Task ，但他们的数据依赖于上一个MapTask并发实例的输出</li><li>MapReduce编程模型只能包含一个Map和一个Reduce阶段，若业务繁杂，只能使用多个MapReduce程序串行运行</li></ol><p>MapReduce进程</p><ul><li>MrAppmaster：整个程序的过程调度及协调</li><li>MapTask：负责Map阶段的整个数据流处理</li><li>ReduceTask：负责Reduce阶段的数据处理</li></ul><p>编程规范</p><ul><li>Mapper阶段：继承Mapper类，输入输出均为kv形式，业务逻辑写在map()中，MapTask进程对每个kv仅调用一次</li><li>Reduce阶段：继承Reduce类，输入为Mapper的输出数据类型，业务写在reduce()中，ReduceTask进程对每组k相同的kv调用一次reduce()</li><li>Driver阶段：相当于Yarn的客户端，提交封装了MapReduce程序相关运行参数的Job对象到Yarn集群</li></ul><p>本地Hadoop测试WordCount计算成功后，应将其提交到集群，交由集群计算。</p><ul><li>Driver类中输入输出参数填args[]数组的参数</li><li>根据实际情况添加依赖，打包后放入集群运行时，应填写全列名，如“com/yz/mapreduce/wordcount2/WordCountDriver”再添加其他参数即可运行</li></ul><p>Hadoop序列化：java自带序列化的简化版</p><ul><li>紧凑 ：高效使用存储空间。</li><li>快速：读写数据的额外开销小。</li><li>互操作：支持多语言的交互</li></ul><p>MapReduce的切片机制与MapTask并行度决定机制</p><p>数据块：HDFS上将数据分为多个块</p><p>数据切片：在逻辑上对输入进行分片，并不会在磁盘上对其切分成片存储，数据切片是MapReduce程序计算输入数据的单位，一个切片对应启动一个MapReduce</p><ul><li>一个Job的Map阶段并行度由客户端在 提交Job时的切片数决定</li><li>默认情况下，切片大小=BlockSize</li><li>每个Slipt切片分配一个MapTask并行实例处理</li><li>切片时不考虑数据整体，而是逐个对单个文件单独切片</li></ul><p>FileInputFormat切片分析：</p><ol><li><p>程序找到数据存储的目录</p></li><li><p>遍历切片下的每个文件，切片时不考虑数据集整体，对每个文件单独切片</p></li><li><p>遍历第一个文件：</p></li><li><ol><li>获取文件大小</li><li>根据切片公式计算切片大小，默认切片大小=blocksize</li><li>第一个切片0:128M，第二个128:256，第三个356:300M，每次切片都要判断切完剩下的部分是否大于块的1.1倍，不大于就划成一块切片（源码中有写）</li><li>将切片信息写入切片规划文件中</li></ol></li><li><p>整个切片的核心过程都在getSplit( )中完成，InputSplit只记录了切片元数据</p></li><li><p>提交切片规划文件到YARN上，YARN的MrAppMaster根据切片规划文件计算开启MapTask的个数</p></li></ol><p>获取切片信息API</p><ul><li>获取切片名称：inputSplit.getPath().getName()</li><li>根据文件类型获取切片信息：（FileSplit）context.getInputSplit()</li></ul><p>MapReduce框架</p><ul><li>基本流程：</li></ul><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193038.png"></p><p><strong>TextInputFormat：系统默认的切片机制</strong></p><p>TextInputFormat是默认的FileInputFormat实现类。按行读取每条记录。键是存储该行在整个文件中的起始字节偏移量， LongWritable类型。值是这行的内容，不包括任何行终止符（换行符和回车符），Text类型。</p><p><strong>CombineTextInputFormat切片机制</strong></p><p>解决TextInputFormat对单个文件切片的缺陷，如果小文件过多将会产生大量MapTask，效率低下，CombineTextInputFormat将多个小文件从逻辑上划分给同一个MapTask，提高效率</p><p>虚拟存储切片最大值设置：CombineTextInputFormat.setMaxInputSplitSize(job, 4194304);// 4m</p><p><strong>MapTask工作机制</strong></p><ol><li>读取数据组件Inputformat(接口，实际是TextinputFormat)通过getSplits方法对输入目录中的文件进行逻辑切片，得到block，有多少个block就有多少个MapTask</li><li>输入文件切块之后，由RecordReader对象（实际是LineRecordReader）进行行读取，读一行返回一个ky，key为首字母偏移量，value为这行的文本内容</li><li>读取block后返回ky,进入用户自己继承的Mapper类，重写map函数，写业务代码</li><li>mapper结束后，通过conetxt.write收集结果，，在context中对其进行分区处理</li><li>然后会将数据写入内存，内存中这片区域叫环形缓冲区，作用是批量收集Mapper结果，减少磁盘IO的影响，ky对以及Partition的结果都会被写入缓冲区，写入之前ky都会被序列化成字节数组。缓冲区其实就是一个存放ky的数组，环形结构值一个抽象概念。缓冲区有100M大小，当当Mapper输出结果较多，则需要另起一个线程将数据写入磁盘，这个行为叫Spill溢写。溢写的阈值是80%，即当数组快到80%时，就开始溢写，同时还会接收Mapper数据，并且当二者速度相差过大时，内存还会等待溢写，直到可以继续收集。溢写之前对key的索引按照字典顺序进行快排，快排之后进行combiner规约，生成小文件。hadoop的mapred-site.xml中定义了缓冲区的相关设置。缓冲区大小通过mapreduce.task.io.sort.mb设置，阈值通过mapreduce.map.sort.split.percent设置</li><li>溢写程序启动后，对80M内容的Key做排序，排序是MapReduce模型默认的行为，是对序列化的字节做的排序</li><li>合并溢写文件，每次溢写都会在磁盘生成一个临时文件，多Mapper输出结果大，则会有多次溢写，有多个临时文件，整个数据处理结束后，开始对磁盘中的临时文件做Merge合并成一个文件，并写入磁盘，并为这个we你按提供一个索引文件，记录每个reduce对应数据的偏移</li></ol><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193053.png"></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193115.png"></p><p><strong>MapReduce工作流程</strong></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193129.png"></p><p> <img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193155.png"></p><p><strong>MapReduce_Shuffle机制</strong></p><p>Map方法之后就开始Reduce阶段，Reduce第一个阶段是Reduce_Shuffle，一般当做Reduce业务层前置阶段。第二阶段即真正的ReduceTask，用来对数据进行操</p><p>Shuffle大致分为四个步骤：</p><ol><li>分区：环型缓冲期前的逻辑分区</li><li>排序：：缓冲期写入磁盘前的快速排序</li><li>combiner规约：溢写前、合并小文件等都会用到的操作，可选</li><li>分组：小文件合并成一个大文件后，对其进行归并排序、分组</li></ol><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193205.png"></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806193218.png"></p><p><strong>Partition分区</strong></p><p>系统默认的分区逻辑如下，默认分区是根据key的hashCode对ReduceTask个数取模得到，用户无法控制key存储到哪个分区：</p><p>public class HashPartitioner&lt;K2, V2&gt; implements Partitioner&lt;K2, V2&gt; {</p><p>……</p><p>  public int getPartition(K2 key, V2 value, int numReduceTasks) {</p><p>​    return (key.hashCode() &amp; 2147483647) % numReduceTasks;</p><p>  }</p><p>}</p><p>想要控制存储分区，可继承下面的Partitioner抽象类，并重写getPartitioner()方法：</p><p>public abstract class Partitioner&lt;KEY, VALUE&gt; {</p><p>  public abstract int getPartition(KEY var1, VALUE var2, int var3);</p><p>}</p><p>若自定义了分区，必须在job驱动中设置自定义Partitioner，否则还是会走默认，并根据Partitioner的逻辑设置相应数量的ReduceTask</p><p>分区总结：</p><ul><li>若ReduceTask数量&gt;getPartitioner结果数量，则会产生空的part-r-000xx文件。造成资源浪费</li><li>若1&lt;ReduceTask数量&lt;getPartitioner结果数量，则一部分分区数据无法存放，报IO异常</li><li>若ReduceTask数量=1，则为默认情况，所有分区文件都交给一个ReduceTask，结果生成一个part文件</li><li>分区号必须从0开始，逐一累加</li></ul><p><strong>WritableComparable排序</strong></p><p>排序是MapReduce中最重要的操作之一，MapTask和ReduceTask均会对数据排序，这是Hadoop行为，不论逻辑是否需要均会排序。</p><p>MapTask中，处理的结果暂时放在环形缓冲区，到达阈值后，对80%的数据进行一次快排，并将排序后的数据溢写到磁盘，全部处理完毕后对多有文件进行归并排序</p><p>ReduceTask中，从每个MapTask上远程拷贝相应的数据文件，若文件大于阈值则溢写到磁盘，否则存在内存中。</p><ul><li>若内存中文件大小或数量到达阈值，则合并后将数据溢写在磁盘。</li><li>若磁盘中文件数量达到阈值则做一次归排生成一个大文件</li><li>所有数据拷贝完后，ReduceTask统一对内存和磁盘上所有数据进行一次归并排序</li></ul><p>排序分类：</p><p>部分排序：MapReduce根据记录的键对数据集排序，保证输出的每个文件内部有序</p><p>全排序：最终输出结果只有一个文件，文件内部有序，一般不会使用这种方式，因为数据量太大，用一个ReduceTask处理效率太低</p><p>辅助排序：FroupingComparator分组，少用</p><p>二次排序（自定义排序）：若compareTo中的判断条件为2个即为二次排序</p><p><strong>Combiner合并</strong></p><p>combiner是可选的步骤，是Mapper和Reduce之外的组件，Combiner的父类就是Reduce。Combiner的意义就是对每个MapTask的输出进行局部汇总，以减少网络传输量。</p><p>选择Combiner的限制条件是，使用后不能影响最终的业务逻辑，例如比较适合叠加操作，而不适合求平均值操作</p><p>outPutFormatgaishu概述</p><p>后续：</p><p><a href="https://www.bilibili.com/video/BV1Qp4y1n7EN">https://www.bilibili.com/video/BV1Qp4y1n7EN</a></p><p>P105</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA运行测试错误Failed to resolve org.junit.platform:junit-platform-launcher</title>
    <link href="/2022/08/06/IDEA%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E9%94%99%E8%AF%AFFailed-to-resolve-org-junit-platform-junit-platform-launcher/"/>
    <url>/2022/08/06/IDEA%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E9%94%99%E8%AF%AFFailed-to-resolve-org-junit-platform-junit-platform-launcher/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>问题原因：<br>这里的问题是IntelliJ试图在不使用IDE中配置的Maven“用户设置文件”(settings.xml)的情况下解决所需的工件本身。它将直接连接到Maven Central，但被我的雇主屏蔽了</p><p>解决方案在pom文件添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- this is needed or IntelliJ gives junit.jar or junit-platform-launcher:1.3.2 not found errors --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.platform<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-platform-launcher<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySql索引基本原理</title>
    <link href="/2022/08/06/MySql%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/06/MySql%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>前置概念：</p><ul><li><p>磁盘预读：内存跟磁盘在发生数据交互的时候，一般情况下有一个最小的逻辑单元，即”页”/“datapage”，页一般由操作系统决定是多大，一般是4k或8k。而进行数据交互的时候，可以取页的整数倍来读取。如innodb引擎每次读取数据都是16k</p></li><li><p>B+树</p></li><li><ul><li>每个关键字对应一棵子树</li><li>每个结点关键字个数n的范围是[m/2]&lt;=n&lt;=m</li><li>叶节点是包含信息的，其他所有非叶节点仅起到索引作用，包含了对应子树的最大关键字和指向该子树的指针</li></ul></li><li><p>mysql底层构造</p></li><li><ul><li><p>client层——&gt;server层——&gt;存储引擎</p></li><li><ul><li>client向server层发送SQL语句，server层通过连接器接收</li><li>server层的分析器对SQL语句进行语法分析，转变为AST抽象语法树</li><li>server层使用优化器对语句中具体查询的数据</li><li>执行器与存储引擎进行IO交互，获取查询结果</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806192503.png"></p><p>从头遍历</p><p>没有索引的查找方法：从第一页记录开始查，遍历所有数据页，相当耗费资源和时间。</p><p>简单的索引方案——一层目录</p><ol><li>假设一个数据页的数据已经存储满了，这时再添加一条记录。如果该记录的主键比现有记录最大的主键小：首先必然会产生页的分裂，其次，现有的最大主键用户记录会移到新的数据页，而新插入的用户记录则插入到原来已满的数据页。页的分裂始终保持——下一个数据页中用户主键值必须大于上一页的用户记录主键值。</li><li>再假设上述页分裂操作多次执行，导致数据页数量非常多。此时应该给这些数据页按照主键大小整合目录页。目录页只包含1.数据页上最小的用户主键值。2.数据页的页号。如此，只要将目录页放在连续的内存中，即可快速通过主键查找到用户记录</li></ol><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806192532.png"></p><p>InnoDB的索引——B+树</p><p>前置信息：由于面向的是真实的数据库用户，因此数据量有时会非常大。一个page只有16KB,别说用户记录了，就连目录项都有可能装不完。并且，如果数据页做了增删操作，那么所有目录项也需要做调整，这样非常浪费空间和资源。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806192546.png"></p><ol><li>因此，MySQL将数据页和目录页做一个复用，由于目录项和用户记录比较相似，因此让他们使用同一个页模版——0x45BF，即FIL_PAGE_INDEX。只使用一条属性record_type将二者区分。除此之外，页的结构、记录分组(槽)等等都是一样的（另外，page Header中信息自然时不一样的）。</li><li>如果数据量实在太多，一张16KB全部装着目录项的page也不够用，则产生页分裂，使用多个目录页来装；数据量巨大，连目录页都太多了，查找起来很慢，则会产生更高层次的目录，将目录页存储起来！这种结构，就称之为B+树。最顶端的节点是根节点，中间的节点为非叶子节点，而最底端的节点为叶子节点。所有的用户记录均被存储在叶子节点中。</li></ol><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806192601.png"></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806192618.png"></p><p>像这种层级往上叠的结构，每增加一个层级，所能容纳的数据成几何倍数增长，一个数据页已经可以存放很多条用户记录了，一层数据页则可以更多，一层目录页更是数量爆炸！</p><p>一般情况下，我们用到B+树的层级不会超过4层，这样只需查找3个目录页+1个数据页+页内二分查找，即可快速定位记录。不要小看这4层的B+树，4层B+ 树已经可以存放千万级数据了，如果还想放再多数据，只能扩容或者加表</p><p>聚簇索引，具有以下两个特点的B+树称为聚簇索引：</p><ol><li><p>使用记录主键的大小进行记录和页的排序</p></li><li><ul><li>页内记录按住键大小排序形成单向链表结构，页内划成分组，每组最大记录的偏移量记录在槽中，放在页目录中。</li><li>数据页按页中用户记录的主键大小排序成双向链表（用于对主键的范围查找和分页查找）</li><li>目录页（存放目录项的数据页）分为不同层级，同层目录页根据页中住键大小顺序排列形成双向链表</li></ul></li><li><p>叶子节点存储的是完整的用户记录，即不是二级索引，而是记录中存储了所有列的值（包括隐藏列）</p></li></ol><p>只要我们的记录拥有以下特点，那么我们就不需要手动显式地使用INDEX创建索引，MYSQL会自动创建聚簇索引，在InnoDB中，聚簇索引就是数据的存储方式，即：索引即数据，数据即索引。</p><p>而从存储方面来说，索引和数据本身是存储在磁盘的，查询数据时会优先将索引加载在内存。索引存储的信息就是存放目录项的数据页。在一个磁盘块中，指针大小是固定的，因此当选择某字段当索引时，应该尽量减小键值所占用的空间，这样可以指数级地增加用于存放数据的空间</p><p>Mysql中的索引使用的是B+树，而为什么不使用其他数据结构做呢？</p><ul><li><p>hash：哈希冲突；范围查询时需逐个遍历；对于内存空间要求高。mysql中也存在hash，即memory引擎使用的是hash索引，innodb支持自适应hash，即系统根据数据类型判断使用哪种存储结构</p></li><li><p>树</p></li><li><ul><li><p>二叉树：无序</p></li><li><p>BST：二叉查找树：插入时有序，左子树小于子树根节点，右子树大于子树根节点</p></li><li><ul><li>插入连续值时，可能退化成链表，时间复杂度提高</li></ul></li><li><p>AVL：平衡二叉查找树：有序，为了解决连续值退化的问题，通过左旋或右旋让树平衡，保持最短子树和最长子树高度不能超过1</p></li><li><ul><li>通过插入性能的损失来弥补查询性能的提升</li></ul></li><li><p>红黑树：在旋转平衡的基础上，添加变色的行为。保持最长子树不超过最短子树的2倍即可。使得查询性能和插入性能近似一致</p></li></ul></li><li><p>随着数据的插入，树的深度越来越深，意味着IO次数越多，影响数据读取的效率，因此使用开始使用树</p></li><li><ul><li><p>B树：多岔树，有序，非叶子节点也是存储着数据的，占用空间较大</p></li><li><p>B+树：多岔树，有序，只有叶子节点存储着数据，非叶子节点存储的是指针</p></li></ul></li></ul><p>索引的创建跟存储引擎是挂钩的，存储引擎表示不同数据在磁盘的不同组织形式</p><p>在windows上的Mysql中，文件都是以不同后缀并成对的形式存在。数据结构用的都是B+树，而存储形式又有所不同</p><ul><li><p>.frm：存放表结构</p></li><li><p>.MYD和.MYI：引擎是myisam，非聚簇索引。</p></li><li><ul><li>.MYD：数据，Data</li><li>.MYI：索引，index</li></ul></li><li><p>.ibd：存储数据+索引，即引擎是innodb。只能有一个聚簇索引，可以有很多非聚簇索引。在插入数据时，必须要包含一个索引的key值。这个索引的key值可以是主键；若没有主键也可以是唯一键；若唯一键也没有，就会有一个自生成的6字节的rowid（对用户不可见）</p></li></ul><p>——聚簇索引与非聚簇索引——二者取决于数据和索引是否是放在一起的</p><p>——mysql表中有且至少有一个索引</p><p>索引覆盖：若查询结果包含普通索引列和聚簇索引列，则会直接返回，不需要从聚簇索引查询任何数据，这就叫索引覆盖</p><ul><li>注：面试常问——在设置主键时是否需要自增？答：在满足业务需求的情况下，能自增尽量自增。因为自增是累加的，对前面的数据没有影响，无需做插入操作，也就无需做磁盘块/页分裂的操作（即：页分裂。当在一页数据里插入数据时，如果数据满了就需要分裂成多个页或者磁盘块来存储，父亲节点也可能需要分裂，而分裂会影响效率）。追加的效率较高</li></ul><p>最左匹配：组合索引的匹配规则。若一张表里有两列是组合索引，那么使用时必须先匹配左侧的列，再匹配右侧列</p><ul><li>select * fro table where name=? and age=? 允许使用</li><li>select * fro table where name=? 允许使用</li><li>select * fro table where age=? 无法使用</li><li>select * fro table where age=? and name=? 允许使用</li><li>只要查询条件是组合索引，那么就算顺序相反，mysql内部的优化器会调整对应的顺序</li></ul><p>索引下推（mysql5.7后特性）：使用组合索引时，直接根据组合索引在存储引擎中获取对应数据，无需在server层二次过滤（5.7之前），减少了server层于存储引擎的交互，减少了IO量，提高了效率</p><p>聚簇索引的条件必须是以主键大小排序，即这个B+树的查询条件为主键。而如果以其他列作为查询条件，我们需要换一个树！重新新建一颗B+树，这个树采用其他列作为查询条件，而它的叶子节点并不会存放完整的用户记录，只会存放该列所在记录的主键。它的目录项也不会使用主键+页号，而是使用其他列+页号搭配。</p><p>二级索引的查询过程：</p><p>由于其他列可能没有唯一约束，所以匹配到的可能有多个主键（记录）。因此当查询到第一条记录后，我们通过查询到的主键到聚簇索引中查找完整的用户记录。这个过程（通过携带主键回到聚簇索引里查询完整的用户记录的过程）就叫回表。然后再返回到刚才的B+树，回到刚才定位到的那条用户记录，顺着记录所形成的单向链表找到其他符合条件的记录，然后再回表，再继续找…… </p><p>回表的定义：根据普通索引查询到聚簇索引的key值之后，再根据key值在聚簇索引中获取所有行记录。回表走了2次B+树</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806192641.png"></p><p>由于这种以非主键列的大小为排序规则而建立的树需要执行回表才能查到完整用户记录，所以这种B+树也称为二级索引，这颗B+树是为其他列所建立的索引，该列是索引列。索引列记录的不是完整的用户信息。</p><p>数据存储在磁盘，一般情况况下查询速率慢，都是卡在IO上。因此需要在满足需求的前提下提高IO效率：</p><ul><li>减少IO次数</li><li>减少IO量</li></ul><p>profiling——mysql自带的性能分析工具（单条语句）</p><ul><li>开启profiling：set profiling=1;</li><li>执行SQL语句，然后show profiles; 即可查出上条语句执行的实际时间</li><li>想要查询profiles结果表中具体某条语句的所有状态耗费时长，或者想查询某条语句的某个状态的使用情况，根据可使用profiles表语句对应的Query_ID来查询，语法如下：show profile for [type] query [id]。但这种查询方式在未来版本可能会被其他工具所取代</li></ul><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806192704.png"></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806192742.png"></p><p>进阶–Myysql性能模式：</p><p>5.7默认开启性能模式，在初始数据库中，会有一个performance_schema库，里面有众多相关表，而通过show variables like ‘performance_schema’;查询性能模式的开启状态。而修改状态无法直接update，需要更改mysql配置文件my.cnf</p><p><a href="https://www.bilibili.com/video/BV1ov41137Vo?p=10">https://www.bilibili.com/video/BV1ov41137Vo?p=10</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot配置mybatis使用的两种方式</title>
    <link href="/2022/08/06/SpringBoot%E9%85%8D%E7%BD%AEmybatis%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/08/06/SpringBoot%E9%85%8D%E7%BD%AEmybatis%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>目前在SpringBoot中的使用Mybatis的pom文件是</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1. 注解版本</strong></p><p>添加相关的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--         mysql--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--         lombok 自动创建bean的 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加properties配置文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.datasource.url</span>=jdbc:mysql://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3306</span>/test?serverTimezone=UTC<br><span class="hljs-attr">spring.datasource.username</span>=root<br><span class="hljs-attr">spring.datasource.password</span>=root<br></code></pre></td></tr></table></figure><p>配置完后，SpringBoot会加载spring.datasource的所有配置。数据源就会自动注入到 sqlSessionFactory 中，sqlSessionFactory 会自动注入到 Mapper 中。</p><p>在主类上开启mapper包扫描</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@MapperScan</span>(<span class="hljs-string">&quot;com.yuanzhou.mybatis.mapper&quot;</span>)<br><span class="hljs-variable">@SpringBootApplication</span><br>public class MybatisApplication &#123;<br><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(MybatisApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建mapper接口，在方法上方添加各项注解</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">UserMapper</span> &#123;<br>    <br>    <span class="hljs-variable">@Select</span>(<span class="hljs-string">&quot;select * from user&quot;</span>)<br>    <span class="hljs-variable">@Results</span>(&#123;<br>        <span class="hljs-variable">@Result</span>(property=<span class="hljs-string">&quot;id&quot;</span>, column=<span class="hljs-string">&quot;id&quot;</span>),<br>        <span class="hljs-variable">@Result</span>(property=<span class="hljs-string">&quot;name&quot;</span>, column=<span class="hljs-string">&quot;name&quot;</span>),<br>        <span class="hljs-variable">@Result</span>(property=<span class="hljs-string">&quot;age&quot;</span>, column=<span class="hljs-string">&quot;age&quot;</span>),<br>        <span class="hljs-variable">@Result</span>(property=<span class="hljs-string">&quot;email&quot;</span>, column=<span class="hljs-string">&quot;email&quot;</span>)<br>    &#125;)<br>    List&lt;User&gt; <span class="hljs-built_in">userList</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>之后测试是正确能读取到的</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">@RunWith</span>(SpringRunner.<span class="hljs-keyword">class</span>)<br><span class="hljs-keyword">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MybatisTestCase &#123;<br>    <br>    <span class="hljs-keyword">@Autowired</span><br>    UserMapper userMapper;<br>    <br>    <span class="hljs-keyword">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> selectTest() &#123;<br>        <br>        List&lt;User&gt; list = userMapper.list();<br>        list.forEach(System.<span class="hljs-keyword">out</span>::println);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185712.png"></p><p> <strong>2.XML版本</strong>（前公司使用的）</p><p>在properties文件中添加如下配置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#实体类映射地址（我这里和mapper文件放在一起了，impl文件夹等同于mapper接口的实现了）</span><br>mybatis.mapper-locations=classpath:com<span class="hljs-regexp">/yuanzhou/my</span>batis<span class="hljs-regexp">/mapper/im</span>pl/*.xml<br></code></pre></td></tr></table></figure><p>在上述位置中添加user的映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.yuanzhou.mybatis.mapper.UserMapper&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.yuanzhou.mybatis.entity.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseColumnList&quot;</span>&gt;</span>id, name, age, email<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span><br>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;BaseColumnList&quot;</span> /&gt;</span> from user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mapper层直接写简单的接口方法就可以了，相较之前的版本，直接把注解删除即可</p><p>个人角色第二种方法更简洁一下，接口里看起来更加干净</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java实现读取本地txt文件(行政区划制作层级标记表格)</title>
    <link href="/2022/08/06/Java%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%8F%96%E6%9C%AC%E5%9C%B0txt%E6%96%87%E4%BB%B6-%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92%E5%88%B6%E4%BD%9C%E5%B1%82%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%A1%A8%E6%A0%BC/"/>
    <url>/2022/08/06/Java%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%8F%96%E6%9C%AC%E5%9C%B0txt%E6%96%87%E4%BB%B6-%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92%E5%88%B6%E4%BD%9C%E5%B1%82%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>首先接到的是一个网址，地址是<a href="http://www.zxinc.org/gb2260.htm%E3%80%82%E4%BD%86%E8%BF%99%E4%B8%AA%E7%BD%91%E5%9D%80%E5%90%8E%E6%9D%A5%E5%B0%B1%E6%B2%A1%E7%94%A8%E4%BA%86%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%82%A3%E8%BE%B9%E5%BA%94%E8%AF%A5%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%EF%BC%8C%E4%B8%8D%E8%BF%87%E8%BF%98%E5%A5%BD%E6%88%91%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BA%86%E3%80%82">http://www.zxinc.org/gb2260.htm。但这个网址后来就没用了，服务器那边应该出问题了，不过还好我保存到本地了。</a></p><p>再放一个云盘</p><p>链接：<a href="https://pan.baidu.com/s/1Hkf2PtRGK3dLQ50tJ1mk4g">https://pan.baidu.com/s/1Hkf2PtRGK3dLQ50tJ1mk4g </a><br>提取码：unon </p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184805.png"></p><p> 这里我是将那个页面打开查看源码然后复制下来的，所以前面带了一个<BR>,这里的每行是由区划代码、区划名称构成。这里一共有6976行</p><p>我的需求是将这份文本做成excel，并分成三列，1列放区划代码，2列放名称，3列需要自家根据区划代码来标记区划层级，如省级则标记1，市级标记2，县级标记3.</p><p>这里我没有用一套流程走到底，excel表格也是我直接手动创建并粘贴数据上去的。我只需要在文本中过滤出我想要的数据并打印到控制台，只要行数是正确的，一列列粘贴到excel表格上是可以的。其实也可以写一个方法来写入至excel,但那样效率低，没必要。</p><p>好了直接贴代码，这里我直接是写在main方法里了，我直接将main方法复制下来。有一部分代码暂时不会用到，我将其注释掉了，等需要用时我会打开注释</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-string">&quot;D:\\xzqh.txt&quot;</span>);  <span class="hljs-comment">//源文本</span><br><span class="hljs-comment">//        File file = new File(&quot;D:\\code.txt&quot;);  //代码+标记文本</span><br>        BufferedReader br = <span class="hljs-keyword">null</span>;<br>        StringBuffer sb = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//在字节流的基础上套用InputStreamReader转换为字符流</span><br>            br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">file</span>.getPath()), <span class="hljs-string">&quot;GBK&quot;</span>));<br>            sb = <span class="hljs-keyword">new</span> StringBuffer();<br>            String line = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                sb.<span class="hljs-keyword">append</span>(line);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                br.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//打印文件的所有内容</span><br>        System.err.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">new</span> String(sb));  <br></code></pre></td></tr></table></figure><p>讲一下整体思路吧，我们得到的结果是有三列的Excel表格，所以我们一列一列的走，先拿到他的区划代码</p><p>然后接下来是步骤</p><p>**1.**将上面的代码运行，注意文件位置是对的，正确运行的话应该是下面的样子，这是没有换行的，不过这个影响不大。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184927.png"></p><p> 将 打印所有内容 那行代码注释掉，因为我们不需要打印所有，只需要将区划代码打印出来；并将下面的注释打开，如图</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184943.png"></p><p> 再次运行程序，打印台输出区划代码，同样是6976行（总行数），将其复制粘贴至excel的第一列</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184959.png"></p><p> **2.**根据行政区划做标记省级为XX0000,市级为XXX000或XXXX00，县级为XXXXXX或XXXXX0，层级标记的是数字，所以，但是区划也是数字，在这里不好区分开，所以暂时用ABC代替123，便于过滤。</p><p>将 直接输出 那行代码注释，如图，其他则不变。这段代码是根据区划代码在后面加上标记</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185015.png"></p><p> 输出如图：这里的000000是中华人民共和国，因为只有一个，所以我这里不做判断</p><p> <img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185030.png"></p><p> 然后将打印台内容全选放入一个新的txt文本，取名code.txt。里面保存的是行政区划+区划标记的文本。（先暂时存放，后面还需要用到）</p><p>**3.**将 处理追加字符下面这段代码注释掉，打开 直接输出 的注释，如图</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185050.png"></p><p> 然后将过滤条件更换成匹配中文，然后将 直接输出 这行代码注释掉，将蓝色部分代码的注释打开。这里解释一下为什么已经匹配了中文还需要这么麻烦地对比字符，这是因为有些地名实在是千奇百怪，直接匹配地名，会导致匹配出来行数对不上，也就是数据有问题，所以才这样走一遍的：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185105.png"></p><p> 然后直接输出，打印台是这样的，复制到Ecel，这样就拿到第二列的区划名称</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185120.png"></p><p> <img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185135.png"></p><p>4.读取刚才的code.txt，注意路径。并将以下代码如图注释掉。这里匹配字母然后选择过滤后直接输出！</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185152.png"></p><p> 记得将上面的读取的文件替换成code.txt，将code处理这段注释打开，</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185214.png"></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185226.png"></p><p>打印出一串字母+数字组合，再将以下打印台输出的额所有内容复制到code.txt，再更换过滤条件，单独将数字取出</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185240.png"></p><p> 过滤后直接输出即可，不需要处理什么，注意运行前记得把匹配的6为数字改成1位</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185251.png"></p><p> 控制台输出： </p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185305.png"></p><p> 将其复制粘贴至Excel中即可。注意1开始是从北京市开始的，而不是从中华人民共和国开始。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806185321.png"></p><p>  逻辑有点乱，下次好好梳理</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Springboot 测试类没有找到bean注入</title>
    <link href="/2022/08/06/Springboot-%E6%B5%8B%E8%AF%95%E7%B1%BB%E6%B2%A1%E6%9C%89%E6%89%BE%E5%88%B0bean%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/08/06/Springboot-%E6%B5%8B%E8%AF%95%E7%B1%BB%E6%B2%A1%E6%9C%89%E6%89%BE%E5%88%B0bean%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>其他乱七八糟配置就不扯了，先上项目结构图</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184436.png"></p><p> 配置好参数后我再src/test/java类测试访问数据库时发现bean没有正确的注入。值得注意的是，这个项目的启动类是叫App.java</p><p>所以我们必须在这个测试类上面加上注解：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RunWith</span>(SpringRunner.class)<br><span class="hljs-variable">@SpringBootTest</span>(classes = App.class) <br></code></pre></td></tr></table></figure><p>注意：SpringBoot(classes = App.class) classes后面跟的是启动类的class，千万不要随便抄网上的配置，写一些Application.class之类的，这种Application之类的类名和一些官方包里的类名一样，容易引入错误的包。</p><p>刚开始发现这个问题疯狂去网上看别人的配置文件是怎么写的，试了一天都没用，后来静下心来，把错误信息copy出来文本里仔细看</p><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">org.springframework.beans.<span class="hljs-keyword">factory</span>.UnsatisfiedDependencyException:<br> Error creating bean <span class="hljs-keyword">with</span> name <span class="hljs-string">&#x27;com.springboot.LibrarySystem.mapper.UserMapperTest&#x27;</span>:<br> Unsatisfied dependency expressed through field <span class="hljs-string">&#x27;userMapper&#x27;</span>; <br> nested exception <span class="hljs-keyword">is</span> org.springframework.beans.<span class="hljs-keyword">factory</span>.NoSuchBeanDefinitionException:<br> No qualifying bean of type <span class="hljs-string">&#x27;com.sb.LibrarySystem.mapper.UserMapper&#x27;</span> <br> available: expected at least <span class="hljs-number">1</span> bean which qualifies <span class="hljs-keyword">as</span> autowire candidate. <br> Dependency annotations: &#123;<span class="hljs-meta">@org</span>.springframework.beans.<span class="hljs-keyword">factory</span>.annotation.Autowired(<span class="hljs-keyword">required</span>=<span class="hljs-keyword">true</span>)&#125;<br></code></pre></td></tr></table></figure><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p><p>还是从这个Test类下手</p><p>本来我的类是这样的：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RunWith</span>(SpringRunner.class)<br><span class="hljs-variable">@SpringBootTest</span>(classes = Application.class)<br>public class UserMapperTest &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>修改后就是这样,和我的启动类的类名是一致的：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RunWith</span>(SpringRunner.class)<br><span class="hljs-variable">@SpringBootTest</span>(classes = App.class)<br>public class UserMapperTest &#123;<br></code></pre></td></tr></table></figure><p>完美解决！</p><p>如果百度的时候，发现查看的问题越来越深，越来越偏离最开始的问题，那十有八九是方向偏了，重新整理一下，重新开始吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Eclipse配置Maven的本地仓库和阿里云镜像</title>
    <link href="/2022/08/06/Eclipse%E9%85%8D%E7%BD%AEMaven%E7%9A%84%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/"/>
    <url>/2022/08/06/Eclipse%E9%85%8D%E7%BD%AEMaven%E7%9A%84%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>先确定自己电脑是否安装了Maven和安装位置，具体查询方法直接win+R键打开运行窗口，输入cmd打开dos窗口，再输入mvn -v即可查询安装的位置</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184146.png"></p><p>拿到安装位置 D:\Applications\Work\apache-maven-3.6.1 后打开该位置下的conf文件夹，找到一个叫settings.xml的文件。</p><p>将以下代码粘贴至<mirrors>标签内（注：没修改之前，这个标签里的内容是完全注释掉的，将代码粘贴在标签内部即可，不用管原有的内容。注意有两层标签）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>          <br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span> <br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184214.png"></p><p> 然后找到<localRepository>标签，将里面的内容修改为你Maven本地仓库即可（可以创建一个新的文件夹），这里我没有修改。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184231.png"></p><p> 然后是修改Eclipse内的配置Window-Preferences 这里修改是的是maven的地址</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184242.png"></p><p> 然后修改刚才修改过的setting.xml和本地仓库，我的本地仓库由于没有修改，依旧是.m2文件夹</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806184259.png"></p><p>这样就OK了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS鼠标悬停设置layui tips提示框</title>
    <link href="/2022/08/06/JS%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9C%E8%AE%BE%E7%BD%AElayui-tips%E6%8F%90%E7%A4%BA%E6%A1%86/"/>
    <url>/2022/08/06/JS%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9C%E8%AE%BE%E7%BD%AElayui-tips%E6%8F%90%E7%A4%BA%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>官方介绍：吸附层，灵活判断出现的位置，默认在元素的右侧弹出。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">layer<span class="hljs-selector-class">.tips</span>(<span class="hljs-attribute">content</span>, follow, options)<br>layer<span class="hljs-selector-class">.tips</span>(msg, <span class="hljs-string">&#x27;#id&#x27;</span>,&#123;tips: <span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><p>必填参数 ：</p><p>content: 生成的文本，可以是字符串或HTML代码<br>follow: 元素ID，若是元素本身可直接用this（绑定元素时）<br>options : tips的配置型，即位置[1上；2右；3下；4左, 字体颜色]</p><p>还有一些基础参数，我的另一篇文章中，是layer弹出层是基础参数</p><p>实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showDiv</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>    layer.<span class="hljs-title function_ invoke__">tips</span>(<span class="hljs-string">&quot;&lt;span&gt;车辆轨迹&lt;/span&gt;&lt;span&gt;关联人员&lt;/span&gt;&quot;</span>,         <br>    <span class="hljs-string">&quot;#&quot;</span>+obj.id, <br>    &#123;<span class="hljs-attr">tips</span>:[<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;#663ff&#x27;</span>], <span class="hljs-attr">time</span>:<span class="hljs-number">3000</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p> 以上效果就是鼠标悬浮到a标签后，显示悬浮窗，3s后自动关闭。为啥要设置3秒自动关闭？因为这样可以让我们去点击a标签里的内容。由于会自动关闭，所以也不需要鼠标移除的事件。</p><p><em>需要注意的是，需要多个tips悬浮时，tipsMore（默认false）应该是flase的</em></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java实现文本中的关键字高亮,匹配所有长度</title>
    <link href="/2022/08/06/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE-%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E9%95%BF%E5%BA%A6/"/>
    <url>/2022/08/06/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE-%E5%8C%B9%E9%85%8D%E6%89%80%E6%9C%89%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>这个方法还不完整，后面想起来再看，直接放代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getHeightlightWord</span><span class="hljs-params">(String textWord, String key)</span>&#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">tempWord</span> <span class="hljs-operator">=</span> textWord == <span class="hljs-literal">null</span>? <span class="hljs-string">&quot;&quot;</span> : textWord.trim();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">tempKey</span> <span class="hljs-operator">=</span> key == <span class="hljs-literal">null</span>? <span class="hljs-string">&quot;&quot;</span> : key.trim();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;&quot;</span>.equals(tempWord) || <span class="hljs-string">&quot;&quot;</span>.equals(tempKey))&#123;<br>        <span class="hljs-keyword">return</span> tempWord;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        sb.append(tempWord);<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">upperWord</span> <span class="hljs-operator">=</span> tempWord.toUpperCase();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">upperKey</span> <span class="hljs-operator">=</span> tempKey.toUpperCase();<br>    <span class="hljs-keyword">if</span>(!upperWord.contains(upperKey))&#123;<br>        <span class="hljs-keyword">return</span> tempWord;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">keyLen</span> <span class="hljs-operator">=</span> upperKey.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">thisMathIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;Map&lt;Integer, String&gt;&gt; matchList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Map&lt;Integer, String&gt;&gt;();<br>        <span class="hljs-keyword">while</span>((thisMathIndex = upperWord.indexOf(upperKey, thisMathIndex)) != -<span class="hljs-number">1</span>)&#123;<br>            Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, String&gt;();<br>            map.put(thisMathIndex, tempWord.substring(thisMathIndex, thisMathIndex + keyLen));<br>            matchList.add(map);<br>            thisMathIndex += keyLen;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">thisKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Map&lt;Integer, String&gt; map : matchList)&#123;<br>            thisKey = getKey(map);<br>            keys += thisKey;<br>            sb.replace(thisKey, thisKey + keyLen, <span class="hljs-string">&quot;&lt;span style=&#x27;background-color: yellow;&#x27;&gt;&quot;</span>+map.get(thisKey)+<span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>);<br>            keys += <span class="hljs-string">&quot;&lt;span style=&#x27;background-color: yellow;&#x27;&gt;&lt;/span&gt;&quot;</span>.length();<br>        &#125;<br>    &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getKey</span><span class="hljs-params">(Map&lt;Integer, String&gt; obj)</span>&#123;<br>    Set&lt;Integer&gt; keySet = obj.keySet();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">firstKey</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> key : keySet)&#123;<br>        firstKey = key;<br>        <span class="hljs-keyword">if</span>(firstKey != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> firstKey;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码可实现一次高亮，余下的问题就在于如何多次改变字符串的长度后能定位到需要更改的字符串（即多次高亮），打个卡先，有空再弄</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java身份证处理方法(15转18,出生日期隐藏)</title>
    <link href="/2022/08/06/Java%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-15%E8%BD%AC18-%E5%87%BA%E7%94%9F%E6%97%A5%E6%9C%9F%E9%9A%90%E8%97%8F/"/>
    <url>/2022/08/06/Java%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-15%E8%BD%AC18-%E5%87%BA%E7%94%9F%E6%97%A5%E6%9C%9F%E9%9A%90%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>只有第一代身份证是15位，后面的身份证都是18位数字</p><p>15位身份证：地址码+出生日期码(2位年)+顺序码<br>18位身份证：地址码+出生日期码(4位年)+顺序码+校验码</p><p>地址码：当地的行政区划代码，6位<br>出生日期码：即出生年月日<br>顺序码：同一地址码的区域内，对同年同月同日生的人进行编号，奇数为男性，偶数为女性<br>校验码：通过算法计算得出。</p><p>校验方法<br>1.将前17位数字分别乘以不同的系数，这个系数数组如下：7-9-10-5-8-4-2-1-6-3-7-9-10-5-8-4-2<br>2.将这17位数字和系数相乘的结果相加，加出来的和除以11，看余数是多少<br>3.余数只有可能在0-1-2-3-4-5-6-7-8-9-10这11个数字之间，分别对应的校验码是1-0-X-9-8-7-6-5-4-3-2<br>即如果余数为0，身份证校验码就是1，余数为2就是X</p><p>然后就上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//计算校验码</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getVerifyCode</span><span class="hljs-params">(String idCard)</span>&#123;<br>    <span class="hljs-keyword">if</span>(idCard == <span class="hljs-literal">null</span> || idCard.length()&lt;<span class="hljs-number">17</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">char</span>[] ai = idCard.toCharArray();<br>    <span class="hljs-type">int</span>[] wi = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">char</span>[] verifyCode = &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;wi.length; i++) &#123;<br>        s+=(ai[i]-<span class="hljs-string">&#x27;0&#x27;</span>)*wi[i];<br>    &#125;<br>    y = s % <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">return</span> verifyCode[y];<br>&#125;<br><br><span class="hljs-comment">//转换为18位</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNewIdCard</span><span class="hljs-params">(String oldCard)</span>&#123;<br>    StringBuilder sb;<br>    <span class="hljs-keyword">if</span>(oldCard != <span class="hljs-literal">null</span> &amp;&amp; oldCard.length() == <span class="hljs-number">15</span>) &#123;<br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(oldCard.substring(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)).append(<span class="hljs-string">&quot;19&quot;</span>).append(oldCard.substring(<span class="hljs-number">6</span>));<br>        sb.append(getVerifyCode(sb.toString()));<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 隐藏出生日期，用*代替</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBrithdayByxx</span><span class="hljs-params">(String idCard)</span>&#123;<br>    <span class="hljs-type">Srting</span> <span class="hljs-variable">newCard</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span>(idCard != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(idCard.length == <span class="hljs-number">18</span>)&#123;<br>            newCard = idCard.substring(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)+ <span class="hljs-string">&quot;********&quot;</span>+idCard.substring(<span class="hljs-number">14</span>, <span class="hljs-number">18</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>()&#123;<br>            newCard = idCard.substring(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)+ <span class="hljs-string">&quot;******&quot;</span>+idCard.substring(<span class="hljs-number">12</span>, <span class="hljs-number">15</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newCard;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Layer单选框 radio问题总结</title>
    <link href="/2022/08/06/Layer%E5%8D%95%E9%80%89%E6%A1%86-radio%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/06/Layer%E5%8D%95%E9%80%89%E6%A1%86-radio%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>放官方文档：<a href="https://www.layuiweb.com/doc/element/form.html#radio">https://www.layuiweb.com/doc/element/form.html#radio</a></p><p>位置 页面元素-表单；内置模块-表单<br>属性title可自定义文本<br>属性disabled开启禁用<br>设置value=”xxx”可自定义值，否则选中时返回的就是默认的on<br>radio单选框被点击时触发，回调函数返回一个object参数，并携带两个成员：<br>data.elem radio原始DOM对象<br>data.value 被点击的radio的value值</p><p>官网文档太简洁了，以至于在实际碰到问题时，明明可以一个小时解决，最后却要花费两三个小时，其实说到底还是菜如狗罢了。</p><p>在layer渲染过type为radio的input后，会在原始input元素的后面追加一个div，div的内容如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;layui-unselect layui-form-radio layui-form-radioed&quot;</span>&gt;<br>&lt;i <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;layui-anim layui-icon&quot;</span>&gt;&lt;/i&gt;<br>&lt;<span class="hljs-keyword">div</span>&gt;input的title值&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><ol><li>获取所选中的单选框的对象和value值<br>一般情况下，input框有一个id，然后直接找到下一个元素就是当前展示出来的那个div对象了。<br>即：$(“#inputId”).next();</li></ol><p>input框中添加lay-filter=”xxx”,即带有lay-filter的input都在渲染范围之内，根据filter的值来区分不同的单选框<br>var val = $(“input[name=’xxx’]:checked”).val()<br>val即是所选中的框的value值。可在页面初始化时获取，并在获取后进行下一步操作。</p><ol start="2"><li>控制多选框的点击事件(事件监听)</li></ol><p>语法：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">form.<span class="hljs-literal">on</span>(<span class="hljs-string">&#x27;event(过滤器值)&#x27;</span>, callback);<br></code></pre></td></tr></table></figure><p>form模块在layui事件机制中注册了专属事件，所以当你使用layui.onevent(自定义模块事件时，请勿占用form名。</p><p>form支持的事件有：select; checkbox; switch; radio; submit</p><p>默认监听的是所有form模块元素，但一般都不会这么干，所以这里需要用到filter过滤</p><p>其实这个事件监听就相当于我们的点击事件</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">form.on(<span class="hljs-string">&#x27;select(test)&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>更新渲染</strong>：<br>页面加载时，layer将该渲染的元素全部渲染一遍。但有时候数据是动态操作的，需要执行更新渲染才可以</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">form</span><span class="hljs-selector-class">.render</span>(type, <span class="hljs-attribute">filter</span>)<br></code></pre></td></tr></table></figure><p>type :可选。表单的type，如果不选择，则对全部类型的表单刷新一次<br>可选择的type值：</p><p>select 下拉选；</p><p>checkbox 多选框(含开关)；</p><p>radio 单选框。例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">form</span><span class="hljs-selector-class">.render</span>(<span class="hljs-string">&#x27;select&#x27;</span>);<br></code></pre></td></tr></table></figure><p>filter :即class=”layui-form” 所在元素的lay-filter=“”的值，说白了这个值就是相同的一个或多个input的lay-filter的值，由这个filter值来控制元素的渲染范围<br>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">form</span><span class="hljs-selector-class">.render</span>(null, <span class="hljs-string">&#x27;test&#x27;</span>)或<span class="hljs-selector-tag">form</span><span class="hljs-selector-class">.render</span>(<span class="hljs-string">&#x27;test&#x27;</span>)  <span class="hljs-comment">//重新渲染lay-filter值为test的所有元素的全部状态（包含select、checkbox和radio）</span><br><span class="hljs-selector-tag">form</span><span class="hljs-selector-class">.render</span>(<span class="hljs-string">&#x27;select&#x27;</span>, <span class="hljs-string">&#x27;test1&#x27;</span>) <span class="hljs-comment">//重新渲染lay-filter值为test1的所有元素的select状态</span><br></code></pre></td></tr></table></figure><p><strong>注：</strong>一般在同一个元素上放置多种状态的挺少的，起码我还没碰到过，所以一般一个元素只放一个状态（即一种框）。等碰到了再回来补</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java生成指定数量的假数据</title>
    <link href="/2022/08/06/Java%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%81%87%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/08/06/Java%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%81%87%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>实际上也不是什么正经需求，只是在画页面的时候需要放一些随机的假数据，且最好不要重复。我这里只放了十套假数据就懒得再放了，写成了一个方法先放在这里</p><p>随机生成一些假数据：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> String get<span class="hljs-constructor">RandomInfo(String <span class="hljs-params">flag</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span>&#123;<br>    List&lt;String&gt; <span class="hljs-built_in">list</span> = null;<br>    <span class="hljs-built_in">int</span> sex = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> xb = <span class="hljs-number">0</span>;<br>    switch(flag) &#123;<br>    case <span class="hljs-string">&quot;1&quot;</span>:<br>        <span class="hljs-comment">//姓名数组</span><br>        String<span class="hljs-literal">[]</span> nameArr = &#123;<span class="hljs-string">&quot;哈里旦&quot;</span>, <span class="hljs-string">&quot;加德拉&quot;</span>, <span class="hljs-string">&quot;米娜尔&quot;</span>, <span class="hljs-string">&quot;比比努尔&quot;</span>, <span class="hljs-string">&quot;森田提&quot;</span>&#125;;<br>        <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">nameArr</span>)</span>;<br>        break;<br>    case <span class="hljs-string">&quot;2&quot;</span>:<br>        <span class="hljs-comment">//证件号码数组</span><br>        String<span class="hljs-literal">[]</span> zjhmArr = &#123;<span class="hljs-string">&quot;370205621219253&quot;</span>, <span class="hljs-string">&quot;370206501122483&quot;</span>, <span class="hljs-string">&quot;370203640507092&quot;</span>, <span class="hljs-string">&quot;370206390709161&quot;</span>, <span class="hljs-string">&quot;370206340306481&quot;</span>&#125;;<br>        <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">zjhmArr</span>)</span>;<br>        break;<br>    case <span class="hljs-string">&quot;3&quot;</span>:<br>        <span class="hljs-comment">//户籍详址数组</span><br>        String<span class="hljs-literal">[]</span> hjxzArr = &#123;<span class="hljs-string">&quot;新疆伊犁市xxx街1号&quot;</span>, <span class="hljs-string">&quot;新疆伊犁市xxx街2号&quot;</span>, <span class="hljs-string">&quot;新疆伊犁市xxx街3号&quot;</span>, <span class="hljs-string">&quot;新疆伊犁市xxx街4号&quot;</span>, <span class="hljs-string">&quot;新疆伊犁市xxx街5号&quot;</span>&#125;;<br>        <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">hjxzArr</span>)</span>;<br>        break;<br>    case <span class="hljs-string">&quot;4&quot;</span>:<br>        <span class="hljs-comment">//现住详址数组</span><br>        String<span class="hljs-literal">[]</span> xzxzArr = &#123;<span class="hljs-string">&quot;西湖区xx路111号&quot;</span>, <span class="hljs-string">&quot;西湖区xx路222号&quot;</span>, <span class="hljs-string">&quot;西湖区xx路333号&quot;</span>, <span class="hljs-string">&quot;西湖区xx路444号&quot;</span>, <span class="hljs-string">&quot;西湖区xx路555号&quot;</span>&#125;;<br>        <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">xzxzArr</span>)</span>;<br>        break;<br>    case <span class="hljs-string">&quot;5&quot;</span>:<br>        xb = (<span class="hljs-built_in">int</span>)(<span class="hljs-number">1</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>random<span class="hljs-literal">()</span>*<span class="hljs-number">2</span>);<br>        sex = <span class="hljs-number">1</span>;<br>        break;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(sex<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">list</span>.<span class="hljs-params">get</span>(<span class="hljs-params">num</span>)</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        return xb<span class="hljs-operator"> == </span><span class="hljs-number">1</span>?<span class="hljs-string">&quot;男&quot;</span>:<span class="hljs-string">&quot;女&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是放在for循环内调用的方法，所以必须填入一个num来控制具体哪一组数据，flag用于区分数组的类别。<br>根据需要生成的数据条数，作为for循环的次数，就可以将指定次数的数据生成出来。</p><p><strong>注意</strong>：在页面分页时需要特别调试。目前我只放到10次以内。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树莓派设置音频输出音量</title>
    <link href="/2022/08/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AE%BE%E7%BD%AE%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA%E9%9F%B3%E9%87%8F/"/>
    <url>/2022/08/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AE%BE%E7%BD%AE%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA%E9%9F%B3%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>首先查看声卡</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">amixer scontrols</span><br></code></pre></td></tr></table></figure><p>我是在手机上用JuiceSSH敲的命令，这里就不展示截图了</p><p>上述命令显示如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">Simple mixer <span class="hljs-keyword">control</span> <span class="hljs-string">&#x27;PCM&#x27;</span>, <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>然后在输入：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">amixer <span class="hljs-keyword">set</span> PCM <span class="hljs-comment">80%</span><br></code></pre></td></tr></table></figure><p>即可设置音量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux下查询jdk安装路径</title>
    <link href="/2022/08/06/Linux%E4%B8%8B%E6%9F%A5%E8%AF%A2jdk%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/08/06/Linux%E4%B8%8B%E6%9F%A5%E8%AF%A2jdk%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>首先这个问题困扰了我很久，由于是新装的系统还不熟悉，配置java环境变量时很头疼，找不到JDK位置，还好google一波，发现了这个方法。</p><p>首先确保安装了JDK</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-version<br><br><span class="hljs-keyword">java </span>version <span class="hljs-string">&quot;1.8.0_65&quot;</span><br><span class="hljs-keyword">Java(TM) </span>SE Runtime Environment (<span class="hljs-keyword">build </span><span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>_65-<span class="hljs-keyword">b17)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Java </span>HotSpot(TM) Client VM (<span class="hljs-keyword">build </span><span class="hljs-number">25</span>.<span class="hljs-number">65</span>-<span class="hljs-keyword">b01, </span>mixed mode)<br></code></pre></td></tr></table></figure><p>查找java命令位置，注意图形界面可看到这是个软链</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">which java<br><br><span class="hljs-regexp">/usr/</span>bin/java<br></code></pre></td></tr></table></figure><p>然后再查找java位置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/usr/</span>bin/java<br><br>lrwxrwxrwx <span class="hljs-number">1</span> root root <span class="hljs-number">22</span> <span class="hljs-number">6</span>月  <span class="hljs-number">27</span>  <span class="hljs-number">2018</span> <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/java -&gt; /</span>etc<span class="hljs-regexp">/alternatives/</span>java<br></code></pre></td></tr></table></figure><p>根据指向的目录，查找jdk目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/etc/</span>alternatives/java<br><br>lrwxrwxrwx <span class="hljs-number">1</span> root root <span class="hljs-number">53</span> <span class="hljs-number">8</span>月  <span class="hljs-number">24</span> <span class="hljs-number">19</span>:<span class="hljs-number">16</span> <span class="hljs-regexp">/etc/</span>alternatives<span class="hljs-regexp">/java -&gt; /u</span>sr<span class="hljs-regexp">/lib/</span>jvm<span class="hljs-regexp">/jdk-8-oracle-arm32-vfp-hflt/</span>jre<span class="hljs-regexp">/bin/</span>java<br></code></pre></td></tr></table></figure><p>最后拿到jdk的目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>jdk-<span class="hljs-number">8</span>-oracle-arm32-vfp-hflt<span class="hljs-regexp">/jre/</span>bin/java<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树莓派更新源流程</title>
    <link href="/2022/08/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%96%B0%E6%BA%90%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/08/06/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%96%B0%E6%BA%90%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>直接切换至root用户下执行操作</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su - root</span><br></code></pre></td></tr></table></figure><p>输入密码进入root用户，然后修改软件更新源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>apt/sources.list <br></code></pre></td></tr></table></figure><p>将原来的源用 # 注掉，添加这个阿里源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/raspbian/</span>raspbian/ stretch main contrib non-free rpi<br></code></pre></td></tr></table></figure><p>接下来修改系统更新源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>raspi.list<br></code></pre></td></tr></table></figure><p>将原有注释掉，添加这个科大源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb http:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/archive.raspberrypi.org/</span>debian/ stretch main ui<br></code></pre></td></tr></table></figure><p>最后更新一下即可</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> upgrade<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树莓派wifi环境下初始化及环境配置</title>
    <link href="/2022/08/06/%E6%A0%91%E8%8E%93%E6%B4%BEwifi%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/08/06/%E6%A0%91%E8%8E%93%E6%B4%BEwifi%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在此放一下我的系统</p><p>链接：<a href="https://pan.baidu.com/s/192cL6qSsMd-wqxHeDWfIug">https://pan.baidu.com/s/192cL6qSsMd-wqxHeDWfIug</a><br>提取码：0lrq </p><p>1.准备一张内存卡，最好是32G class10 16G的话也够用。然后用SDFormatter格式化一下</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806182544.png"></p><p>2.用Win32DiskImager读取img包，并选择需要写入的SD卡，然后点击下方Write写入，根据img包的大小和内存卡写入速度不同，等待时间也不一样</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806182559.png"></p><p>3.打开内存卡的根目录，创建一个名为ssh的文件，（没有后缀）。如若看不到后缀自行打开文件夹选项-查看显示后缀。然后再创建一个名为wpa_supplicant.conf，注意后缀就是.conf，用文本编辑器打开即可，填入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">country=CN <br>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev<br>update_config=1<br>network=&#123;  <br>ssid=<span class="hljs-string">&quot;WiFi-SSID&quot;</span>   <br>psk=<span class="hljs-string">&quot;pwd&quot;</span>   <br>key_mgmt=WPA-PSK   <br>priority=1<br>&#125;<br></code></pre></td></tr></table></figure><p>ssid和psk自己填入wifi名和密码，key_mgmt是加密方式，按照不同的加密方式填写，一般都是WPA-PSK加密，其他的应该不需要改动。</p><p>4.将内存卡插入树莓派，等待1~2分钟。第一次连接wifi时，IP是跟随当前地址往后排的。但这样的的地址是动态的，不方便后期调试，所以应该设置为静态IP。</p><p>打开netscan（官网安装，自带中文试用） ，查找当前局域网内的ip范围，如果不清楚就先看看自己电脑上的，根据网关选择一个0~192的范围。根据扫描结果：</p><p>我这里已经配置好了静态IP，这个系统也自带的已经写好的主机名，所以第一次连接时还是很好找的。但我们设置静态IP应该将IP固定在不常用的一些地址，比如我常用的是192.168.0.0 ~ 192.168.0.100，我就把110这个不常用的ip给树莓派，一般操作就是这样。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806182616.png"></p><p>5.想好一个将要分配给树莓派的IP后，根据扫描到的树莓派IP,SSH上去，输入用户名密码，这个系统的用户名是pi 密码 yahboom</p><p>然后用自带的nano编辑DHCP配置文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>dhcpcd.conf<br></code></pre></td></tr></table></figure><p> 然后在末尾添加一段代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">interface wlan0<br> <br>static ip_address=内网静态ip地址/24<br>static routers=内网网关ip地址<br>static domain_name_servers=114.114.114.114<br><span class="hljs-comment"># 使用CTRL+O保存修改（字母o），然后回车确认，再CTRL+X退出编辑</span><br><span class="hljs-comment"># 设置静态IP完成，重启树莓派即可，重新SSH连接时记得更换为刚刚替换的静态IP</span><br></code></pre></td></tr></table></figure><p>将系统自带的python2.7卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get autoremove python2.7<br></code></pre></td></tr></table></figure><p>然后将另外一个3.5版本的python设置为默认（否则无法检测到）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> -s /usr/bin/python3.5 /usr/bin/python<br></code></pre></td></tr></table></figure><p>进入python命令后，退出则输入quit()或按CTRL+D回到树莓派命令下。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-JVM内存区域划分</title>
    <link href="/2022/08/06/Java-JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/"/>
    <url>/2022/08/06/Java-JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>发现网上有两个版本的JVM内存划分，一个是按照《深入理解JVM虚拟机》上的版本，包含程序计数器等，按照是否线程共享划分。</p><p>另一个我觉得更好记一些，也更适合我自己，在这里记录一下。</p><p>首先上思维导图：<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806182340.png"></p><p>一个个来说道吧。</p><p><strong>堆内存 heap</strong></p><p>堆内存主要被划分为新生代和老年代（叫法不一，差不多的意思）。JVM默认Yong和Old分配比例为1:2，即新生代的内存大小为堆内存的1/3。</p><p>（调整参数：–XX:NewRatio）</p><p>基本上所有对象实例都在堆中创建，因此堆内存经常发生GC回收操作。新的对象首先分配在Eden区，两个Surviior区仅作为Eden区的缓冲使用。每次GC回收一次，对象的age值就+1，当Survivor区对象age值大于15时，就被转移到老年代。</p><p>（age值调整参数：-XX:MaxTenuringThreshold）</p><p>新生代下又划分为三个区，即Eden Space，To Survivor ，From Survivor。新生代占用堆内存的1/3，而三个区的内存占用情况如下图:<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806182358.png"></p><p>新生代中，Eden、from、to的默认比例为8：1：1，一般来说，当Eden区内存将要被占满时，才会进入其中一个Survivor区。JVM每次只会使用一块Survivor区来为对象服务。所以，不论何时，都存在一个空闲的Survivor区域</p><p>（调整参数：–XX:SurvivorRatio ）</p><p>老年代存放JVM认为生命周期较长的对象，内存大小也比较大，GC回收相对来说不太频繁，所以分配给老年区的内存大小为堆内存的2/3</p><p>堆内存回收规则：</p><p>当一个对象小于Eden区内存时，直接放入Eden区，若大于Eden并小于老年代，则直接放入老年代。若大于老年代，则直接内存溢出</p><p>如此分区的目的：</p><p>新生代由于对象产生的比较多并且大都是朝生夕灭的，所以直接采用标记-清理算法。而老年代生命力强，采用复制算法，针对不同情况使用不同算法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 将Clob类型转换为String</title>
    <link href="/2022/08/06/Java-%E5%B0%86Clob%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BAString/"/>
    <url>/2022/08/06/Java-%E5%B0%86Clob%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BAString/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>SQL CLOB 是内置类型，它将字符大对象存储为数据库表某一行中的一个列值，使用CHAR来存储数据，如XML文档。</p><p>如下是一个Clob转换为String的静态方法，可将其放在自己常用的工具类中，想直接用的话，自己稍作修改即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">clobToStr</span><span class="hljs-params">(Clob clob)</span> &#123;<br>  <span class="hljs-keyword">if</span>(clob == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;  <br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">strClob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">Reader</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>    reader = clob.getCharacterStream();<br>    <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (length = reader.read(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>)) != -<span class="hljs-number">1</span>) &#123;<br>        strClob.append(buffer, <span class="hljs-number">0</span>, length);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">if</span> (reader != <span class="hljs-literal">null</span>)<br>            reader.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br>str = strClob.toString();<br><span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure><p>我在将数据导出成Excel时碰到的问题，需要导出的数据中有Clob格式只需将其Clob对象（若直接导出则显示的是地址）</p><p>这个工具挺好用的，放在这里，以后方便自己使用。<br>另：博客园的代码排版实在太丑了，以后还是在外面编辑好再粘贴进来比较好</p><p>2022.08.06迁移吐槽:太好笑了,现在你已经到github了,再也不用担心博客园的排版了!</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript实现&lt;li&gt;元素向上轮播</title>
    <link href="/2022/08/06/JavaScript%E5%AE%9E%E7%8E%B0-li-%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8A%E8%BD%AE%E6%92%AD/"/>
    <url>/2022/08/06/JavaScript%E5%AE%9E%E7%8E%B0-li-%E5%85%83%E7%B4%A0%E5%90%91%E4%B8%8A%E8%BD%AE%E6%92%AD/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在网上找了很久，没有找到合适的模板，其实我这个也是公司用的，希望以后也能复用，节省时间</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> scroll<span class="hljs-constructor">Auto(<span class="hljs-params">scrollBox</span>, <span class="hljs-params">list</span>)</span>&#123;<span class="hljs-comment">//两个参数分别填列表的ul的class属性和li的class属性</span><br>        var listHeight = <span class="hljs-constructor">$(<span class="hljs-params">list</span>)</span>.outer<span class="hljs-constructor">Height(<span class="hljs-params">true</span>)</span>;<br>        var mTop = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">function</span> <span class="hljs-built_in">list</span><span class="hljs-constructor">Go()</span> &#123;<br>            <span class="hljs-keyword">if</span>(mTop &gt; -listHeight) &#123;<br>                <span class="hljs-constructor">$(<span class="hljs-params">scrollBox</span>)</span>.css(&#123;&#x27;margin-top&#x27;: mTop&#125;);<br>                mTop = mTop - <span class="hljs-number">0.5</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                   mTop = <span class="hljs-number">0</span>;<br>                    <span class="hljs-constructor">$(<span class="hljs-params">scrollBox</span>)</span>.css(&#123;&#x27;margin-top&#x27;: <span class="hljs-character">&#x27;0&#x27;</span>&#125;);<br>                    <span class="hljs-constructor">$(<span class="hljs-params">scrollBox</span>)</span>.find(&#x27;.a-<span class="hljs-built_in">list</span>:first-child&#x27;).append<span class="hljs-constructor">To(<span class="hljs-params">scrollBox</span>)</span>; <span class="hljs-comment">//此处的a-list为li的class属性名</span><br>            &#125;<br>        &#125;<br>        var listTime = set<span class="hljs-constructor">Interval(<span class="hljs-params">listGo</span>, 20)</span>;<br>        <span class="hljs-constructor">$(<span class="hljs-params">scrollBox</span>)</span>.mouseenter(<span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;<br>            clear<span class="hljs-constructor">Interval(<span class="hljs-params">listTime</span>)</span>;<br>        &#125;)<br>        <span class="hljs-constructor">$(<span class="hljs-params">scrollBox</span>)</span>.mouseleave(<span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;<br>            listTime = set<span class="hljs-constructor">Interval(<span class="hljs-params">listGo</span>, 20)</span>;<br>        &#125;)<br></code></pre></td></tr></table></figure><p>由于我是先写好静态页面再实现滚动的，所以没有特别设置CSS样式</p><p>在$(function(){})中调用，直接调用，即可实现打开页面向上轮播li列表</p><p>注：这个方法可能造成轮播时图片、文字抖动，暂时还没想到解决办法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax返回error可能出现的问题</title>
    <link href="/2022/08/06/Ajax%E8%BF%94%E5%9B%9Eerror%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/06/Ajax%E8%BF%94%E5%9B%9Eerror%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>AJAX常用于浏览器与Web服务器之间的异步通信,使得网页无需从服务端获取过量的数据</p><span id="more"></span><ol><li>dataType错误</li></ol><p>　　我遇到的就是这个dataType错误，即后台返回的dataType类型与前台写的不一致，一般前台写json没问题，大部分是后台返回的类型对不上</p><ol start="2"><li>async请求同步异步问题</li></ol><p>　　这个没有遇见过很少碰到类似的问题</p><p> 　async默认是true(异步请求),如果想一个Ajax执行完后再执行另一个Ajax, 需要把async=false</p><p>　　这是别人的总结，可以参考一下：</p><p>　　如，你用post请求传值到另一个页面后台，但是页面一加载你的ajax就已经执行过了，传值接收是在后台才完成的，这时候就请求不到数据，所以可以考虑把ajax请求改为同步试试。</p><ol start="3"><li>data不能为空</li></ol><p>即便为空也一定要传” { } “，不然返回的是xml格式</p><ol start="4"><li><p>传递的参数必须是ajax支持的编码格式</p></li><li><p>URL路径不可为中文</p></li></ol><p>在error函数中填入 ： XMLHttpRequest, textStatus, errorThrown这几个参数，可输出调试信息</p><p><strong>status</strong> ：<strong>输出为HTTP状态码</strong>，可直接理解</p><p><strong>readyState: 状态码</strong><br>0 － （未初始化）还没有调用send()方法<br>1 － （载入）已调用send()方法，正在发送请求<br>2 － （载入完成）send()方法执行完成，已经接收到全部响应内容<br>3 － （交互）正在解析响应内容<br>4 － （完成）响应内容解析完成，可以在客户端调用了</p><p><strong>textStatus</strong>输出为parsererror，则问题就是返回类型不一致了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java ArrayList源码详解</title>
    <link href="/2022/08/06/Java-ArrayList%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/08/06/Java-ArrayList%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>ArrayList是Java集合常用的数据结构之一，继承自AbstractList，实现了List，RandomAccess、Cloneable、Serializable等一系列接口…………</p><span id="more"></span><p><strong>简介</strong></p><p>ArrayList是Java集合常用的数据结构之一，继承自AbstractList，实现了List，RandomAccess、Cloneable、Serializable等一系列接口，支持快速访问，复制和序列化。底层是基于数组实现容量大小动态变化，允许null值存在。</p><p><strong>部分源码分析</strong></p><p>ArrayList的底层是由数组实现</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180401.png"></p><p>默认size的初始大小为10：<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180551.png"></p><p>ArrayList定义了两个类常量数组：EMPTY_ELEMENTDATA（EE）和DEFAULTCAPACITY_EMPTY_ELEMENTDATA（DEE）</p><p>注释：EE，用于ArrayList空实例的共享空数组实例</p><p>DEE，用于默认大小空实例的共享空数组实例，将EE和DEE区分开，以便在添加第一个元素时知道要增加多少<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180614.png"></p><p>三个构造函数，包括一个无参构造和两个有参构造：<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180648.png"></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180701.png"></p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180711.png"></p><p>注：无参构造创建的实例是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，有参构造创建的实例是EMPTY_ELEMENTDATA</p><p>然后是add( )方法：<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180744.png"></p><p>当第一次调用add(E e)方法时，判断是不是无参构造方法创建的对象，如果是，则将DEFAULT_CAPACITY作为ArrayLiat的容量，此时minCapacity = 1<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180802.png"></p><p>还有其他add方法例如：</p><p> addAll( Collection&lt;? extends E&gt; c )<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180818.png"><br>add( int index, E element )<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180851.png"></p><p>等等….这些方法中都包含ensureCapacitylnternal( int Capacity )方法，确保无参构造在创建实例并添加第一个元素时，最小的容量是默认大小10。</p><p>　　而有参构造创建空实例后，在add( E e )方法添加元素扩容情况是这样的：</p><p><strong>新容量为旧容量的1.5倍</strong><br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180911.png"></p><p>在Java7中，ArrayList的构造方法只有EMPTY_ELEMENTDATA即EE, 而Java8中DEE代替了EE，但是原来的EE还存在，只是作用改变了：<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180926.png"></p><p> 　当容量为0时，会创建一个空数组，赋值给elementData，当一个应用中有很多这样的ArrayList空实例时，就会有很多空数组，这样使用EMPTY_ELEMENTDATA就是为了优化性能，所有的ArrayList空实例都指向同一个数组。而DEE（DEFAULTCAPACITY_EMPTY_ELEMENTDATA）就是为了保证无参构造方法常见的实例在添加第一个元素时，最小的容量是默认的10.</p><p> <strong>ArrayList的扩容</strong></p><p> 以无参构造为例：</p><p>首先无参构造初以默认大小来始化内部数组<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806180949.png"></p><p>然后是扩容，使用add( )方法<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806181005.png"></p><p>ensureCapacityInternal方法中的size代表执行添加前的元素个数，通过现有的元素个数数组的容量进行对比，若需要扩容则扩容。</p><p> ensureCapacityInternal(size + 1)就是将要添加的额元素放入数组中</p><p>扩容条件：若数组的长度eleentData的长度小于做小需要的容量minCapacity，就需要扩容<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806181021.png"></p><p>扩容逻辑：<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806181021.png"></p><p>注：</p><p>\1. &gt;&gt;位运算，右移一位代表oldCapacity / 2，位运算效率更高</p><p>\2. JDK7后增加对元素个数的最大个数判断，MAX_ARRAY_SIZE为int最大值减去8</p><p>\3. 复制元素方法扩容。使用延迟分配对象数组空间，当数组加满数组容量后才会按照1.5倍扩容。</p><p><strong>ArrayList的remove( int index )方法</strong><br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806181055.png"></p><p>当我们调用remove( int index )时，首先调用rangrCheck( ) 方法检查index是否合法，再判断要删除的元素是否位于数组的最后一个位置。</p><p>当index是最后一个，则直接将数组的最后一个位置置空，即size-1即可；</p><p>当index不是最后一个，调用System.arraycopy( )方法复制数组，将从index+1开始，所有元素都往前挪一个位置，再将数组最后一个位置置空。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中的==和equals( )方法比较</title>
    <link href="/2022/08/06/Java%E4%B8%AD%E7%9A%84-%E5%92%8Cequals-%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <url>/2022/08/06/Java%E4%B8%AD%E7%9A%84-%E5%92%8Cequals-%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<p>在Java中，equals和==都是用于检测两个字符串是否相等，返回类型也都是boolean值，但是二者内部处理却不一样…………</p><span id="more"></span><p>在Java中，equals和==都是用于检测两个字符串是否相等，返回类型也都是boolean值，但是二者内部处理却不一样。</p><h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals( )"></a>==与equals( )</h3><p>==在Java中是一个二元操作符，用于比较原生类型和对象。当比较基本类型时，较为好理解；当比较对象时，比较规则是：两个对象基于内存引用，若两个对象的引用完全相同，则==返回的结果为true。</p><p>equals( )方法是Object( )类中，根据具体的业务逻辑来定义该方法，用于检查两个对象的相等性。默认是equals方法实现与==操作是一样的，所以在业务中一般都会重写equals( )。</p><h3 id="和equals比较时"><a href="#和equals比较时" class="headerlink" title="==和equals比较时"></a>==和equals比较时</h3><p>1.如果比较基本数据类型（或者说是值变量）</p><p>当时Java的基本类型做比较时，应使用 == 比较的是他们的值，而equals是不存在的。因为int float等是基本数据类型，没有equals( )方法，不存在int.equals( )</p><p>2.如果比较的是复合数据类型（或者说是引用型变量）</p><p>当比较引用型变量时：</p><p>==比较的是两个引用是否指向同一个对象实例</p><p>equals( )比较看是否被重写，如果有被重写则按照重写的规则比较，没有重写则与==比较规则一样。</p><p>（下图为String中重写的equals( )方法）<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806175443.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b+ 32位arm架构安装JDK</title>
    <link href="/2022/08/06/%E6%A0%91%E8%8E%93%E6%B4%BE3b-32%E4%BD%8Darm%E6%9E%B6%E6%9E%84%E5%AE%89%E8%A3%85JDK/"/>
    <url>/2022/08/06/%E6%A0%91%E8%8E%93%E6%B4%BE3b-32%E4%BD%8Darm%E6%9E%B6%E6%9E%84%E5%AE%89%E8%A3%85JDK/</url>
    
    <content type="html"><![CDATA[<p>树莓派虽然体积很小,但功能相当齐全.有幸3年前接触到树莓派,并使其成为我的Linux入门老师,感谢…………</p><!-- moew --><p>如图我的Raspbian系统如下图版本信息：<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806174245.png"></p><p>可以看到是armv7l，我查了一下是32位的arm架构，即下载第一个就好了<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806174313.png"></p><p>通过SSH Secure Shell远程上去把压缩包或者解压后的文件传过去<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806174410.png"></p><p>这样拖过去有个问题，需要改文件JDK文件夹的权限<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806174453.png"></p><p>然后配上环境变量，就可以啦，最好重启下树莓派，重启之后java -version 验证一下<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806174513.png"><br>java c 试一下,OK了<br><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806174602.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows dos下Mysql中文乱码</title>
    <link href="/2022/08/06/Windows-dos%E4%B8%8BMysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <url>/2022/08/06/Windows-dos%E4%B8%8BMysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>在dos客户端输出窗口中查询表中的数据,还有项目部署到服务器上时前台的页面，中文数据都显示成乱码…………</p><span id="more"></span><p>在dos客户端输出窗口中查询表中的数据,还有项目部署到服务器上时前台的页面，中文数据都显示成乱码，如下图所示：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806173201.png"></p><p>这个问题困扰了我一天，后来解决了才发现原来我的方向错了，一直我以为是SpringBoot项目的原因，因为之前我已经检查过数据库这边的字符集问题，把所有字符集更改成utf8,包括这个character-set-result=utf8,如下图：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806173640.png"></p><p>结果后来仔细一查才发现，原来我的win7默认使用字符集是GB2312，所以在输出窗口使用的字符集不是UTF8而是GB2312，更改后如下图：</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806173708.png"></p><p>注：网上有人问再次打开又回到原来的编码，这个我重启项目还没有碰到，依旧是可以显示中文。实在不行可以把设置字符集的那段命令写入my.ini文件中去（重启生效）</p><p>说到底还是个菜鸡，欢迎交流</p><p>知识补充：</p><p>GB2312是GBK的子集，是简体中文的码。GBK是包含中日韩大字符集合，支持简体和繁体</p><p>UTF-8包含大部分文字的编码，支持几乎所有字符</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>建站所想</title>
    <link href="/2022/08/06/%E5%BB%BA%E7%AB%99%E6%89%80%E6%83%B3/"/>
    <url>/2022/08/06/%E5%BB%BA%E7%AB%99%E6%89%80%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>关于建站的一些思考以及后续的想法</p><span id="more"></span><p>终于把站点弄好啦！！！经过一整天（抽空摸鱼）翻查资料终于搞定了。实际操作完觉得部署这个还算不难，细心一些基本没什么问题。</p><p>目前的实现是：在腾讯云服务器上基于的Hexo框架搭建本地博客，并发布到Github Pages上。</p><p>应该有不少人是跟我一样的配置，云服务器最大的优点就在于跨平台，只要有一台能上外网的设备，就可以随时随地无缝衔接工作。当然，本地PC用户也不在少数，大家都比较养老。</p><p>这篇文章对我建站很有帮助，写的很全面，有详有略。前面简单的操作带过了。比较适合半生不熟的盆友（例如我）。我也是在部署到github上的时候才发现这篇文章，老后悔了，前面踩了很多坑。在发布的时候配置文件中不小心把分支配置成mian，默认的主支是main，所以我每次发布都会新建一个分支，就很离谱……还有部署的时候因为网络原因卡住，网上都会有对应的解决办法。其实只要仔细认真一点就不太会出现问题，整套流程下来还是蛮简单的。</p><p>这里介绍了从基本的环境搭建，到Github建库、安装Hexo、发布到github，还包括一些其他有意思的功能，想要在Github上建站的朋友，一定不能错过。</p><p>注意这里的本地环境是windows</p><p><a href="https://blog.csdn.net/yaorongke/article/details/119089190">https://blog.csdn.net/yaorongke/article/details/119089190</a></p><p>实际上白天的时候就已经把页面整出来了，晚上回家后花了很多时间思考用哪个主题，最后决定使用fluid。这是看起来比较舒服、流畅度高，且没有什么bug的主题了。</p><p>这是fluid主题的官网</p><p><a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></p><p>这是目前最开始的状态，只要一个例子和一个Demo。我打算有空的时候先把自己博客园上一些“自我感觉不错的文章”拷过来，当然文章来源不仅是博客园，还有我的公众号&amp;个人随笔&amp;互联网上所有我认为值得记录的东西。</p><p><img src="https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806095113.png"></p><p>当然这个平台也有一定的缺点，那就是文章只适合阅读，不适合修改。无法像博客园那样拥有后台管理系统，能够随时修改博客。如果需要修改文章就会重新发布，发布时间也会修改。</p><p>残余问题：</p><ol><li>备份。由于Hexo框架中的文档全都在云服务器内，一旦云服务器有问题就有可能会影响我的博客，因此后期在备份上需要花店时间研究一下。</li><li>使用。在Hexo框架中，并不能直接将md文件上传至服务器，Hexo有一定的规则，需要使用自带的命令来创建文章，这个也有点麻烦，需要适应一个新的写作环境。</li><li>图床。图片直接放在md中是没办法显示到网页上的，因为位置仍旧是本地电脑的，因此需要找一个平台上传图片，或者将图片一起打包传至服务器。<ul><li>0806已解决，仍然利用github仓库，通过PicGo上传。PicGo使用教程如下：</li><li><a href="https://blog.dgut.top/2020/07/10/hexo-pic/">https://blog.dgut.top/2020/07/10/hexo-pic/</a></li><li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/">https://picgo.github.io/PicGo-Doc/zh/guide/</a></li></ul></li><li>广告。在打开主题案例网站的时候发现居然有Google的广告，这是我不能忍受的。但后来发现出现的频率并不是很高，就罢了。</li><li>美化。现在的框架只是一个非常简单、官方的状态，需要后续长期维护，在官方的基础上小修小改，最后变成真正自己的网站，加油！奥利给！现在是8.06凌晨12点01分，该睡觉了。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/05/hello-world/"/>
    <url>/2022/08/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
