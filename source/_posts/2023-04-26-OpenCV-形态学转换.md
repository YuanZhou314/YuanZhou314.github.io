---
title: OpenCV-形态学转换
categories:
  - Study
tags:
  - Python
index_img: 'https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202304251519018.png'
abbrlink: af40d2f8
date: 2023-04-26 15:57:10
---

<!-- more -->
<!-- categories:Dev、Ops、Study、Sth、News、work-->
<!-- tags: 
Python、MySQL、LeetCode、机器学习、Linux、Big Data、Java、BlockChain、Docker、Web 、分布式、
Maven、数据结构、JVM、JavaScript、Crontab、Shell、Ubuntu、VPN、NodeJS、String、VM、Hadoop、
Life、树莓派、Git、Hexo、算法、运维、网络、看法、电影、美学、写作、哲学、文档、绘画、前端、
历史、政治、社会、导购
 -->
## 侵蚀与膨胀

### 膨胀

膨胀和侵蚀从数学的角度说，都是将图像或图像的一部分与核进行卷积。核可以是任意大小和形状，有一个单独定义出来的点，称之为锚点。膨胀是针对白色部分而言的。膨胀就是对高亮部分进行扩张，侵蚀就是对高亮部分进行收缩。

而膨胀就是求局部最大值的操作。将核与图形进行卷积，**计算该核覆盖区域的像素点的最大值，并将这个最大值赋值给参考点指定的像素**。这样就使得图像中高亮区域逐渐增长。一般来说，设置一个3*3的核，锚点位于核的中心，使用核遍历所有待处理像素，遍历时，锚点对齐待处理像素，且遍历的是原图，而不是膨胀某个像素后的图像。核的大小和形状（通过cv2创建的核）可以自定义，但是锚点必须在核内。


膨胀原理视图
![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202304251700944.png)

```python
qs=cv2.imread("D:\\z-bank\\bank\\PY\\corrode.png")
kernel=np.ones((3,3),dtype=np.uint8)  # 创建一个3*3的矩形核
dilate=cv2.dilate(qs,kernel,1)  # 膨胀，迭代次数为1
cv_show("dilate",dilate)
```

补充：上方创建`kernel`时，是通过numpy创建的，也可以通过`cv2.getStructuringElement()`函数创建，如：

```python
kernel=np.ones((3,3),np.uint8)
kernel2=cv2.getStructuringElement(cv2.MORPH_RECT,(3,3)) 
```

两种方式创建的核是一样的，都是3*3的矩阵，值都是1，只是类型不一样，kernel是np.uint8，kernel2是np.int32。
但是`getStructuringElement()`函数可以创建更复杂的核，如椭圆形，十字形等。

膨胀效果如下，膨胀之后毛刺部分变粗，字体中间的间隙也变小了。如果增加核的大小，相当于ps中的画笔直径变大，膨胀的效果也会更明显。
![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202304251734416.png)



**膨胀的实际运用**
将一段英文文本转换为黑白图像，然后对图像进行膨胀操作，英文字符之间的间隔被填充了，这样就可以将文本分割成单个字符，遍历进行OCR识别。


### 侵蚀

侵蚀是膨胀的反向操作，同样是将图像与核做卷积，但是计算的是局部最小值，然后将这个最小值赋值给参考点指定的像素。这样就使得图像中高亮区域逐渐减少。

```python
erosion=cv2.erode(qs,kernel,1)  # 侵蚀，迭代次数为1
```

## 开运算与闭运算

使用`cv2.morphologyEx()`函数进行开闭运算，第一个参数是原图，第二个参数是运算类型，第三个参数是核，第四个参数是迭代次数。

运算类型有如下几种：
- cv2.MORPH_OPEN 开运算
- cv2.MORPH_CLOSE 闭运算
- cv2.MORPH_GRADIENT 形态学梯度
- cv2.MORPH_TOPHAT 顶帽
- cv2.MORPH_BLACKHAT 黑帽

开运算指的是先将图像先进行侵蚀，再进行膨胀，这样就可以去除图像外部的细节（噪声）。一般用于获取图像中的主要对象。如下，5次开运算后，图片周围的白点被去除了。

```python
qs2=cv2.morphologyEx(qs,cv2.MORPH_OPEN,kernel,iterations=5) # 开运算

```
效果图：
![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202304261443168.png)


闭运算时，先膨胀后侵蚀，用于填充/连接被误分为许多小块的对象，或关闭前景对象内部的小孔。如下，7次闭运算后，图片中的字体被填充了。
```python
qs2=cv2.morphologyEx(qs,cv2.MORPH_CLOSE,kernel,iterations=7) # 闭运算
```

效果图：
![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202304261452641.png)


## 形态学梯度
梯度计算主要显示的是图像的边缘，也就是膨胀与侵蚀的差值。看起来像是图像的轮廓。
```python
grd=cv2.morphologyEx(qs,cv2.MORPH_GRADIENT,kernel) # 形态学梯度运算
```
效果图：
![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202304261509383.png)


## 顶帽与黑帽
- 顶帽计算：原图像-开运算之后的图像
- 黑帽计算：闭运算后的图像-原图像

例如上面开运算的例子，开运算后字体周围的毛刺和上面的曲线被去掉了，顶帽计算就是将开运算去掉的这些毛刺和曲线提取出来。
```python
top_hat=cv2.morphologyEx(qs,cv2.MORPH_TOPHAT,kernel) # 顶帽运算
```

![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202304261533780.png)

闭运算后，字体中间的空隙被填充了，黑帽计算就是将这些空隙提取出来。
```python
black_hat=cv2.morphologyEx(qs,cv2.MORPH_BLACKHAT,kernel) # 黑帽运算
```
![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202304261536402.png)



## 已被骂醒，暂时结束课程
![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202304261555948.png)


