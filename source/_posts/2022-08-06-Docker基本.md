---
title: Docker基本
tags: Docker
categories: Ops
index_img: 'https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/docker0.png'
abbrlink: 446df500
date: 2022-08-06 19:50:14
---

<!-- more -->

# 单体Docker

 

## Docker

![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/20220806195111.png)

 

 

Docker出现的契机：解决项目中的环境问题。docker的图标：鲸鱼上放了许多集装箱，也映射了docker的核心思想——隔离。每个箱子是互相隔离的。隔离机制也可以将linux服务器利用到极致

 

深究历史

2010年出现dotcloud，2013年开源后使用人数增多。2014年Docker1.0发布，基于Go语言开发。Docker优势是非常轻巧，在Docker之前一般都是使用虚拟机，非常笨重。Docker是容器技术，也属于一种虚拟化技术。一般linux最核心的环境不过4MB。

 

Docker与VM虚拟技术

虚拟机技术缺点：资源占用多、冗余步骤多、启动慢

容器化技术：不是模拟一个完整的操作系统

 

差异点：

1. 传统虚拟机先虚拟出一套硬件，运行完整的操作系统，再在系统上运行软件
2. 容器内的应用直接运行在宿主机的内容，容器本身无内核，也没有硬件，且容器间互相隔离，文件系统都是不一样的

 

优势：

1. 应用更快速的交付和部署

2. - 传统交付需要借助文档、安装程序
   - docker打包镜像后发布测试，一键运行

3. 更便捷的升级和扩缩容

4. - 部署应用快捷、项目打包为镜像后扩展方便

5. 更简单的系统运维

6. - 开发、测试等环境高度一致

7. 更高效的计算资源利用

8. - 内核级别的虚拟化，在一台物理机上可运行多个容器实例，服务器性能充分利用

 

## **Docker安装**

 

架构图：

![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/20220806195138.png)

名词解释：

1. 镜像：相当于一个模板，通过镜像来创建容器。一个镜像可以创建多个容器
2. 容器：通过容器可以独立运行一个或一个组应用，有启动、停止、删除等基本操作
3. 仓库：存放镜像的地方，有共有仓库和私有仓库

 

更换阿里云镜像地址：yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

安装教程（linux）：https://docs.docker.com/engine/install/centos/

配置阿里云镜像加速（教程地址：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors）：

```
#修改daemon配置文件/etc/docker/daemon.json来使用加速器
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://1fd77tzz.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

 

 

# Docker命令

工作原理

docker是一个Client-Server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问。DockerServer接收到DockerClient的指令，就会执行这个命令。docker中容器之间相互隔离，外部不能直接访问容器。

![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/20220806195206.png)

docker比vm快的原因

vm对比dc架构：

![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/20220806195217.png)

docker比vm少了一层Guest OS。直接利用宿主机的内核。因此在新建容器时，无需想vm一样加载一个操作系统内核，省略了这个复杂的过程，加载时间是秒级的

![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/20220806195228.png)

 

### 帮助命令

docker version 版本信息

docker info 系统和容器相关信息

docker --help 帮助 ，官网文档地址：[https://docs.docker.com/engine/reference/commandline/](https://docs.docker.com/engine/reference/commandline/build/)

 

### 镜像命令

### docker images 查看所有本地的主机上的镜像

 -a, --all       Show all images (default hides

​            intermediate images)# 列出所有镜像

   --digests     Show digests

 -q, --quiet      Only show image IDs #只显示镜像ID

### docker search 搜索镜像

-f, --filter filter  Filter output based on conditions provided#过滤搜索

例如：docker search --filter=stars=5000 #寻找stars大于等于5000的镜像

### docker pull 下载镜像

```
格式：docker pull 镜像名[:tag]（版本）
Using default tag: latest #如果不写tag则是默认mlatest
latest: Pulling from library/mysql
a10c77af2613: Pull complete  #分层下载，docker images的核心：联合文件系统
b76a7eb51ffd: Pull complete  #当下载其他镜像时，若有相同层的镜像，则不会重新下载，直接共用
258223f927e4: Pull complete
2d2c75386df9: Pull complete
63e92e4046c9: Pull complete
f5845c731544: Pull complete
bd0401123a9b: Pull complete
3ef07ec35f1a: Pull complete
c93a31315089: Pull complete
3349ed800d44: Pull complete
6d01857ca4c1: Pull complete
4cc13890eda8: Pull complete
Digest: sha256:aeecae58035f3868bf4f00e5fc623630d8b438db9d05f4d8c6538deb14d4c31b #签名
Status: Downloaded newer image for mysql:latest 
docker.io/library/mysql:latest  #真实地址，docker pull mysql 等价于docker pull docker.io/library/mysql:latest
```

###  docker rmi 删除镜像 rm代表删除，i代表image

```
-f, --force      Force removal of the image #强制删除镜像
```

例如：

删除指定镜像：docker rmi -f ID/image名，

删除全部镜像：docker rmi -f $(docker images -aq)

 

## 容器命令（有镜像才可以创建容器）

### docker run 启动容器

先在本机寻找镜像，找不到则去dockerHub上下载，还找不到就报错，找到了就下载到本地，并使用

```
docker run [可选参数] image
--name="Name" 容器名字，用于区分容器
-d                        后台方式运行
-it                        使用交互方式运行，进入容器查看内容
-p                        使用容器的端口，-p 8080:8080
        -p ip:主机端口:容器端口
        -p 主机端口:容器端口（常用）
        -p 容器端口
            容器端口
-P（大写）    随机指定端口
```



```
启动并进入镜像，交互工具使用bash
[root@VM-0-7-centos ~]# docker run -it centos /bin/bash  
[root@2b902d8d2492 /]# ls  #镜像内部是一个并不太完整的centos系统，很多命令是没有的
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
```

 

###  exit 退出至主机



```
exit    直接停止容器并退出
Ctrl + P + Q 容器不停止
[root@2b902d8d2492 /]# exit
exit
[root@VM-0-7-centos ~]# ls /
bin  boot  data  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@VM-0-7-centos ~]#
```

 

### docker ps 列出容器

```
-a    列出当前正在运行的容器和历史运行过的容器
-n=?  列出最近创建的容器 ?为个数
-q    只显示容器编号
```



```
[root@VM-0-7-centos ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@VM-0-7-centos ~]# docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                     PORTS     NAMES
2b902d8d2492   centos         "/bin/bash"   3 minutes ago   Exited (0) 2 minutes ago             vibrant_torvalds
184d14eb101f   feb5d9fea6a5   "/hello"      8 days ago      Exited (0) 8 days ago                stoic_fermi
[root@VM-0-7-centos ~]#
```

 

### docker rm 删除容器

```
docker rm 容器名 删除指定容器，不能删除正在运行的
docker rm -f 强制删除容器
docker rm -f $( docker ps -aq ) 强制删除所有容器，等同于docker ps -a -q | xargs rm 使用管道删除
```

# 容器基本操作命令

容器的启动、重启、停止和强制停止

```
docker start[ -i] id 
docker restart id
docker stop id
docker kill id
```

 

## 其他命令

### 后台启动容器

```
当使用后台启动容器、且容器创建后没有对外的服务时（如nginx），创建后就会立刻停止容器。所以容器使用后台启动时，一定要有一个前台进程
[root@VM-0-7-centos ~]# docker run -d centos
41730bcd96cf85f682b13b2346ef6701868981f68d4c4c2e0b4930c02e17a874
[root@VM-0-7-centos ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@VM-0-7-centos ~]# docker ps -a
CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES
41730bcd96cf   centos    "/bin/bash"   8 seconds ago   Exited (0) 7 seconds ago             eager_gauss

注意，这样是正常的。具体原因不详：docker run -d --name nginx74 -p 7474:80 nginx
```

 

### 查看日志

```
docker logs -tf --tail 10 容器ID  查看最后10条实时日志
docker logs -tf 容器ID  查看所有日志、实时
```

 

### 查看容器中的进程



```
[root@VM-0-7-centos ~]# docker top d3b2db3e0491
UID             PID             PPID           C         STIME               TTY             TIME        CMD
root            15252           15234          0         21:13               ?               00:00:00    /bin/sh -c while true;do echo yuanzhou;sleep 2;done
root            28124           15252          0         21:24               ?               00:00:00    /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 2
```

 

### 查看镜像元数据

```
docker inspect 容器ID
[
    {
        "Id": "d3b2db3e0491e4caa4434343c2c8860db8442c6ac03295b46f7d679e1180066f",
        "Created": "2021-11-30T13:13:56.884601581Z",
        "Path": "/bin/sh",
        "Args": [
            "-c",
            "while true;do echo yuanzhou;sleep 2;done"
        ],
        "State": {
            "Status": "running",
………………
```

 

### 进入当前正在运行的容器

```
docker exec -it ID bashShell 开启一个新的终端，可以在里面操作（常用）
```

```
[root@VM-0-7-centos ~]# docker exec -it d3b2db3e0491 /bin/bash
[root@d3b2db3e0491 /]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 13:13 ?        00:00:00 /bin/sh -c while true;do echo yuanzhou;sleep 2;done
root      1264     0  0 13:55 pts/0    00:00:00 /bin/bash
root      1279     1  0 13:55 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 2
root      1280  1264  0 13:55 pts/0    00:00:00 ps -ef
```

 

```
docker attach ID 进入容器正在执行的终端，不启动新进程，不常用
```

 

### 从容器内拷贝文件到主机

```
[root@VM-0-7-centos ~]# docker exec -it 17a7dca3d597 /bin/bash
[root@17a7dca3d597 /]# cd
[root@17a7dca3d597 ~]# ls
anaconda-ks.cfg  anaconda-post.log  original-ks.cfg  yuanhou.sh
[root@17a7dca3d597 ~]# exit
exit
[root@VM-0-7-centos ~]# docker cp 17a7dca3d597:/root/yuanhou.sh /root/   #与scp写法类似
[root@VM-0-7-centos ~]# ll
总用量 1340
-rw-r--r-- 1 root root 1362341 11月 29 22:25 single_table.sql
drwxr-xr-x 3 root root    4096 9月  17 22:43 test
-rw-r--r-- 1 root root      16 11月 30 22:18 yuanhou.sh
```

 

 

### 查看docker的CPU状态

```
docker stats
```

 ![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/20220806195355.png)

 

使用docker安装nginx、tomcat

注：容器中的命令较少，且tomcat中的镜像是保证最小可运行的镜像，连webapps都需要从其他目录copy过来

 

安装elasticsearch:

docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms64m -xmx512m" -e "discovery.type=single-node" elasticsearch:7.6.2 /bin/bash

[root@VM-0-7-centos ~]# curl localhost:9200

{

 "name" : "dda2ff33a70e",

 "cluster_name" : "docker-cluster",

 "cluster_uuid" : "ECsYrnfeTl-hxGllhDXSvg",

 "version" : {

  "number" : "7.6.2",

  "build_flavor" : "default",

  "build_type" : "docker",

  "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",

  "build_date" : "2020-03-26T06:34:37.794943Z",

  "build_snapshot" : false,

  "lucene_version" : "8.4.0",

  "minimum_wire_compatibility_version" : "6.8.0",

  "minimum_index_compatibility_version" : "6.0.0-beta1"

 },

 "tagline" : "You Know, for Search"

}

[root@VM-0-7-centos ~]#

 

 

ES+kibna：数据可视化，涉及到两个容器的网络连接。

 

安装docker可视化面板portainer(一般不会用)

```
docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

注：针对容器启动后就停止有两种可能，一种是容器内部没有前台进程，如nginx这种，启动之后就会立刻退出。还有一种是ela这种需要超大内存的容器，启动之后直接把一核1G内存的云主机CPU挤爆了，这种就需要对其资源占用做限制，如添加 -e ES_JAVA_OPTS="-Xms64m -xmx512m" 以限制jvm的资源

 

 

# Docker镜像

 

联合文件系统：UFS是一种分层、轻量级、高性能文件系统，Union文件系统是镜像的基础，联合加载会把各层文件系统叠加起来，最终文件系统会包含所有底层文件和目录

 

## 镜像加载原理

bootfs包含加载系统，镜像的最底层。与典型的linux是一样的，包含boot加载器和内核，当boot加载完成后，整个内核都在内存中，此时内存的使用权就由boofs转交给内核，系统也会卸载bootfs

 rootfs：在bootfs之上，包含/dev、/proc、/etc等标准目录，就是不同操作系统发行版，如乌班图、centos等

 

![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/20220806195421.png)

 

 

Docker进项都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层就是通常说的容器层，容器之下的都叫镜像层

 

![](https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/20220806195434.png)

 

### commit镜像

```
docker commit 提交容器称为一个新副本
-m 描述信息
-a 作者 容器id 目标镜像名：[tag] 
```

修改原有镜像后，通过docker commit -m xxx -a xxx打包成一个新的镜像。因此如果想要保存一个容器当前的状态，必须通过commit来提交，获得新的镜像。类似虚拟机中的快照
