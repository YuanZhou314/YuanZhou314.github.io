---
title: Java-JVM内存区域划分
date: 2022-08-06 18:22:43
tags:
- Java
- JVM
categories: 
- Study
index_img: https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/old/JVM.png
---

<!-- more -->

发现网上有两个版本的JVM内存划分，一个是按照《深入理解JVM虚拟机》上的版本，包含程序计数器等，按照是否线程共享划分。

另一个我觉得更好记一些，也更适合我自己，在这里记录一下。

首先上思维导图：
![](https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806182340.png)

一个个来说道吧。

**堆内存 heap**

堆内存主要被划分为新生代和老年代（叫法不一，差不多的意思）。JVM默认Yong和Old分配比例为1:2，即新生代的内存大小为堆内存的1/3。

（调整参数：–XX:NewRatio）

基本上所有对象实例都在堆中创建，因此堆内存经常发生GC回收操作。新的对象首先分配在Eden区，两个Surviior区仅作为Eden区的缓冲使用。每次GC回收一次，对象的age值就+1，当Survivor区对象age值大于15时，就被转移到老年代。

（age值调整参数：-XX:MaxTenuringThreshold）

新生代下又划分为三个区，即Eden Space，To Survivor ，From Survivor。新生代占用堆内存的1/3，而三个区的内存占用情况如下图:
![](https://raw.githubusercontent.com/YuanZhou314/PicRepo/main/imgs/20220806182358.png)


新生代中，Eden、from、to的默认比例为8：1：1，一般来说，当Eden区内存将要被占满时，才会进入其中一个Survivor区。JVM每次只会使用一块Survivor区来为对象服务。所以，不论何时，都存在一个空闲的Survivor区域

（调整参数：–XX:SurvivorRatio ）

 

老年代存放JVM认为生命周期较长的对象，内存大小也比较大，GC回收相对来说不太频繁，所以分配给老年区的内存大小为堆内存的2/3

堆内存回收规则：

当一个对象小于Eden区内存时，直接放入Eden区，若大于Eden并小于老年代，则直接放入老年代。若大于老年代，则直接内存溢出

如此分区的目的：

新生代由于对象产生的比较多并且大都是朝生夕灭的，所以直接采用标记-清理算法。而老年代生命力强，采用复制算法，针对不同情况使用不同算法
