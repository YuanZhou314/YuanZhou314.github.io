---
title: 关于近期较火的ChatGPT的一些尝试……
categories:
  - Dev
tags:
  - Python
abbrlink: f439431f
date: 2023-03-08 14:25:38
index_img:
---

<!-- more -->
<!-- categories:Dev、Ops、Study、Sth、News、work-->
<!-- tags: 
Python、MySQL、LeetCode、机器学习、Linux、Big Data、Java、BlockChain、Docker、Web 、分布式、
Maven、数据结构、JVM、JavaScript、Crontab、Shell、Ubuntu、VPN、NodeJS、String、VM、Hadoop、
Life、树莓派、Git、Hexo、算法、运维、网络、看法、电影、美学、写作、哲学、文档、绘画、前端、
历史、政治、社会、导购
 -->
基于文本预训练的GPT-1，GPT-2，GPT-3三代模型都是采用的以Transformer为核心结构的模型，不同的是模型的层数和词向量长度等超参（Trm是一个Transforme结构），它们具体的内容如下图：

<img src="https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/202303031120701.png" style="zoom: 33%;" />

InstructGPT包含一系列GPT模型

* GPT-1: text-Davinci-001(2018)
* GPT-2: text-Davinci-002(2019)
* GPT-3: text-Davinci-003(2020)

聊天生成型预训练变换模型（Chat Generative Pre-trained Transformer），简称ChatGPT。2022年11月由OpenAI开发的人工智能聊天机器人程序。ChatGPT以文字方式交互，可用于相对复杂的语言工作，包括自动文本生成、自动问答、自动摘要等在内的多种任务，还具有编写和调试计算机程序的能力。

ChatGPT是OpenAI对InstructGPT对话模型进一步微调（使用了推特的数据），算是Davinci-003的衍生产品，模型名：gpt-3.5-turbo。

国内注册方式：通过第三方SMS接码平台注册，例如https://sms-activate.org/

**InstructGPT与ChatGPT在训练上的不同：**

* InstructGPT训练目标是根据指令生成满足条件的自然语言文本，用于生成满足特定需要的文本，例如问题答案、摘要、代码
* ChatGPT训练目标是生成自然流畅的对话，实现机器与人类自然对话交互。ChatGPT使用了大规模对话数据来训练模型，使其理解自然语言语法、语义和上下文信息。因此ChatGPT主要用于生成对话

**InstructGPT与ChatGPT在使用上的不同体验：**

1. InstructGPT比ChatGPT更开放、具有创意，可以让它做很多种事情；ChatGPT在某些方面更聪明。
2. 训练InstructGPT的语料清洗程度相对少，表现得更像人类；ChatGPT会不断提示用户它的局限性。
3. 如果不使用“进一步思考一下……”这种引导性语句，InstructGPT可能无法解决部分问题；ChatGPT这方面更好用
4. InstructGPT未来会更加灵活通用，但它更适合提供API出来接入程序里，而不像ChatGPT那样做到开箱即用

ChatGPT价格：1000token 花费0.002美元

目前接入ChatGPT的公司

* Snapchat：社交
* Quizlet：学习
* Instacart：购物
* shop：购物
* speak：学习
  ……

## API调用

ChatGPT

```python
def openai_chat(question, api):
    '''
    基于 gpt-3.5-turbo 的 ChatGPT 机器人
    question::问题
    api_key::api_key
    '''
    openai.api_key = api_key
    data = [
        {"role": "user", "content": question}
    ]
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=data,
        max_tokens=3500,
        stop=None,
        temperature=0.7,
    )
    return response.choices[0].message.content.strip()+'\n'
```

whisper：

```python
def openai_tapy(filepath, api):
    '''
    whisper语音转文字
    filepath::录音文件,限制25MB,支持mp3, mp4, mpeg, mpga, m4a, wav, and webm等
    api_key::api_key
    '''
    openai.api_key = api_key
    audio_file = open(filepath, 'rb')
    transcript = openai.Audio.transcribe("whisper-1", audio_file)
    return transcript.get('text')
```

Telegram机器人()

```python
import json
from PY.tools.py import pyTools
import datetime
import time
import sys
import random
import re
import requests
import asyncio
import telegram
from telegram import Update, InlineQueryResultArticle, InputTextMessageContent
from telegram.ext import InlineQueryHandler, CommandHandler, ContextTypes, ApplicationBuilder, MessageHandler, filters
import logging
from PY.tools.py import pyTools

'''
仓库wiki：https://github.com/python-telegram-bot/python-telegram-bot/wiki/Introduction-to-the-API
官方教程(java)：https://core.telegram.org/bots/tutorial#first-run
'''

OPENAI_API = ''
TELEGRAM_TOKEN = ''

# 日志配置
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO)


# async def main():
#     向用户发送消息
#     bot = telegram.Bot('5999158932:')
#     async with bot:
#         await bot.send_message('6252946896', '您好，我是您的机器人贾维斯，很荣幸认识您！')


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #  接收/start命令，并返回指定语句
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="您好先生，我是Jarvis，您的tg助理！"
    )


async def echo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #  不处理消息，直接返回
    response_text = pyTools.openai_chat(
        update.message.text, OPENAI_API)
    await context.bot.send_message(chat_id=update.effective_chat.id,
                                   text=response_text)


async def caps(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #  将/caps 后面的字母大写后回显，例如/caps i love you ，回显I LOVE YOU
    text_caps = ' '.join(context.args).upper()
    await context.bot.send_message(chat_id=update.effective_chat.id, text=text_caps)


async def inline_caps(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # 添加内联模式(inline model)，类似在其他聊天中便捷调用机器人的功能
    query = update.inline_query.query
    if not query:
        return
    results = []
    results.append(
        InlineQueryResultArticle(
            id=query.upper(),
            title='Cps',
            input_message_content=InputTextMessageContent(query.upper())
        )
    )
    await context.bot.answer_inline_query(update.inline_query.id, results)


async def unknow(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #  识别未定义的命令
    await context.bot.send_message(chat_id=update.effective_chat.id,
                                   text='这是嘛意思？给我整不明白了都')

# 主函数入口
if __name__ == '__main__':
    # asyncio.run(main())
    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()
    start_handler = CommandHandler('start', start)
    echo_handler = MessageHandler(filters.TEXT & (
        ~filters.COMMAND), echo)  # filters包含众多过滤器，可过滤文本、图像、状态更新
    caps_handler = CommandHandler('caps', caps)
    unknow_handler = MessageHandler(filters.COMMAND, unknow)

    inline_caps_handler = InlineQueryHandler(inline_caps)

    #  将以创建的handles添加进application
    application.add_handler(start_handler)
    application.add_handler(echo_handler)
    application.add_handler(caps_handler)
    application.add_handler(inline_caps_handler)
    application.add_handler(unknow_handler)  # 需要最后添加，避免影响正常触发
    application.run_polling()

```


