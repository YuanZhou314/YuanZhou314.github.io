---
title: LeetCode-724. 寻找数组的中心下标
tags:
  - LeetCode
  - Java
categories: Study
index_img: 'https://blog-cnd-1307088890.cos.ap-guangzhou.myqcloud.com/leetcode.png'
abbrlink: ba18b6b1
date: 2022-08-06 20:15:01
---

<!-- more -->

给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

 

示例 1：

输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
示例 2：

输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
示例 3：

输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。

------

 

这道题并不是我自己想出来的，是看了题目下的评论分析了很久才想到的（惭愧了），我晚上回家后自己根据白天的思路写出来的。其实原理也挺巧妙的。除了特殊情况（中心索引为0）要额外考虑，其他都是正常的去比大小。做这种题目真的觉得自己人都傻了，连简单的比大小、加减法都不会做了。

分析：重点在于——中心下标的定义：其**左侧所有元素相加的和**等于**右侧所有元素相加的和**。∑左侧元素=∑右侧元素，千万不能直接去简单的想，遍历元素时把左侧元素之和加上、把右侧元素之和加上，然后再对比。这样我没试过啊，而且想一想就觉得效率太慢了。这样想才是正确的：∑a的左侧元素 = (∑0~a) - a ，同理，∑a右侧元素 = ( ∑所有元素 ) - ( ∑0~a )。由此对比就可算出数组中是否存在中心索引。

```
class Solution {
    public int pivotIndex(int[] nums) {
        int end=0,sum=0,flag = 0;
        for(int i=0; i<nums.length; i++){
            sum +=nums[i];
        }
        if(0 == sum-nums[0]){  //如果第一个元素右侧所有元素和为0，则中心索引为0
            return 0;
        }
        for(int j=0; j<nums.length; j++){ //必须从索引为0的元素开始加起，否则会漏掉一个元素
            flag += nums[j];  //当前循环中已遍历过的元素之和
            end = sum-flag;  //当前循环未遍历的元素之和
            if(end == flag){
                return j;
            }
        }
        return -1;  //如果没有对比出符合条件的，则返回-1
    }
}
```

 
